-- =============================================================================
-- ==========================  Full _release.sql file
-- =============================================================================
PRO Installing 3.0.0 (Kscope19)

--  sqlblanklines - Allows for SQL statements to have blank lines
set sqlblanklines on
--  define - Sets the character used to prefix substitution variables
set define '^'



-- *** DDL ***

-- #17
alter table ks_events add blind_vote_flag varchar2(1);
comment on column ks_events.blind_vote_begin_date is 'begin date of Public voting';
comment on column ks_events.blind_vote_end_date is 'end date of Public voting';
comment on column ks_events.blind_vote_flag is 'Indicates that the Public Voting will be "blind"';

-- #11
alter table ks_sessions add room_size_code varchar2(20);
comment on column ks_sessions.room_size_code is 'Define the size for a room S|M|L';

-- #13
alter table ks_users add expired_passwd_flag varchar2(1);
alter table ks_users add login_attempts number;
alter table ks_users add last_login_date date;
comment on column ks_users.expired_passwd_flag is 'Set to Y when the account password is expired.';
comment on column ks_users.login_attempts is 'Number of unsuccessful login attempts since last login';
comment on column ks_users.last_login_date is 'Date the user was las successful login in';


-- #16
-- Changes made by Ben Shumway
alter table ks_full_session_load add presented_anything_ind varchar2(4000);
alter table ks_full_session_load add presented_anything_where varchar2(4000);
comment on column ks_full_session_load.presented_anything_ind is 'Whether the presenter has ever done a live presentation, anywhere for anything.';
comment on column ks_full_session_load.presented_anything_where is 'Where the presenter has done live presentations (of any kind).';

alter table ks_sessions add presented_anything_ind varchar2(1);
alter table ks_sessions add presented_anything_where varchar2(4000);
alter table ks_sessions add constraint ks_sessions_pres_any_yn check (presented_anything_ind in ('Y','N'));
comment on column ks_sessions.presented_anything_ind is 'Whether the presenter has ever done a live presentation(s), anywhere for anything.';
comment on column ks_sessions.presented_anything_where is 'Where the presenter has done live presentation (of any kind)';

comment on column ks_sessions.presented_before_ind is 'Whether the session has been presented before';
comment on column ks_sessions.presented_before_where is 'Where the presentaton been done before';


-- #20
alter table ks_session_votes add decline_vote_flag varchar2(1);
comment on column ks_session_votes.decline_vote_flag is 'Used when a user abstains form voting on a session.';


-- #3
-- @../install/ks_event_admins.sql
PRO ..ks_event_admins 

-- drop table ks_event_admins cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_admins (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , event_id        number        not null
  , username        varchar2(60)  not null
  , created_by      varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_event_admins_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
  , constraint ks_event_user_admin_fk foreign key ( username ) references ks_users ( username ) not deferrable
)
enable primary key using index
/

create unique index ks_event_admins_u01 on ks_event_admins (event_id, username);
  

comment on table ks_event_admins is 'List of Event Admins';

comment on column ks_event_admins.id is 'Primary Key ID';
comment on column ks_event_admins.username is 'user with ADMIN role on the event';
comment on column ks_event_admins.created_by is 'User that created this record';
comment on column ks_event_admins.created_on is 'Date the record was first created';
comment on column ks_event_admins.updated_by is 'User that last modified this record';
comment on column ks_event_admins.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_admins_u_trg
before update
on ks_event_admins
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/
-- @../install/ks_email_templates.sql
PRO .. ks_email_templates 

-- drop table ks_email_templates cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_email_templates (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , name            varchar2(255) not null
  , template_text   varchar2(4000) not null
  , created_by      varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
)
enable primary key using index
/

comment on table ks_email_templates is 'List Email Templates';

comment on column ks_email_templates.id is 'Primary Key ID';
comment on column ks_email_templates.created_by is 'User that created this record';
comment on column ks_email_templates.created_on is 'Date the record was first created';
comment on column ks_email_templates.updated_by is 'User that last modified this record';
comment on column ks_email_templates.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_email_templates_u_trg
before update
on ks_email_templates
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/




-- *** Views ***

-- #3
-- @../views/ks_users_v.sql
PRO ks_users_v
create or replace view ks_users_v
as
select u.id
     , u.username
     , u.password
     , u.first_name
     , u.last_name
     , u.first_name || nvl2(u.last_name, ' ' || u.last_name, '') full_name
     , u.email
     , u.active_ind
     , u.admin_ind
     , u.external_sys_ref
     , u.expired_passwd_flag
     , u.login_attempts
     , u.last_login_date
     , u.created_by
     , u.created_on
     , u.updated_by
     , u.updated_on
  from ks_users u
/

-- @../views/ks_events_tracks_v.sql
create or replace view ks_events_tracks_v
as
  select e.id event_id
       , t.id event_track_id
       , e.name event_name
       , t.display_seq
       , t.name track_name
       , e.blind_vote_flag
       , nvl(t.alias, t.name) track_alias
       , nvl(t.blind_vote_begin_date , e.blind_vote_begin_date ) blind_vote_begin_date
       , nvl(t.committee_vote_begin_date, e.committee_vote_begin_date) committee_vote_begin_date
       , nvl(nvl(t.blind_vote_end_date   , e.blind_vote_end_date ), sysdate) blind_vote_end_date
       , nvl(nvl(t.committee_vote_end_date  , e.committee_vote_end_date), sysdate) committee_vote_end_date
       , case when sysdate between nvl(t.blind_vote_begin_date , e.blind_vote_begin_date)
                               and nvl(nvl(t.blind_vote_end_date, e.blind_vote_end_date), trunc(sysdate))+.99999 then 'Y' else 'N' end blind_voting_current_ind
       , case when sysdate between nvl(t.committee_vote_begin_date, e.committee_vote_begin_date)
                               and nvl(nvl(t.committee_vote_end_date, e.committee_vote_end_date), trunc(sysdate))+.99999 then 'Y' else 'N' end committee_voting_current_ind
       , case when sysdate between e.begin_date and nvl(e.end_date, e.begin_date) then 'Y' else 'N' end event_current_ind
       , e.begin_date begin_date
       , nvl(e.end_date, e.begin_date) end_date
       , e.active_ind event_active_ind
       , t.active_ind track_active_ind
       , t.blind_vote_help
       , t.committee_vote_help
       , (case
            when sysdate < nvl(t.blind_vote_begin_date,e.blind_vote_begin_date ) then
              'Opens ' || to_char(nvl(t.blind_vote_begin_date,e.blind_vote_begin_date ), 'fmDay, fmMonth fmDD, YYYY')
            when sysdate >= nvl(t.blind_vote_begin_date,e.blind_vote_begin_date )
                        and nvl(t.blind_vote_end_date,e.blind_vote_end_date ) is null then
              'Opened Indefinately'
            when sysdate >= nvl(t.blind_vote_begin_date,e.blind_vote_begin_date )
             and sysdate < nvl(t.blind_vote_end_date,e.blind_vote_end_date )+.99999 then
              'Closes ' || to_char(nvl(t.blind_vote_end_date,e.blind_vote_end_date), 'fmDay, fmMonth fmDD, YYYY')
            when sysdate >= nvl(t.blind_vote_end_date,e.blind_vote_end_date)
             and sysdate <= (nvl(t.blind_vote_end_date,e.blind_vote_end_date) + 7 + .99999) then
              'Closed ' || to_char(nvl(t.blind_vote_end_date,e.blind_vote_end_date), 'fmDay, fmMonth fmDD, YYYY')
            else ''
          end) blind_vote_date_desc
       , (case
            when sysdate < nvl(t.committee_vote_begin_date,e.committee_vote_begin_date ) then
              'Opens ' || to_char(nvl(t.committee_vote_begin_date,e.committee_vote_begin_date ), 'fmDay, fmMonth fmDD, YYYY')
            when sysdate >= nvl(t.committee_vote_begin_date,e.committee_vote_begin_date )
                        and nvl(t.committee_vote_end_date,e.committee_vote_end_date ) is null then
              'Open Indefinately'
            when sysdate >= nvl(t.committee_vote_begin_date,e.committee_vote_begin_date )
             and sysdate < nvl(t.committee_vote_end_date,e.committee_vote_end_date )+.99999 then
              'Closes ' || to_char(nvl(t.committee_vote_end_date,e.committee_vote_end_date), 'fmDay, fmMonth fmDD, YYYY')
            when sysdate >= nvl(t.committee_vote_end_date,e.committee_vote_end_date)
             and sysdate <= (nvl(t.committee_vote_end_date,e.committee_vote_end_date) + 7 + .99999) then
              'Closed ' || to_char(nvl(t.committee_vote_end_date,e.committee_vote_end_date), 'fmDay, fmMonth fmDD, YYYY')
            else ''
          end) committee_vote_date_desc
       , t.max_comps
       , t.max_sessions
  from ks_events e
     , ks_event_tracks t
 where 1=1
   and t.event_id = e.id
/
-- @../views/ks_events_sec_v.sql
PRO ks_events_sec_v
create or replace view ks_events_sec_v
as
with p as (select sys_context('APEX$SESSION','app_user') app_user from sys.dual)
select e.id
     , e.name
     , e.alias
     , e.location
     , e.event_type
     , e.begin_date
     , e.end_date
     , e.blind_vote_begin_date
     , e.blind_vote_end_date
     , e.committee_vote_begin_date
     , e.committee_vote_end_date
     , e.blind_vote_flag
     , e.active_ind
     , e.created_by
     , e.created_on
     , e.updated_by
     , e.updated_on
  from ks_events e
 where (
  -- Global Admin
  exists (select 1 
            from ks_users u, p 
           where u.admin_ind = 'Y' and u.active_ind = 'Y'
             and u.username = p.app_user
         )
    or e.id in (
     -- Event Admin
     select a.event_id
       from ks_event_admins a, p
      where a.username = p.app_user
   )
 )
/
-- @../views/ks_events_allowed_v.sql
PRO ks_events_allowed_v
create or replace view ks_events_allowed_v
as
with p as (select sys_context('APEX$SESSION','app_user') app_user from sys.dual)
select e.id
     , e.name
     , e.alias
     , e.location
     , e.event_type
     , e.begin_date
     , e.end_date
     , e.blind_vote_begin_date
     , e.blind_vote_end_date
     , e.committee_vote_begin_date
     , e.committee_vote_end_date
     , e.blind_vote_flag
     , e.active_ind
     , e.created_by
     , e.created_on
     , e.updated_by
     , e.updated_on
  from ks_events e
 where (
  -- Global Admin
  exists (select 1 
            from ks_users u, p 
           where u.admin_ind = 'Y' and u.active_ind = 'Y'
             and u.username = p.app_user
         )
    or e.id in (
     -- Event Admin
     select a.event_id
       from ks_event_admins a, p
      where a.username = p.app_user
     union
     -- Track Viewer
     select et.event_id
       from ks_events_tracks_v et
          , ks_user_event_track_roles tr
          , p
      where tr.event_track_id = et.event_track_id
        and tr.selection_role_code is not null -- (expecting: OWNER and VIEWER)
        and tr.username = p.app_user
   )
 )
/

-- #16
-- @../views/ks_session_load_coll_v.sql
PRO ks_session_load_coll_v
create or replace view ks_session_load_coll_v
as
select seq_id
     , n001 track_id
     , c001 track_name
     , n002 session_count
     , c002 notify_ind
  from apex_collections
 where collection_name = 'LOADED_SESSIONS'
/

-- #32 
-- @../views/ks_sessions_v.sql

PRO ks_sessions_v
create or replace view ks_sessions_v
as
with totals as (
  select d.session_id
       , sum(d.vote) votes_total
       , avg(d.vote) votes_average
   from ks_session_votes d
  group by d.session_id
)
select  s.id
      , s.event_id
      , s.event_track_id
      , s.session_num
      , s.sub_category
      , s.session_type
      , s.title
      , s.presenter
      , s.company
      , s.co_presenter
      , s.status_code
      , s.notes
      , s.tags      
      , t.votes_total
      , t.votes_average
      , s.presenter_email
      , s.session_summary
      , s.session_abstract
      , s.target_audience
      , s.presented_before_ind
      , s.presented_before_where
      , s.technology_product
      , s.ace_level
      , s.video_link
      , trim (
        case
        when instr (s.video_link, 'http') > 0 
        then
          substr (
             s.video_link
            ,instr (s.video_link, 'http')
            ,case 
              when instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1) < instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1)
                then instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1)
              when instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1) > instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1)
                then instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1) - 1
                else length (s.video_link)
            end
          )
        else null
        end
      ) as first_video_link
      , s.contains_demo_ind
      , s.webinar_willing_ind
      , s.external_sys_ref
      , s.presenter_user_id
      , s.co_presenter_user_id
      , s.presenter_biography
      , s.co_presenter_company
      , s.submission_date
      , s.room_size_code
      , s.presented_anything_ind
      , s.presented_anything_where
      , s.created_by
      , s.created_on
      , s.updated_by
      , s.updated_on
  from ks_sessions s
     , totals t
 where s.id = t.session_id (+)
/





-- *** Objects ***

-- Added ks_log calls
-- @../plsql/ks_tags_api.plb

PROMPT ks_tags_api body
create or replace package body ks_tags_api
is
        
--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

---
--- Tag Synchronisation Procedure
---
procedure tag_sync (
    p_new_tags          in varchar2,
    p_old_tags          in varchar2,
    p_content_type      in varchar2,
    p_content_id        in number )
as
    l_scope  ks_log.scope := gc_scope_prefix || 'tag_sync';
  -- l_params logger.tab_param;

    type tags is table of varchar2(255) index by varchar2(255);
    l_new_tags_a    tags;
    l_old_tags_a    tags;
    l_new_tags      apex_application_global.vc_arr2;
    l_old_tags      apex_application_global.vc_arr2;
    l_merge_tags    apex_application_global.vc_arr2;
    l_dummy_tag     varchar2(255);
    i               integer;

begin
  -- we call tag_sync form a trigger, so lets not call logger unless we need to.
  -- logger.append_param(l_params, 'p_option_name', p_option_name);
    ks_log.log('START', l_scope);

    l_old_tags := apex_util.string_to_table(p_old_tags,':');
    l_new_tags := apex_util.string_to_table(p_new_tags,':');
    if l_old_tags.count > 0 then --do inserts and deletes
        --build the associative arrays
        for i in 1..l_old_tags.count loop
            l_old_tags_a(l_old_tags(i)) := l_old_tags(i);
        end loop;
        for i in 1..l_new_tags.count loop
            l_new_tags_a(l_new_tags(i)) := l_new_tags(i);
        end loop;
        --do the inserts
        for i in 1..l_new_tags.count loop
            begin
                l_dummy_tag := l_old_tags_a(l_new_tags(i));
            exception when no_data_found then
                insert into ks_tags (tag, content_id, content_type )
                    values (l_new_tags(i), p_content_id, p_content_type );
                l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
            end;
        end loop;
        --do the deletes
        for i in 1..l_old_tags.count loop
            begin
                l_dummy_tag := l_new_tags_a(l_old_tags(i));
            exception when no_data_found then
                delete from ks_tags where content_id = p_content_id and tag = l_old_tags(i);
                l_merge_tags(l_merge_tags.count + 1) := l_old_tags(i);
            end;
        end loop;
    else --just do inserts
        for i in 1..l_new_tags.count loop
            insert into ks_tags (tag, content_id, content_type )
                values (l_new_tags(i), p_content_id, p_content_type );
            l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
        end loop;
    end if;
    for i in 1..l_merge_tags.count loop
        merge into ks_tag_type_sums s
        using (select count(*) tag_count
                 from ks_tags
                where tag = l_merge_tags(i) and content_type = p_content_type ) t
           on (s.tag = l_merge_tags(i) and s.content_type = p_content_type )
         when not matched then insert (tag, content_type, tag_count)
                               values (l_merge_tags(i), p_content_type, t.tag_count)
         when matched then update set s.tag_count = t.tag_count;
        merge into ks_tag_sums s
        using (select sum(tag_count) tag_count
                 from ks_tag_type_sums
                where tag = l_merge_tags(i) ) t
           on (s.tag = l_merge_tags(i) )
         when not matched then insert (tag, tag_count)
                               values (l_merge_tags(i), t.tag_count)
         when matched then update set s.tag_count = t.tag_count;
    end loop;

    ks_log.log('START', l_scope);

end tag_sync;

/*******************************************************************
 * Maintain the collection elements when using search filters
 *   p_coll: collection_name
 *    p_sub: Optional sub level/area for the tags.
 *     p_id: ID being managed
 * p_status: YES/NO is the element checked (YES) or un-checked (NO)
 *******************************************************************/
procedure maintain_filter_coll(
       p_coll   in varchar2
     , p_sub    in varchar2 := null
     , p_id     in varchar2
     , p_status in varchar2 := 'NO')
is
  l_scope  ks_log.scope := gc_scope_prefix || 'maintain_filter_coll';

  l_seq_id number;
begin

  ks_log.log('START', l_scope);

  /*
  The collections being used:
    SESSIONTAGFILTER: For Session (abstract) filters
  */

  if p_coll in ('SESSIONTAGFILTER') then
    -- is this the top level selection
    if p_id = 'top' then

      -- Because it's the top level, empty the collection
      if apex_collection.collection_exists(p_coll) then
        apex_collection.truncate_collection(p_coll);
      else
        apex_collection.create_collection(p_coll);
      end if;

      -- the collection is already empty, but if the status
      -- is YES then we need to populate ALL of the elmemnts
      if p_status = 'YES' then
        for i in (
          select tag id from ks_tag_type_sums where content_type='SESSION' || nvl2(p_sub, ':' || p_sub, '') and p_coll = 'SESSIONTAGFILTER'
          )
        loop
          apex_collection.add_member(p_coll, p_c001 => i.id);
        end loop;
      end if;

    else
      -- We're dealing with a single element

      -- Create the collection if it doesn't exist.
      if not apex_collection.collection_exists(p_coll) then
          apex_collection.create_collection(p_coll);
      end if;

      -- The element was checked so add it
      if p_status = 'YES' then
          apex_collection.add_member(p_coll, p_c001 => p_id);
      else

        -- the element was unchecked so remove it.
        begin
        select seq_id
          into l_seq_id
          from apex_collections
         where collection_name = p_coll
           and c001 = p_id;

          apex_collection.delete_member(p_coll, l_seq_id);
        exception
        when NO_DATA_FOUND then
          null;
        end;
      end if;

    end if;
  end if;

  ks_log.log('END', l_scope);

end maintain_filter_coll;


end ks_tags_api;
/

-- #4
-- @../plsql/ks_error_handler.plb
set define off
create or replace PACKAGE BODY ks_error_handler
AS
--============================================================================
-- B A S I C   E R R O R   D U M P
--============================================================================
FUNCTION basic_error_dump(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
  l_test varchar2(32767);
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
        l_result.message := 'Here''s the full error details:<p/>'||
                            '<PRE>'||
                            '<BR/><B>          MESSAGE:</B> '||p_error.message||
                            '<BR/><B>  Additional Info:</B> '||p_error.additional_info||
                            '<BR/><B> Display Location:</B> '||p_error.display_location||
                            '<BR/><B> Association_Type:</B> '||p_error.Association_type||
                            '<BR/><B>   Page Item Name:</B> '||p_error.page_item_name||
                            '<BR/><B>        Region ID:</B> '||p_error.region_id||
                            '<BR/><B>     Column Alias:</B> '||p_error.column_alias||
                            '<BR/><B>          Row Num:</B> '||p_error.row_num||
                            '<BR/><B>Is Internal Error:</B> '||case when p_error.is_internal_error = TRUE 
                                                        THEN 'True'
                                                        ELSE 'False'
                                                   end||
                            '<BR/><B>  APEX ERROR CODE:</B> '||p_error.apex_error_code||
                            '<BR/><B>      ora_sqlcode:</B> '||p_error.ora_sqlcode||
                            '<BR/><B>      ora_sqlerrm:</B> '||p_error.ora_sqlerrm||
                            '<BR/><B>  Error Backtrace:</B><BR/>'||p_error.error_backtrace||
                            '<BR/><B>   Component.type:</B> '||p_error.component.type||
                            '<BR/><B>     Component.id:</B> '||p_error.component.id||
                            '<BR/><B>   Component.name:</B> '||p_error.component.name||
                            '<BR/><B>  First Error Text:</B> '||apex_error.get_first_ora_error_text ( p_error => p_error )||
                            '<BR/><B>   Application ID:</B> '||v('APP_ID')||
                            '<BR/><B>          Page ID:</B> '||v('APP_PAGE_ID')||'<P/><pre/>' ;
             
-- Now return the result record to the caller.
  
  RETURN l_result;
END basic_error_dump;
--============================================================================
-- B A S I C   E R R O R   H A N D L E R
--============================================================================
FUNCTION basic_error_handler(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
  -- Look at the error that was encountered. Is it an "internal" error?
  IF p_error.is_internal_error then
     -- If it is, then it may contain information that could give away clues to the 
     -- database structure.
     -- 
     -- However the errors for Authorization Checks should be fine... So if it's 
     -- anything BUT an authroization Check, we need to re-write the error 
     IF p_error.apex_error_code <> 'APEX.AUTHORIZATION.ACCESS_DENIED' then
 
     
        -- We'll try to construct an error that has good information 
        -- but doesn't give away any info into the DB Structure
        --
        l_result.message := 'We''re Sorry. An unexpected error has occurred. '||
                            'Please note the following information and contact the help desk:<p/>'||
                            '<PRE/>'||
                            '<BR/> Application ID: '||v('APP_ID')||
                            '<BR/>        Page ID: '||v('APP_PAGE_ID')||
                            '<BR/>APEX ERROR CODE: '||p_error.apex_error_code||
                            '<BR/>    ora_sqlcode: '||p_error.ora_sqlcode||
                            '<BR/>    ora_sqlerrm: '||p_error.ora_sqlerrm||
                            '</PRE>' ;
     END IF;
  ELSE 
    -- It's NOT an internal error, so we need to handle it.
    --
    -- First lets reset the place where it's going to display
    -- If at all possible we want to get away from the ugly error page scenario.
    -- 
    l_result.display_location :=
      CASE 
         -- If the error is supposed to be displayed on an error page
         WHEN l_result.display_location = apex_error.c_on_error_page 
           -- Then let's put it back inline
           THEN apex_error.c_inline_in_notification
         -- Otherwise keep it as defined.
         ELSE l_result.display_location
      END;
 
      -- If it was an ORA error that was raised
      -- we'll present the error text of to the end user in a nicer format.
      -- 
      -- To do this we'll get the "First Error Text" using the APEX_ERROR API
        
      IF p_error.ora_sqlcode IS NOT NULL then
            l_result.message := apex_error.get_first_ora_error_text (
                                    p_error => p_error );
      END IF;
      
      -- We can also use the APEX_ERROR API to automatically find the 
      -- item the error was associated with, IF they're not already set.
      if l_result.page_item_name is null and l_result.column_alias is null then
            apex_error.auto_set_associated_item (
                p_error        => p_error,
                p_error_result => l_result );
        end if;
      
      
   END IF;      
                            
-- Now return the result record to the caller.
  
  RETURN l_result;
END basic_error_handler;
--============================================================================
-- B A S I C   E R R O R   H A N D L E R   W I T H   L O O K U P
--============================================================================
FUNCTION basic_error_lookup(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
  l_constraint_name varchar2(255);
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
  -- Look at the error that was encountered. Is it an "internal" error?
  IF p_error.is_internal_error then
     -- If it is, then it may contain information that could give away clues to the 
     -- database structure.
     -- 
     -- However the errors for Authorization Checks should be fine... So if it's 
     -- anything BUT an authroization check, we need to re-write the error 
     IF p_error.apex_error_code <> 'APEX.AUTHORIZATION.ACCESS_DENIED' then
     
        
        -- We'll try to construct an error that has good information 
        -- but doesn't give away any info into the DB Structure
        --
        l_result.message := 'We''re Sorry. An unexpected error has occurred. '||
                            'Please note the following information and contact the help desk:<p/>'||
                            '<PRE/>'||
                            '<BR/> Application ID: '||v('APP_ID')||
                            '<BR/>        Page ID: '||v('APP_PAGE_ID')||
                            '<BR/>APEX ERROR CODE: '||p_error.apex_error_code||
                            '<BR/>    ora_sqlcode: '||p_error.ora_sqlcode||
                            '<BR/>    ora_sqlerrm: '||p_error.ora_sqlerrm||
                            '</PRE>';
     END IF;
  ELSE 
    -- It's NOT an internal error, so we need to handle it.
    --
    -- First lets reset the place where it's going to display
    -- If at all possible we want to get away from the ugly error page scenario.
    -- 
    l_result.display_location :=
      CASE 
         -- If the error is supposed to be displayed on an error page
         WHEN l_result.display_location = apex_error.c_on_error_page 
           -- Then let's put it back inline
           THEN apex_error.c_inline_in_notification
         -- Otherwise keep it as defined.
         ELSE l_result.display_location
      END;
 
      -- If it is an ORA error that was raised lets do our best to figure it out
      -- and present the error text of to the end user in a nicer format.
      -- 
      -- To do this we'll get the "First Error Text" using the APEX_ERROR API
        
      IF p_error.ora_sqlcode IS NOT NULL then
      
            -- If it's a constraint violation then we'll try to get a matching "friendly" message from our 
            -- Lookup table. Below is a reference of common constraint violations you may want to handle.
            --
            --   -) ORA-00001: unique constraint violated
            --   -) ORA-02091: transaction rolled back (-> can hide a deferred constraint)
            --   -) ORA-02290: check constraint violated
            --   -) ORA-02291: integrity constraint violated - parent key not found
            --   -) ORA-02292: integrity constraint violated - child record found
            --
            IF p_error.ora_sqlcode in (-1, -2091, -2290, -2291, -2292) then
            -- Get the contraint name 
            l_constraint_name := apex_error.extract_constraint_name ( p_error => p_error );
            -- Use that constraint name to see if we have a translation for it in our table.
            begin
                select message
                  into l_result.message
                  from constraint_lookup
                 where constraint_name = l_constraint_name;
            exception 
                 when no_data_found 
                 then null; 
            end;
            ELSE
               -- Lets check some common error codes here... 
             l_result.message :=
              case 
                  when p_error.ora_sqlcode = -1407
                  then 'Trying to insert a null value into a not null column.'
                  --WHEN p_error.ora_sqlcode =  -12899
                  --THEN 'The value you entered was to large for the field. Please try again.'
               else
                  apex_error.get_first_ora_error_text (p_error => p_error )
               end;
            end if;
      
      ELSE
            --l_result.message := apex_error.get_first_ora_error_text (p_error => p_error );
            null;
      END IF;
      
      -- We can also use the APEX_ERROR API to automatically find the 
      -- item the error was associated with, IF they're not already set.
      if l_result.page_item_name is null and l_result.column_alias is null then
            apex_error.auto_set_associated_item (
                p_error        => p_error,
                p_error_result => l_result );
        end if;
      
      
   END IF;   
                            
-- Now return the result record to the caller.
  
  RETURN l_result;
END basic_error_lookup;
--============================================================================
-- E R R O R   H A N D L E R  -  L O G G I N G
--============================================================================
FUNCTION error_handler_logging(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
  l_constraint_name varchar2(255);
  l_logger_message varchar2(4000);
  l_logger_scope   varchar2(1000);

  -- If an error has this code it means we don't want to see the ORA-code but the
  -- APEX Process error the developer specified.
  c_process_error number := -20999; 
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
  -- Look at the error that was encountered. Is it an "internal" error?
  IF p_error.is_internal_error then
     -- If it is, then it may contain information that could give away clues to the 
     -- database structure.
     -- 
     -- However the errors for Authorization Checks should be fine... So if it's 
     -- anything BUT an authroization check, we need to re-write the error 
     IF p_error.apex_error_code = 'APEX.SESSION.EXPIRED' then -- added for APEX5
        -- Keep the error, but add more to it. And capture with logger below (for now).
        -- Redirect to Home Page after 1.5 second.
        l_result.message := p_error.message
            || '<script>setTimeout(function(){window.top.location="f?p=' || v('APP_ID') || '";},1500);</script>';
        -- leave the additional_info alone.
        -- l_result.additional_info := '';
     ELSIF p_error.apex_error_code <> 'APEX.AUTHORIZATION.ACCESS_DENIED' then
     
        
        -- We'll try to construct an error that has good information 
        -- but doesn't give away any info into the DB Structure
        --
        l_result.message := 'We''re Sorry. An unexpected error has occurred. '||
                            'Please note the following information and contact the help desk:<p/>'||
                            '<PRE/>'||
                            '<BR/> Application ID: '||v('APP_ID')||
                            '<BR/>        Page ID: '||v('APP_PAGE_ID')||
                            '<BR/>APEX ERROR CODE: '||p_error.apex_error_code||
                            '<BR/>    ora_sqlcode: '||p_error.ora_sqlcode||
                            '<BR/>    ora_sqlerrm: '||p_error.ora_sqlerrm||
                            '</PRE>';
     END IF;
  ELSE 
    -- It's NOT an internal error, so we need to handle it.
    --
    -- First lets reset the place where it's going to display
    -- If at all possible we want to get away from the ugly error page scenario.
    -- 
    l_result.display_location :=
      CASE 
         -- If the error is supposed to be displayed on an error page
         WHEN l_result.display_location = apex_error.c_on_error_page 
           -- Then let's put it back inline
           THEN apex_error.c_inline_in_notification
         -- Otherwise keep it as defined.
         ELSE l_result.display_location
      END;
 

      -- If it is an ORA error that was raised lets do our best to figure it out
      -- and present the error text of to the end user in a nicer format.
      -- 
      -- To do this we'll get the "First Error Text" using the APEX_ERROR API
      IF p_error.ora_sqlcode IS NOT NULL and p_error.ora_sqlcode <> c_process_error then
      
            -- If it's a constraint violation then we'll try to get a matching "friendly" message from our 
            -- Lookup table. Below is a reference of common constraint violations you may want to handle.
            --
            --   -) ORA-00001: unique constraint violated
            --   -) ORA-02091: transaction rolled back (-> can hide a deferred constraint)
            --   -) ORA-02290: check constraint violated
            --   -) ORA-02291: integrity constraint violated - parent key not found
            --   -) ORA-02292: integrity constraint violated - child record found
            --
            IF p_error.ora_sqlcode in (-1, -2091, -2290, -2291, -2292) then
              -- Get the contraint name 
              l_constraint_name := apex_error.extract_constraint_name ( p_error => p_error );
              -- Use that constraint name to see if we have a translation for it in our table.
              begin
                  select message
                    into l_result.message
                    from constraint_lookup
                   where constraint_name = l_constraint_name;
              exception 
                   when no_data_found 
                   then null; 
              end;
            ELSE
               -- Lets check some common error codes here... 
             l_result.message :=
              CASE 
                  WHEN p_error.ora_sqlcode = -1407
                  THEN 'Trying to insert a null value into a not null column.'
                  --WHEN p_error.ora_sqlcode =  -12899
                  --THEN 'The value you entered was too large for the field. Please try again.'                    
               ELSE 
                  apex_error.get_first_ora_error_text (
                                    p_error => p_error )
               end;
            end if;
      
      ELSE
            --l_result.message := apex_error.get_first_ora_error_text (p_error => p_error );
            null;
      END IF;
      
      -- We can also use the APEX_ERROR API to automatically find the 
      -- item the error was associated with, IF they're not already set.
      if l_result.page_item_name is null and l_result.column_alias is null and l_constraint_name is null then
            apex_error.auto_set_associated_item (
                p_error        => p_error,
                p_error_result => l_result );
      end if;
      
      
   END IF;   
   
-- LAST thing we do before returning is log the error     
--
-- LOG THE UNKNOWN ERROR IN THE LOGGER TABLES
--
-- First build the log message
l_logger_message  := 'Here''s the full error details:<p/>'||
            '<PRE>'||
            '<BR/><B>          MESSAGE:</B> '||p_error.message||
            '<BR/><B>  Additional Info:</B> '||p_error.additional_info||
            '<BR/><B> Display Location:</B> '||p_error.display_location||
            '<BR/><B> Association_Type:</B> '||p_error.Association_type||
            '<BR/><B>   Page Item Name:</B> '||p_error.page_item_name||
            '<BR/><B>        Region ID:</B> '||p_error.region_id||
            '<BR/><B>     Column Alias:</B> '||p_error.column_alias||
            '<BR/><B>          Row Num:</B> '||p_error.row_num||
            '<BR/><B>Is Internal Error:</B> '||case when p_error.is_internal_error = TRUE 
                                        THEN 'True'
                                        ELSE 'False'
                                   end||
            '<BR/><B>  APEX ERROR CODE:</B> '||p_error.apex_error_code||
            '<BR/><B>      ora_sqlcode:</B> '||p_error.ora_sqlcode||
            '<BR/><B>      ora_sqlerrm:</B> '||p_error.ora_sqlerrm||
            '<BR/><B>  Error Backtrace:</B><BR/>'||p_error.error_backtrace||
            '<BR/><B>   Component.type:</B> '||p_error.component.type||
            '<BR/><B>     Component.id:</B> '||p_error.component.id||
            '<BR/><B>   Component.name:</B> '||p_error.component.name||
            '<BR/><B> First Error Text:</B> '||apex_error.get_first_ora_error_text ( p_error => p_error )||
            '<BR/><B>   Application ID:</B> '||v('APP_ID')||
            '<BR/><B>          Page ID:</B> '||v('APP_PAGE_ID')||'<P/><pre/>' ;
-- Generate a SCOPE string for logger so we can get a handle back on it
-- Format   YYYY-MM-DD HH24.MI.SS:USER:APP:PAGE:SESSION
--
l_logger_scope := to_char(sysdate,'YYYY-MM-DD HH24.MI.SS')||':'||v('APP_USER')||':'||v('APP_ID')||':'||v('APP_PAGE_ID')||':'||v('APP_SESSION');
-- Now create the log entry as an error so it captures the error stack.
-- but remove the HTML
l_logger_message := replace(l_logger_message, '<BR/>', chr(10));
-- logger.log_error(p_text => l_logger_message, p_scope => l_logger_scope);
                            
-- Now return the result record to the caller.
 
  RETURN l_result;
END error_handler_logging;
--============================================================================
-- E R R O R   H A N D L E R  -  L O G G I N G  &  S E S S I O N   S T A T E
--============================================================================
FUNCTION error_handler_logging_session(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
  l_constraint_name varchar2(255);
  l_logger_message varchar2(4000);
  l_logger_scope   varchar2(1000);
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
  -- Look at the error that was encountered. Is it an "internal" error?
  IF p_error.is_internal_error then
     -- If it is, then it may contain information that could give away clues to the 
     -- database structure.
     -- 
     -- However the errors for Authorization Checks should be fine... So if it's 
     -- anything BUT an authroization check, we need to re-write the error 
     -- Oh and if the session expired, don't report it as an error.
     IF p_error.apex_error_code = 'APEX.SESSION.EXPIRED' then -- added for APEX5
        -- Keep the error, but add more to it. And capture with logger below (for now).
        -- Redirect to Home Page after 1.5 second.
        l_result.message := p_error.message
            || '<script>setTimeout(function(){location.href="f?p=' || v('APP_ID') || '";},1500);</script>';
        -- leave the additional_info alone.
        -- l_result.additional_info := '';
     ELSIF p_error.apex_error_code <> 'APEX.AUTHORIZATION.ACCESS_DENIED' then
     
        
        -- We'll try to construct an error that has good information 
        -- but doesn't give away any info into the DB Structure
        --
        l_result.message := 'We''re Sorry. An unexpected error has occurred. '||
                            'Please note the following information and contact the help desk:<p/>'||
                            '<PRE/>'||
                            '<BR/> Application ID: '||v('APP_ID')||
                            '<BR/>        Page ID: '||v('APP_PAGE_ID')||
                            '<BR/>APEX ERROR CODE: '||p_error.apex_error_code||
                            '<BR/>    ora_sqlcode: '||p_error.ora_sqlcode||
                            '<BR/>    ora_sqlerrm: '||p_error.ora_sqlerrm||
                            '</PRE>';
     END IF;
  ELSE 
    -- It's NOT an internal error, so we need to handle it.
    --
    -- First lets reset the place where it's going to display
    -- If at all possible we want to get away from the ugly error page scenario.
    -- 
    l_result.display_location :=
      CASE 
         -- If the error is supposed to be displayed on an error page
         WHEN l_result.display_location = apex_error.c_on_error_page 
           -- Then let's put it back inline
           THEN apex_error.c_inline_in_notification
         -- Otherwise keep it as defined.
         ELSE l_result.display_location
      END;
 
      -- If it is an ORA error that was raised lets do our best to figure it out
      -- and present the error text of to the end user in a nicer format.
      -- 
      -- To do this we'll get the "First Error Text" using the APEX_ERROR API
        
      IF p_error.ora_sqlcode IS NOT NULL then
      
            -- If it's a constraint violation then we'll try to get a matching "friendly" message from our 
            -- Lookup table. Below is a reference of common constraint violations you may want to handle.
            --
            --   -) ORA-00001: unique constraint violated
            --   -) ORA-02091: transaction rolled back (-> can hide a deferred constraint)
            --   -) ORA-02290: check constraint violated
            --   -) ORA-02291: integrity constraint violated - parent key not found
            --   -) ORA-02292: integrity constraint violated - child record found
            --
            IF p_error.ora_sqlcode in (-1, -2091, -2290, -2291, -2292) then
              -- Get the contraint name 
              l_constraint_name := apex_error.extract_constraint_name ( p_error => p_error );
              -- Use that constraint name to see if we have a translation for it in our table.
              begin
                  select message
                    into l_result.message
                    from constraint_lookup
                   where constraint_name = l_constraint_name;
              exception 
                   when no_data_found 
                   then null;
              end;
            ELSE
               -- Lets check some common error codes here... 
             l_result.message :=
              case 
                  when p_error.ora_sqlcode = -1407 THEN
                   'Trying to insert a null value into a not null column.'
                  --WHEN p_error.ora_sqlcode =  -12899
                  --THEN 'The value you entered was to large for the field. Please try again.'
               else 
                  apex_error.get_first_ora_error_text (
                                    p_error => p_error )
               end;
            end if;
      
      ELSE
            --l_result.message := apex_error.get_first_ora_error_text (p_error => p_error );
            null;
      END IF;
      
      -- We can also use the APEX_ERROR API to automatically find the 
      -- item the error was associated with, IF they're not already set.
      if l_result.page_item_name is null and l_result.column_alias is null then
            apex_error.auto_set_associated_item (
                p_error        => p_error,
                p_error_result => l_result );
        end if;
      
      
   END IF;   
   
  -- LAST thing we do before returning is log the error     
  --
  -- LOG THE UNKNOWN ERROR IN THE LOGGER TABLES
  --
  -- First build the log message
  l_logger_message  := 'Here''s the full error details:<p/>'||
              '<PRE>'||
              '<BR/><B>          MESSAGE:</B> '||p_error.message||
              '<BR/><B>  Additional Info:</B> '||p_error.additional_info||
              '<BR/><B> Display Location:</B> '||p_error.display_location||
              '<BR/><B> Association_Type:</B> '||p_error.Association_type||
              '<BR/><B>   Page Item Name:</B> '||p_error.page_item_name||
              '<BR/><B>        Region ID:</B> '||p_error.region_id||
              '<BR/><B>     Column Alias:</B> '||p_error.column_alias||
              '<BR/><B>          Row Num:</B> '||p_error.row_num||
              '<BR/><B>Is Internal Error:</B> '||case when p_error.is_internal_error = TRUE 
                                          THEN 'True'
                                          ELSE 'False'
                                     end||
              '<BR/><B>  APEX ERROR CODE:</B> '||p_error.apex_error_code||
              '<BR/><B>      ora_sqlcode:</B> '||p_error.ora_sqlcode||
              '<BR/><B>      ora_sqlerrm:</B> '||p_error.ora_sqlerrm||
              '<BR/><B>  Error Backtrace:</B><BR/>'||p_error.error_backtrace||
              '<BR/><B>   Component.type:</B> '||p_error.component.type||
              '<BR/><B>     Component.id:</B> '||p_error.component.id||
              '<BR/><B>   Component.name:</B> '||p_error.component.name||
              '<BR/><B> First Error Text:</B> '||apex_error.get_first_ora_error_text ( p_error => p_error )||
              '<BR/><B>   Application ID:</B> '||v('APP_ID')||
              '<BR/><B>          Page ID:</B> '||v('APP_PAGE_ID')||'<P/><pre/>' ;
  -- Generate a SCOPE string for logger so we can get a handle back on it
  -- Format   YYYY-MM-DD HH24.MI.SS:USER:APP:PAGE:SESSION
  --
  l_logger_scope := to_char(sysdate,'YYYY-MM-DD HH24.MI.SS')||':'||v('APP_USER')||':'||v('APP_ID')||':'||v('APP_PAGE_ID')||':'||v('APP_SESSION');
  -- Now create the log entry as an error so it captures the error stack.
  -- but remove the HTML
  l_logger_message := replace(l_logger_message, '<BR/>', chr(10));
  l_logger_message := replace(replace(l_logger_message, '<B>', '*'), '</B>', '*');
  -- logger.log_apex_items(p_text => l_logger_message, p_scope => l_logger_scope);
                              
  -- Now return the result record to the caller.
 
  RETURN l_result;
END error_handler_logging_session;


--============================================================================
-- F O R C E   P L / S Q L   E R R O R   
--============================================================================
PROCEDURE force_plsql_error
AS
    l_NUMBER number;
BEGIN
  l_number := 1/0;
END force_plsql_error;


end ks_error_handler;
/

-- #1, #22, #20, #32
-- @../plsql/ks_session_api.pls
create or replace package ks_session_api
is

--------------------------------------------------------------------------------
--*
--* 
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter in ks_sessions.presenter%TYPE);
  
procedure switch_votes (
	p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username 	  in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
);


function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N',
                                  p_escape_html in varchar2 default 'Y')
  return varchar2;


procedure session_id_navigation (
   p_id in ks_sessions.id%type
  ,p_region_static_id in varchar2
  ,p_page_id in number
  ,p_previous_id out ks_sessions.event_track_id%type
  ,p_next_id out ks_sessions.event_track_id%type
  ,p_total_rows out number
  ,p_current_row out number
);


function is_session_owner (
  p_session_id in ks_sessions.id%type
 ,p_username   in varchar2
)
return varchar2;


function parse_video_link (
  p_video_link in ks_sessions.video_link%type
)
return varchar2;

end ks_session_api;
/
-- @../plsql/ks_session_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
create or replace package body ks_session_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 * @constant gc_html_whitelist_tags a list of strings to NOT escape from. Same as the apex version but includes span and em
 * @constant gc_token_exceptions is a "|" separated list that gets passed into ks_util. It contains the tokens which we want to ommit from escaping.
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

gc_html_whitelist_tags constant varchar2(500) := '<h1>,</h1>,<h2>,</h2>,<h3>,</h3>,<h4>,</h4>,<p>,<span>,</span>,</p>,<b>,</b>,<strong>,</strong>,<i>,</i>,<ul>,</ul>,<ol>,</ol>,<li>,</li>,<br />,<hr/>,<em>,</em>';
gc_token_exceptions constant varchar2(4000) := 'oracle|apex|epm|and|its|it|of';
gc_parameter_tokens_name constant ks_parameters.name_key%type := 'ANONYMIZE_EXTRA_TOKENS';


------------------------------------------------------------------------------
/**
 *  Output of the form:
 *    apex_json.open_object;
 *    apex_json.write('presenter', p_presenter);
 *    apex_json.write('trackList', '<ul><li>Track 1</li></ul>');
 *    apex_json.close_object;
 *
 * @example
 *
 * @issue
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param p_event_id
 * @param p_presenter
 * @return
 */
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter in ks_sessions.presenter%TYPE)
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'presenter_tracks_json';
  -- l_params logger.tab_param;

  list_cur sys_refcursor;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter', p_presenter);
  -- logger.log('BEGIN', l_scope, null, l_params);

  open list_cur for
    select p_presenter "presenter"
         , '<ul><li>' ||listagg(n || ' in ' || p || ' (' || status || ')', '</li><li>') within group (order by display_seq) || '</li></ul>' "trackList"
    from (
      select t.display_seq, nvl(t.alias, t.name) p, count(*) n
           , listagg(nvl(st.name, '?'), ',') within group (order by st.display_seq) status
        from ks_event_tracks t
           , ks_sessions s
           , ks_session_status st
       where t.id = s.event_track_id
         and s.event_id = to_number(p_event_id)
         and s.presenter = p_presenter
         and s.status_code = st.code (+)
       group by t.display_seq, nvl(t.alias, t.name)
    );

  apex_json.write(list_cur);

  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    apex_json.open_array;
    apex_json.open_object;
    apex_json.write('presenter', p_presenter);
    apex_json.write('trackList', 'Unable to fetch list:<br>' || sqlerrm || '<br>');
    apex_json.close_object;
    apex_json.close_array;
end presenter_tracks_json;






/**
 * Switch votes and voting role of an user for a selected event / track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 26, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_username username of the user.
 * @param p_voting_role selected voting role for the user.
 */
procedure switch_votes (
  p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username    in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
)
is

begin

  -- Move all votes to new vote_type
  update ks_session_votes
     set vote_type = p_voting_role
   where id in (
      select sv.id
        from ks_session_votes sv
           , ks_sessions s
       where sv.username = p_username
         and s.event_id = p_event_id
         and s.event_track_id = p_track_id
         and sv.session_id = s.id);

  update ks_user_event_track_roles
     set voting_role_code = p_voting_role
   where username = p_username
     and event_track_id = p_track_id;

end switch_votes;







--==============================================================================
-- Function: html_whitelist_clob
-- Purpose: returns a varchar2 where every chunk of 4000 characters has been html_whitelisted and tokenized
--
-- Inputs:  p_string - the clob or varchar2 to be escaped/tokenized
--          p_session_id - the session id. We use this to get the name of the presenter/company/co-presenter
--          p_anonymize - whether to hide the info
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N',
                                  p_escape_html in varchar2 default 'Y')
  return varchar2
is
  l_scope ks_log.scope := gc_scope_prefix || 'html_whitelist_tokenize';

  l_output varchar2(32767);

  l_presenter    ks_sessions.presenter%type;
  l_co_presenter ks_sessions.co_presenter%type;
  l_company      ks_sessions.company%type;
begin
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END

  --The id is usually null when the user's session got reset
  --We don't want to create an ugly error on top of the page already showing errors
  --So silently exit.
  if p_session_id is null then
    return '';
  end if;

  if p_escape_html = 'Y' then
    l_output := apex_escape.html_whitelist(p_string, gc_html_whitelist_tags);
  else
    l_output := p_string;
  end if;
  l_output := regexp_replace(l_output, '_x000D_', '', 1, 0, 'i');

  if p_anonymize = 'Y' then
    select s.presenter, s.company, s.co_presenter
      into l_presenter, l_company, l_co_presenter
      from ks_sessions s
     where s.id = p_session_id;

     l_output := ks_util.replace_tokens(l_output 
                                      , l_presenter || ' ' || l_company || ' ' || l_co_presenter ||' ' || ks_util.get_param(gc_parameter_tokens_name)
                                      , gc_token_exceptions);


  end if;



  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  html_whitelist_tokenize;



/**
 * Get the following data to allow navigation of the sessions:
 *    - Previous Session ID
 *    - Next Session ID
 *    - Current Row
 *    - Total Row
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 1, 2018
 * @param p_id
 * @param p_region_static_id
 * @param p_page_id
 * @return
 * @param p_previous_id
 * @param p_next_id
 * @param p_total_rows
 * @param p_current_row
 */
procedure session_id_navigation (
   p_id in ks_sessions.id%type
  ,p_region_static_id in varchar2
  ,p_page_id in number
  ,p_previous_id out ks_sessions.event_track_id%type
  ,p_next_id out ks_sessions.event_track_id%type
  ,p_total_rows out number
  ,p_current_row out number
)
is
  l_report apex_ir.t_report;
  l_sql clob;
  l_next_id number;
  l_previous_id number;
  l_order_by varchar2 (32000);
  l_cur number;
  l_res number;
  l_total_rows number;
  l_row_num number;
  l_alias varchar2(1);
  l_scope ks_log.scope := gc_scope_prefix || 'session_id_navigation';

begin
  ks_log.log('START', l_scope);

  l_report := ks_util.get_ir_report (
      p_page_id => p_page_id
    , p_static_id => p_region_static_id
  );
          
  l_sql := l_report.sql_query;  
  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('l_sql:' || l_sql, l_scope);
  $END

  $IF wwv_flow_api.c_current >= 20180404 $THEN
    -- in 18.1 the alias changed from r to i
    l_alias := 'i';
  $ELSE
    l_alias := 'r';
  $END

  --l_report.sql_query selects the columns indicated on the option "menu Action > Select Columns" from the SQL Query indicated on the App Builder's IR Configuration.
  --The following line replaces the list of selected columns on l_report.sql_query by all the columns.
  --Ex: SESSION_NUM is not displayed on the IR, so it is not selected on l_report.sql_query.
  --Selecting all the columns with r.*, allows to order by any column indicated on the option "menu Action > Data > Sort" even if it is not included on "menu Action > Select Columns".
  --Also, the total number of rows is calculated at this level.
  l_sql := 'select count (id) over () as total_rows'
       || ',' || l_alias || '.*'
       || substr (l_sql, instr (l_sql, ' from '));

  l_order_by := ks_util.get_ir_order_by (p_ir_query => l_sql);
  $IF wwv_flow_api.c_current >= 20180404 $THEN
  -- in APEX 18.1 the order by construct changed and got an extra wrap ")i"
  if instr(l_order_by, ')i') > 0 then
    l_order_by := substr(l_order_by, 1, instr(l_order_by, ')i') -1);
  end if;
  $END

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('order by:' || l_order_by, l_scope);
  $END

  if l_order_by is null then
    l_order_by := 'order by session_num';
  end if;

  l_sql := 'select next
      ,previous
      ,total_rows
      ,row_num
    from (' ||
        '   select    id
                    , lead (id) over ( ' || l_order_by || ') next ' ||
        '           , lag (id) over ( ' || l_order_by || ') previous ' ||
        '           , total_rows ' ||
        '           , row_number () over ( ' || l_order_by || ') as row_num ' ||
        '   from (' || l_sql || 
        ' ))  where id=:ID';

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('New l_sql:' || l_sql, l_scope);
  $END

  l_cur := dbms_sql.open_cursor;

  dbms_sql.parse (l_cur, l_sql, dbms_sql.native);

  for i in 1..l_report.binds.count
  loop
    dbms_sql.bind_variable (l_cur, l_report.binds(i).name, l_report.binds(i).value);
    $IF $$VERBOSE_OUTPUT $THEN
      ks_log.log (l_report.binds(i).name || ':' || l_report.binds(i).value, l_scope);
    $END
  end loop;

  dbms_sql.bind_variable (l_cur, 'ID', p_id);
  dbms_sql.define_column (l_cur, 1, p_next_id);
  dbms_sql.define_column (l_cur, 2, p_previous_id);
  dbms_sql.define_column (l_cur, 3, p_total_rows);
  dbms_sql.define_column (l_cur, 4, p_current_row);

  l_res := dbms_sql.execute(l_cur);

  if dbms_sql.fetch_rows (l_cur) > 0 then
    dbms_sql.column_value (l_cur, 1, p_next_id);
    dbms_sql.column_value (l_cur, 2, p_previous_id);
    dbms_sql.column_value (l_cur, 3, p_total_rows);
    dbms_sql.column_value (l_cur, 4, p_current_row);
  end if;

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('p_next_id:' || p_next_id, l_scope);
    ks_log.log('p_previous_id:' || p_previous_id, l_scope);
    ks_log.log('p_total_rows:' || p_total_rows, l_scope);
    ks_log.log('p_current_row:' || p_current_row, l_scope);
  $END

  dbms_sql.close_cursor (l_cur);
  ks_log.log('END', l_scope);
exception
  when others then
    if dbms_sql.is_open (l_cur) then
      dbms_sql.close_cursor (l_cur);
    end if;

    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  session_id_navigation;




/**
 * For a given track session and user, indicate if the given user is the presenter 
 * or copresenter of the session.
 * The comparison is done against the ks_users.external_sys_ref which identifies users
 * in the external system.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 5, 2018
 * @param p_id
 * @return 'Y','N'
 */
function is_session_owner (
  p_session_id in ks_sessions.id%type
 ,p_username   in varchar2
)
return varchar2
is 
  l_scope ks_log.scope := gc_scope_prefix || 'is_session_owner';
  
  l_return varchar2(1) := 'N';

  l_external_sys_ref ks_users.external_sys_ref%type;
  l_presenter_user_id ks_sessions.presenter_user_id%type;
  l_co_presenter_user_id ks_sessions.co_presenter_user_id%type;
begin
  ks_log.log('START', l_scope);

  select s.presenter_user_id
       , s.co_presenter_user_id
    into l_presenter_user_id
       , l_co_presenter_user_id
    from ks_sessions s
   where s.id = p_session_id;

  select u.external_sys_ref
    into l_external_sys_ref
    from ks_users u
   where u.username = p_username;

  if l_external_sys_ref in (l_presenter_user_id, l_co_presenter_user_id) then
    l_return := 'Y';
  end if;

  ks_log.log('END', l_scope);
  return l_return;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end is_session_owner;



/**
 * Parse the "video link" text returning one line per link and formatting the link as an html anchor tag when applied.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 15, 2018
 * @param p_video_link
 * @return parsed text containing the link as a html anchor tag.
 */
function parse_video_link (
  p_video_link in ks_sessions.video_link%type
)
return varchar2
is 
  l_scope ks_log.scope := gc_scope_prefix || 'parse_video_link';
  
  c_link_format constant varchar2(1000) := '<a id="VIDEO_URL" href="#LINK#" target="_blank" alt="Video" title="Video">#LINK#</a>';
  
  l_links apex_t_varchar2;
  l_key varchar2(1000);
  l_link varchar2(32000);
  l_return varchar2(32000);
  l_is_not_first_line boolean := FALSE;
begin
  ks_log.log ('START', l_scope);

  l_links := apex_string.split(p_video_link, '<br />');
  l_key := l_links.first;
  
  while (l_key is not null)
  loop
    l_link := l_links (l_key);

    if substr (trim (l_link), 1, 4) = 'http' then 
      l_link := replace (c_link_format, '#LINK#', l_link);
    end if;

    if l_is_not_first_line then 
      l_return := l_return || '<br>' || l_link;
    else 
      l_return := l_link;
      l_is_not_first_line := TRUE;
    end if;

    l_key := l_links.next (l_key);
  end loop;

  ks_log.log ('END', l_scope);
  return l_return;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end parse_video_link;


end ks_session_api;
/

-- #16
-- @../plsql/ks_session_load_api.pls
create or replace package ks_session_load_api
is

--------------------------------------------------------------------------------
--*
--*
--*
--------------------------------------------------------------------------------

-- CONSTANTS

--------------------------------------------------------------------------------


procedure load_xlsx_data (
    p_xlsx      in blob
  , p_username  in varchar2 default v('APP_USER')
);

function validate_data(
    p_into_event_id in ks_event_tracks.event_id%TYPE
) return boolean;

procedure load_sessions (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
  , x_load_count in out number
);

procedure purge_event(
    p_event_id			in ks_sessions.event_id%TYPE
  , p_track_id			in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind	in varchar2
  , p_force_ind			in varchar2
);

procedure create_loaded_session_coll (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
);

procedure toggle_track_notification(p_seq_id in number);


end ks_session_load_api;
/
-- @../plsql/ks_session_load_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
create or replace package body ks_session_load_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix: Standard logger package name
 * @constant gc_all_clob_columns: comma separeted list of columns that are clobs
 * @constant c_loaded_session_coll: Name of the collection created during the load session wizard
 * @column_names_t: is the table type for columns taken from the export file.
 * @c_max_errors_to_display: the maximum number of errors to display to the user.
 * @index_map_t: maps column numbers from the export file to column names in ks_full_session_load
*/
gc_scope_prefix      constant varchar2(31) := lower($$PLSQL_UNIT) || '.';
gc_all_clob_columns  constant varchar2(4000) := 'SESSION_DESCRIPTION';
c_session_load_table constant varchar2(30) := 'KS_FULL_SESSION_LOAD';
c_loaded_session_coll constant varchar2 (30) := 'LOADED_SESSIONS';

c_max_errors_to_display constant number := 6;

type column_names_t is varray(4000) of varchar2(4000);

type index_map_t is table of varchar2(30) index by varchar2(10);



--==============================================================================
-- Function: add_error_check_continue
-- Purpose: Wrapper function for apex_error. It logs the error and if we've reached the threshold c_max_errors_to_display we return false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function add_error_check_continue (p_message in varchar2,
                                   p_display_location in varchar2)
  return boolean
is
  l_scope ks_log.scope := 'add_error_check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);

  apex_error.add_error(
            p_message => p_message
          , p_display_location => p_display_location
        );

  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end add_error_check_continue;




--==============================================================================
-- Function: check_continue
-- Purpose: Checks if we've reached the threshold c_max_errors_to_display. If so, then it returns false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function check_continue
  return boolean
is
  l_scope ks_log.scope := 'check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);


  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end check_continue;




--==============================================================================
-- Function: validate_uniqueness
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_uniqueness
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_uniqueness';

  l_count number;
  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select session_num
      from ks_full_session_load
     where app_user = l_username
     group by session_num
    having count(*) > 1
  )
  loop
    if not add_error_check_continue(p_message => 'The session_number "' || row.session_num || '", is not unique. Correct to continue.'
                             ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;

  --Do the same thing for external_sys_ref
  for row in (
    select external_sys_ref
      from ks_full_session_load
     where app_user = l_username
     group by external_sys_ref
     having count(*) > 1
  )
  loop
    if not add_error_check_continue(
        p_message => 'The session id (external system reference) "' || row.external_sys_ref || '", is not unique. Correct to continue.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;

  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_uniqueness;



--==============================================================================
-- Function: validate_not_null
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_not_null
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_not_null';

  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select title
      from ks_full_session_load
     where app_user = l_username
       and ( session_num is null
          or external_sys_ref is null
        )
  )
  loop
    if not add_error_check_continue(
        p_message => 'Session "' || substr(row.title,1,20) || '" is missing a session_num or external_sys_ref.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  for row in (
    select session_num || ':' || title name
      from ks_full_session_load
     where app_user = l_username
       and event_track_id is null
  )
  loop
    if not add_error_check_continue(
        p_message => 'Session "' || substr(row.name,1,20) || '" is missing a track.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_not_null;



--==============================================================================
-- Function: validate_new_session
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_new_session(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_new_session';

  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select sl.session_num
      from ks_full_session_load sl
         , ks_sessions s
     where sl.app_user = l_username
       and s.session_num = sl.session_num
       and s.event_id = p_into_event_id
  )
  loop
    if not add_error_check_continue(
        p_message => 'A session with session number "' || row.session_num || '" already exists for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  for row in (
    select sl.external_sys_ref
      from ks_full_session_load sl
         , ks_sessions s
     where sl.app_user = l_username
       and s.external_sys_ref = sl.external_sys_ref
       and s.event_id = p_into_event_id
  )
  loop
    if not add_error_check_continue(
        p_message => 'A session with session id (external_sys_ref) "' || row.external_sys_ref || '" already exists for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_new_session;




--==============================================================================
-- Function: validate_correct_tracks
-- Purpose:
--
-- Inputs: p_into_event_id - the id of the event
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_correct_tracks(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_correct_tracks';

  l_username varchar2(60);

begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  --First check the track
  -- Sorry, ks_full_session_load.event_track_id is not an ID at all but a name!
  for row in (
    select distinct sl.event_track_id
      from ks_full_session_load sl
     where sl.app_user = l_username
       and sl.event_track_id not in (
        select name
          from ks_event_tracks
         where event_id = p_into_event_id
     )
  )
  loop
    if not add_error_check_continue(
        p_message => 'The track "'|| row.event_track_id ||'" does not exist for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      ks_log.log('Missing track, Abort!', l_scope);
      return false;
    end if;
  end loop;

  ks_log.log('END', l_scope);
  
  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_correct_tracks;





--==============================================================================
-- Function: validate_data
-- Purpose: Runs validations checks on the data. This occurs after ks_full_session_load is loaded and it's columns are validated,
--             but before we have submitted it's data to the corresponding tables.
--
-- Inputs: p_into_event_id, the id the of the event
-- Output: whether the data is avalid or not
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function validate_data(p_into_event_id ks_event_tracks.event_id%TYPE)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_data';

begin
  ks_log.log('START', l_scope);

  if not validate_uniqueness
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_not_null
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_new_session(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_correct_tracks(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_data;





--==============================================================================
-- Function: validate_column_names
-- Purpose: This makes sure that the first row of the .xlsx file contains row names FOR EACH column in ks_session_load (minus event_id, track_id, and app_user)
--
-- Inputs: p_column_names - varray of column names
-- Output: returns true if valid, false if invalid
-- Scope: Not  Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/09/2017
--==============================================================================
function validate_column_names (p_column_names in column_names_t)
return boolean
is
  l_scope ks_log.scope := 'validate_column_names';
  --l_params logger.tab_param;
  type column_names_dict_t is table of varchar2(20) index by varchar2(4000);
  l_column_names_dict column_names_dict_t;

  i number := 0;
  idx varchar2(4000);
begin
  --logger.append_param(l_params, 'p_column_names', p_column_names);
  ks_log.log('START', l_scope);


  for row in (select trim(upper(lm.header_name)) header
                from ks_load_mapping lm
                where 1=1
                  and table_name = c_session_load_table)
  loop
    l_column_names_dict(row.header) := 'not_matched';
  end loop;

  for i in 1..p_column_names.count
  loop
      if not l_column_names_dict.exists(trim(upper(p_column_names(i))))
      then
        if not add_error_check_continue(p_message => 'The column "' || p_column_names(i) || '" does not match any column names specified in the instructions.'
                                     ,  p_display_location => apex_error.c_inline_in_notification
                            )
        then
          return false;
        end if;
      else
        l_column_names_dict(trim(upper(p_column_names(i)))) := 'matched';
      end if;
  end loop;

  ks_log.log('before l_column_names_dict loop', l_scope);

  idx := l_column_names_dict.first;
  while idx is not null
  loop
    if l_column_names_dict(idx) = 'not_matched'
    then
      ks_log.log('Not matched l_column_names_dict(' || idx || '):', l_scope);
      if not add_error_check_continue(p_message => 'The column "' || initcap(idx) || '", was not found in the file. Please ensure this column exists in the file.'
                       ,  p_display_location => apex_error.c_inline_in_notification
                            )
       then
        return false;
       end if;
    end if;
    idx := l_column_names_dict.next(idx);
  end loop;

  ks_log.log('after l_column_names_dict loop. Errors:' || apex_error.get_error_count, l_scope);

  if apex_error.get_error_count > 0 then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_names;




--==============================================================================
-- Function: validate_column_order
-- Purpose: validates that the columns provided in the export file are in the correct order
--
-- Inputs:  p_column_names - an array of colum names
-- Output: returns true if valid, false if invalid
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes: THIS FUNCTION IS NOT USED - the function works, but turned out to not be useful.
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
function validate_column_order (p_column_names in column_names_t)
  return boolean
is
  l_scope ks_log.scope := 'validate_column_order';
  --l_params logger.tab_param;
  l_idx number := 1;
  l_columns_in_their_order varchar2(4000);
begin
  --logger.append_param(l_params, 'p_column_names', p_column_names);
  ks_log.log('START', l_scope);

  for row in (select trim(upper(lm.header_name)) header_name,
                     display_seq
              from ks_load_mapping lm
             where 1=1
            and table_name = c_session_load_table
            and lm.to_column_name is not null
            order by lm.display_seq
            )
  loop
    if p_column_names(row.display_seq) != row.header_name
    then
      select listagg(lm.header_name, ', ') within group (order by lm.display_seq) value
        into l_columns_in_their_order
        from ks_load_mapping lm
        where 1=1
          and table_name = c_session_load_table;


        apex_error.add_error(
                  p_message => 'The columns in the export file are in an incorrect order. The proper order is: ' ||
                                  l_columns_in_their_order || '. At least this column is out of order: ' || p_column_names(l_idx)
                , p_display_location => apex_error.c_inline_in_notification
              );
      --This is a big error (lots of text), so exit here regardless of number of errors.
      return false;
    end if;

  end loop;

  return true;
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_order;



--==============================================================================
-- Procedure: init_index_map
-- Purpose: After the column names have been validated from the file,
--            we need to map which columns headers in the export go to which columns in ks_full_session_load
-- ASUMPTION(S): Column names are valid, and there aren't any missing
-- Inputs:  l_column_names - column names from the import file
--          l_cells - the final table we will create our view from.
-- Output:
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
procedure init_index_map ( p_index_map in out nocopy index_map_t)
is
  l_scope ks_log.scope := gc_scope_prefix || 'init_index_map';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);

  for row in (
    select m.to_column_name
         , m.display_seq
      from ks_load_mapping m
     where m.table_name = c_session_load_table
       and m.to_column_name is not null
     order by m.display_seq
  )
  loop
    p_index_map(to_char(row.display_seq)) := row.to_column_name;
    ks_log.log('mapped: ' || row.display_seq || ' to '  || row.to_column_name, l_scope);
  end loop;

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end init_index_map;


/**
 * Load data from xlsx into appropriate collection for parsing. All data is
 * loaded to into the session APP_USER
 *
 * @example
 * 
 * @issue
 *
 * @author Ben Shumway (Insum Solutions)
 * @created Oct/09/2017
 * @param p_xlsx blob with all data
 */
procedure load_xlsx_data (
    p_xlsx      in blob
  , p_username  in varchar2 default v('APP_USER')
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'load_xlsx_data';

  l_column_names column_names_t;

  l_cells as_read_xlsx_clob.tp_all_cells;
  l_curr_row number;

  l_rows_row number;

  type session_load_row_t is table of ks_full_session_load%rowtype;
  l_rows session_load_row_t;

  l_curr_col varchar2(30);

  --column index for spreadsheet_content
  l_col_ind number;

  l_index_map index_map_t;
  l_index varchar2(4000);

  --used to get the first 4000 bytes of any string data
  l_substr varchar2(4000);
  --used to get the length of the string data
  l_substr_len number;

  l_string_val clob;
  l_number_val number;
  l_date_val date;

  l_reached_final_line boolean := false;

  --An array of tags
  l_tags apex_application_global.vc_arr2;
    

begin
   --logger.append_param(l_params, 'p_username', p_username);
   --logger.append_param(l_params, 'p_into_event_id', p_into_event_id);
   --logger.append_param(l_params, 'p_into_track_id', p_into_track_id);
   ks_log.log('BEGIN', l_scope);

   l_column_names := column_names_t();
   l_rows := session_load_row_t();

   select *
    bulk collect into l_cells
    from
    table(AS_READ_XLSX_CLOB.read(p_xlsx => p_xlsx))
    order by row_nr, col_nr;

   for i in 1 ..  l_cells.count
   loop
      l_curr_row := to_number(l_cells(i).row_nr);
      $IF $$VERBOSE_OUTPUT $THEN
      ks_log.log('BEGIN cell: ' ||  l_cells(i).row_nr || ',' || l_cells(i).col_nr, l_scope);
      $END

      --NOTE: Assumption, the bulk collect gets all cells in order by row then column
      if l_curr_row = 2 and l_cells(i).col_nr = '1'
      then
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('Length of l_column_names: ' || l_column_names.count, l_scope);
        $END
        if not ks_session_load_api.validate_column_names(l_column_names) then
          return;
        end if;

        --modify l_cells so that the column names are correct
        init_index_map(l_index_map);

        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('l_index_map size: ' || l_index_map.count, l_scope);
        $END
        l_index := l_index_map.first;
        while l_index is not null
        loop
          $IF $$VERBOSE_OUTPUT $THEN
          ks_log.log('l_index_map(' || l_index ||'): ' || l_index_map(l_index), l_scope);
          $END
          
          l_index := l_index_map.next(l_index);
        end loop;

      elsif l_curr_row = '1'
      then
        l_column_names.extend;
        --Get the column name (allows the .xlsx header to be defined "fuzzilly"
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('Adding name: ' || l_cells(i).string_val, l_scope);
        $END
        l_column_names(i) := trim(upper(cast(l_cells(i).string_val as varchar2)));
     end if;

     $IF $$VERBOSE_OUTPUT $THEN
     ks_log.log('i: ' || i, l_scope);
     $END

     if l_curr_row > 1 then
        if l_rows.count < l_curr_row -1
        then
          if l_reached_final_line
          then
            l_rows.delete(l_rows.count);
            exit;
          else
            l_reached_final_line := true; --Considered true until proven otherwise
          end if;
          l_rows.extend;
        end if;

        -- l_string_val := coalesce(l_cells(i).string_val, to_char(l_cells(i).number_val), to_char(l_cells(i).date_val));

        l_string_val := trim(l_cells(i).string_val);
        l_number_val := l_cells(i).number_val;
        l_date_val := l_cells(i).date_val;

        l_rows_row := l_curr_row -1;

        if   l_string_val is not null
          or l_number_val is not null
          or l_date_val is not null
        then
          l_reached_final_line := false;
        end if;
        
        if l_number_val is not null
        then
          l_string_val := to_char(l_number_val);
        end if;


        --The commented out code shows when the as_read_xlsx_clob package skips cells
        /*ks_log.log('Checking existence of: ' || to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end) || ', l_cells(i).col_nr: ' || l_cells(i).col_nr 
                                                                       || ', string_val: ' || l_cells(i).string_val );
        l_index := to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end);*/
        l_index := l_cells(i).col_nr;                                                  
        if l_index_map.exists(l_index)
        then
          l_curr_col := l_index_map(l_index);
          $IF $$VERBOSE_OUTPUT $THEN
          ks_log.log('l_curr_col: ' || l_curr_col, l_scope);
          $END
          
          if l_curr_col = 'EXTERNAL_SYS_REF'
          then            
            l_rows(l_rows_row).external_sys_ref := l_string_val;
          elsif l_curr_col = 'SESSION_NUM'
          then
            l_rows(l_rows_row).session_num :=  l_string_val;
          elsif l_curr_col = 'EVENT_TRACK_ID'
          then
            l_rows(l_rows_row).event_track_id := l_string_val;
          elsif l_curr_col = 'SUB_CATEGORY'
          then
            l_rows(l_rows_row).sub_category := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_TYPE'
          then
            l_rows(l_rows_row).session_type := substr(l_string_val,1,500);
          elsif l_curr_col = 'TITLE'
          then
            l_rows(l_rows_row).title := substr(l_string_val,1,500);
          elsif l_curr_col = 'ACE_LEVEL'
          then
            l_rows(l_rows_row).ace_level := substr(l_string_val,1,30);
          elsif l_curr_col = 'COMPANY'
          then
            l_rows(l_rows_row).company := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_ABSTRACT'
          then
            l_rows(l_rows_row).session_abstract := l_string_val;
          elsif l_curr_col = 'SESSION_SUMMARY'
          then
            l_rows(l_rows_row).session_summary := substr(l_string_val,1,4000);
          elsif l_curr_col = 'TARGET_AUDIENCE'
          then
            l_rows(l_rows_row).target_audience := substr(l_string_val,1,60);
          elsif l_curr_col = 'TECHNOLOGY_PRODUCT'
          then
            l_rows(l_rows_row).technology_product := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTED_BEFORE_IND'
          then
            l_rows(l_rows_row).presented_before_ind := l_string_val;
          elsif l_curr_col = 'PRESENTED_BEFORE_WHERE'
          then
            l_rows(l_rows_row).presented_before_where := substr(l_string_val,1,4000);
          elsif l_curr_col = 'PRESENTED_ANYTHING_IND'
          then
            l_rows(l_rows_row).presented_anything_ind := l_string_val;
          elsif l_curr_col = 'PRESENTED_ANYTHING_WHERE'
          then
            l_rows(l_rows_row).presented_anything_where := substr(l_string_val,1,4000);            
          elsif l_curr_col = 'VIDEO_LINK'
          then
            l_rows(l_rows_row).video_link := substr(l_string_val,1,4000);
          elsif l_curr_col = 'CO_PRESENTER'
          then
            l_rows(l_rows_row).co_presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_COMPANY'
          then
            l_rows(l_rows_row).co_presenter_company := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTER_BIOGRAPHY'
          then
            l_rows(l_rows_row).presenter_biography := l_string_val;
          elsif l_curr_col = 'PRESENTER'
          then
            l_rows(l_rows_row).presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'TAGS'
          then
            l_tags := apex_util.string_to_table(l_string_val,',');
            for i in 1..l_tags.count
            loop
              l_tags(i) := trim(l_tags(i));
            end loop;
            l_rows(l_rows_row).tags := substr(apex_util.table_to_string(l_tags,':'),1,1000);
          elsif l_curr_col = 'CONTAINS_DEMO_IND'
          then
            l_rows(l_rows_row).contains_demo_ind := l_string_val;
          elsif l_curr_col = 'WEBINAR_WILLING_IND'
          then
            l_rows(l_rows_row).webinar_willing_ind := l_string_val;
          elsif l_curr_col = 'PRESENTER_EMAIL'
          then
            l_rows(l_rows_row).presenter_email := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).co_presenter_user_id := case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).presenter_user_id :=  case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'SUBMISSION_DATE'
          then
            -- l_rows(l_rows_row).submission_date := to_date(l_string_val, 'DD/MM/RR HH24:MI');
            l_rows(l_rows_row).submission_date := l_date_val;
          end if;

        end if;
      end if;
    end loop;


    ks_log.log('Removing previous load data (if present)', l_scope);
    delete 
      from ks_full_session_load s
     where app_user = p_username;


    ks_log.log('Inserting into ks_full_session_load', l_scope);
    forall i in l_rows.first .. l_rows.last
      insert into ks_full_session_load (
          app_user
        , external_sys_ref
        , session_num
        , event_track_id
        , sub_category
        , session_type
        , title
        , ace_level
        , presented_before_ind
        , presented_before_where
        , presented_anything_ind
        , presented_anything_where
        , video_link
        , co_presenter
        , co_presenter_company
        , presenter_biography
        , company
        , presenter
        , session_abstract
        , session_summary
        , tags
        , target_audience
        , technology_product
        , contains_demo_ind
        , webinar_willing_ind
        , presenter_email
        , co_presenter_user_id
        , presenter_user_id
        , submission_date
      )
      values (
          p_username
        , l_rows(i).external_sys_ref
        , l_rows(i).session_num
        , l_rows(i).event_track_id
        , l_rows(i).sub_category
        , l_rows(i).session_type
        , l_rows(i).title
        , l_rows(i).ace_level
        , l_rows(i).presented_before_ind
        , l_rows(i).presented_before_where
        , l_rows(i).presented_anything_ind
        , l_rows(i).presented_anything_where
        , l_rows(i).video_link
        , l_rows(i).co_presenter
        , l_rows(i).co_presenter_company
        , l_rows(i).presenter_biography
        , l_rows(i).company
        , l_rows(i).presenter
        , l_rows(i).session_abstract
        , l_rows(i).session_summary
        , l_rows(i).tags
        , l_rows(i).target_audience
        , l_rows(i).technology_product
        , l_rows(i).contains_demo_ind
        , l_rows(i).webinar_willing_ind
        , l_rows(i).presenter_email
        , l_rows(i).co_presenter_user_id
        , l_rows(i).presenter_user_id
        , l_rows(i).submission_date
      );

  ks_log.log('END', l_scope);
  
  exception when others
  then
    ks_log.log('ERROR', l_scope);
    raise;

end load_xlsx_data;



/**
 *
 *
 * @example
 *  ks_session_load_api.load_sessions(
 *      p_event_id   => :P5040_EVENT_ID
 *    , x_load_count => :P5041_ROW_COUNT
 *  );
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created January 6, 2018
 * @param p_event_id
 * @param p_username (optional)
 * @param x_load_count - final load count
 * @return
 */
procedure load_sessions (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
  , x_load_count in out number
)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'load_sessions';
begin
  ks_log.log('BEGIN', l_scope);

  insert into ks_sessions(
      event_id
    , event_track_id
    , external_sys_ref
    , session_num
    , sub_category
    , session_type
    , title
    , presenter
    , company
    , co_presenter
    , co_presenter_company
    , tags
    , presenter_email
    , session_abstract
    , session_summary
    , target_audience
    , presented_before_ind
    , presented_before_where
    , presented_anything_ind
    , presented_anything_where
    , technology_product
    , ace_level
    , video_link        
    , contains_demo_ind
    , webinar_willing_ind
    , presenter_biography
    , co_presenter_user_id
    , presenter_user_id
    , submission_date
   )            
  select p_event_id
       , e.id
       , s.external_sys_ref
       , s.session_num
       , s.sub_category
       , s.session_type
       , s.title
       , s.presenter
       , s.company
       , s.co_presenter
       , s.co_presenter_company
       , s.tags
       , s.presenter_email
       , s.session_abstract
       , s.session_summary
       , s.target_audience
       , decode(trim(lower(s.presented_before_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presented_before_where
       , decode(trim(lower(s.presented_anything_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presented_anything_where
       , s.technology_product        
       , s.ace_level
       , s.video_link        
       , decode(trim(lower(s.contains_demo_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , decode(trim(lower(s.webinar_willing_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presenter_biography
       , co_presenter_user_id
       , presenter_user_id
       , coalesce(submission_date, sysdate)
    from ks_full_session_load s
         left outer join ks_event_tracks e on s.event_track_id = e.name and e.event_id = p_event_id
   where s.app_user = p_username;
      
  x_load_count := SQL%ROWCOUNT;

  ks_log.log('END', l_scope);

  exception
    when OTHERS then
      ks_log.log_error('Unhandled Exception', l_scope);
      raise;
end load_sessions;






/**
 * Process to purge votes, sessions and tags from and event and/or track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 25, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_votes_only_ind to specify that only votes should be deleted.
 * @param p_force_ind to force the execution of the process even when votes
 *                    are present.
 */
procedure purge_event(
  p_event_id          in ks_sessions.event_id%TYPE
  , p_track_id        in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind  in varchar2
  , p_force_ind       in varchar2
)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'purge_event';

  no_action exception;

  l_votes_count number := 0;

begin
  ks_log.log('BEGIN', l_scope);

  -- This count is for pretection.
  -- We don't want to delete when there are votes present.
  select count(1)
    into l_votes_count
    from ks_session_votes v
       , ks_sessions s
   where v.session_id = s.id
     and s.event_id = p_event_id
     and (p_track_id is null or s.event_track_id = p_track_id)
     and p_votes_only_ind = 'N';


  if l_votes_count > 0 then
    -- if this parameter equals No 'N' then the process raises an error indicating no action will be done.
    raise no_action;
  end if;


  -- Delete the votes when the user selects "Votes Only" or "Force Purge"
  delete 
    from ks_session_votes v
   where v.session_id in (
      select ss.id
        from ks_sessions ss
       where ss.event_id = p_event_id
         and (p_track_id is null or ss.event_track_id = p_track_id)
   )
     and (p_votes_only_ind = 'Y' or p_force_ind = 'Y');


  -- Only delete sessions when the there are no votes and user selected Votes Only
  -- OR 
  -- Delete when user selected "Force Purge"
  delete
    from ks_sessions
   where event_id = p_event_id
     and (p_track_id is null or event_track_id = p_track_id)
     and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
         or p_force_ind = 'Y'
       );


  -- Remove unused tags after the "delete ks_sessions"
  --   When the there are no votes and user selected Votes Only
  --   OR 
  --   Delete when user selected "Force Purge"
  delete
    from ks_tag_type_sums ts
   where exists (
    select 1
     from ks_tag_type_sums s
        , ks_event_tracks t
    where s.content_type = 'SESSION' || ':' || t.id
      and s.tag_count = 0
      and s.rowid = ts.rowid
      and t.event_id = p_event_id
      and (p_track_id is null or t.id = p_track_id)
   )
    and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
        or p_force_ind = 'Y'
      );

  ks_log.log('END', l_scope);

  exception
    when no_action then
      raise_application_error (-20000,'Votes are present. Purge action aborted.');
    
end purge_event;




/**
 * Create collection session loaded having
 *    - The name of the track 
 *    - The number of loaded sessions by track
 *    - The checked flag (set Y by default)
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/07/2019
 * @param 
 */
procedure create_loaded_session_coll (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'create_loaded_session_coll';
  l_sql varchar2 (32000);
  l_param_names apex_application_global.vc_arr2;
  l_param_values apex_application_global.vc_arr2;
begin
  ks_log.log('START', l_scope);
  
  l_sql := q'[select e.id track_id
          ,count(*) session_count
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,s.event_track_id track_name
          ,'Y' notify_ind
  from    ks_full_session_load s
  left    outer join ks_event_tracks e 
  on      s.event_track_id = e.name 
  and     e.event_id = :p_event_id
  where   s.app_user = :p_username
  group   by s.event_track_id
         ,e.id]';

  if apex_collection.collection_exists (p_collection_name => c_loaded_session_coll) then 
    apex_collection.delete_collection (p_collection_name  => c_loaded_session_coll);
  end if;

  l_param_names(l_param_names.count + 1) := 'p_event_id';
  l_param_values(l_param_values.count + 1) := p_event_id;
  
  l_param_names(l_param_names.count + 1) := 'p_username';
  l_param_values(l_param_values.count + 1) := p_username;

  apex_collection.create_collection_from_queryb2 (
    p_collection_name => c_loaded_session_coll
   ,p_query           => l_sql
   ,p_names           => l_param_names
   ,p_values          => l_param_values
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end create_loaded_session_coll;



/**
 * Toggle the notification status of a loaded track
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_seq_id position in the collection
 * @param p_notification_ind Y|N
 */
procedure toggle_track_notification(p_seq_id in number)
is
  l_scope ks_log.scope := gc_scope_prefix || 'toggle_track_notification';

  l_notification_ind varchar2(1);

begin
  ks_log.log('START', l_scope);
  ks_log.log('p_seq_id:' || p_seq_id, l_scope);
  
  -- Get the new value
  select decode(notify_ind, 'Y', 'N', 'Y')
    into l_notification_ind
    from ks_session_load_coll_v
   where seq_id = p_seq_id;

  ks_log.log('l_notification_ind:' || l_notification_ind, l_scope);

  apex_collection.update_member_attribute  (
      p_collection_name => c_loaded_session_coll
    , p_seq => p_seq_id
    , p_attr_number => 2
    , p_attr_value  => l_notification_ind
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception:' || sqlerrm, l_scope);
    raise;
end toggle_track_notification;



end ks_session_load_api;
/

-- #6, #13
-- @../plsql/ks_email_api.pls
create or replace package ks_email_api
is

procedure send (
     p_to in varchar2
    ,p_cc in varchar2 default null
    ,p_bcc in varchar2 default null
    ,p_from in varchar2 default null
    ,p_replyto in varchar2 default null
    ,p_subj in varchar2
    ,p_body in clob
    ,p_body_html in clob
);

end ks_email_api;
/
-- @../plsql/ks_email_api.plb
create or replace package body ks_email_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';
gc_email_override_key constant ks_parameters.name_key%type := 'EMAIL_OVERRIDE';

------------------------------------------------------------------------------
/**
 *      Send an email to the original email accounts or 
 *      to the ones specified on email_override on the table ks_parameters.
 *      The parameter "EMAIL_PREFIX" is added to the subject.
 *      If p_to, p_cc and p_bcc are null, the procedure exists.
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param
 *  p_to
 *  p_from
 *  p_replyto
 *  p_subj
 *  p_body
 *  p_body_html 
 */
procedure send (
     p_to in varchar2
    ,p_cc in varchar2 default null
    ,p_bcc in varchar2 default null
    ,p_from in varchar2 default null
    ,p_replyto in varchar2 default null
    ,p_subj in varchar2
    ,p_body in clob
    ,p_body_html in clob
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'send';
  
  c_original_emails_notification constant varchar2(100) := 'This email was originally sent as follows ';

  l_email_override ks_parameters.value%type;
  l_to varchar2(4000);
  l_cc varchar2(4000);
  l_bcc varchar2(4000);
  l_body clob;
  l_body_html clob;
  l_subject_prefix ks_parameters.value%type;
  l_subject varchar2(4000);
begin
  ks_log.log('BEGIN', l_scope);

  if trim (p_to) is null 
      and trim (p_cc) is null
      and trim (p_bcc) is null then 
    return;
  end if;

  l_email_override := ks_util.get_param (p_name_key => gc_email_override_key);
  l_subject_prefix := ks_util.get_param ('EMAIL_PREFIX');
  l_subject := l_subject_prefix || p_subj;

  if l_email_override is not null then 
    l_to := l_email_override;
    l_cc := null;
    l_bcc := null;
    l_body :=  c_original_emails_notification || chr(10) || chr(13) 
      || 'TO: ' || nvl (p_to, '-') || chr(10) || chr(13) 
      || 'CC: ' || nvl (p_cc, '-') || chr(10) || chr(13) 
      || 'BCC: ' || nvl (p_bcc, '-') || chr(10) || chr(13) 
      || p_body;
    l_body_html := '<p>' || c_original_emails_notification || '<br>'
      || 'TO: ' || nvl (p_to, '-') || '<br>'
      || 'CC: ' || nvl (p_cc, '-') || '<br>'
      || 'BCC: ' || nvl (p_bcc, '-') || '</p>'
      || '<hr>'
      || p_body_html;
  else 
    l_to := p_to;
    l_cc := p_cc;
    l_bcc := p_bcc;
    l_body := p_body;
    l_body_html := p_body_html;
  end if;

  ks_log.log ('l_to: ' || l_to, l_scope);
  ks_log.log ('p_from: ' || p_from, l_scope);
  ks_log.log ('l_body: ' || l_body, l_scope);
  ks_log.log ('l_body_html: ' || l_body_html, l_scope);
  ks_log.log ('l_subject: ' || l_subject, l_scope);
  ks_log.log ('l_cc: ' || l_cc, l_scope);
  ks_log.log ('l_bcc: ' || l_bcc, l_scope);
  ks_log.log ('p_replyto: ' || p_replyto, l_scope);

  apex_mail.send (
     p_to => l_to
    ,p_from => p_from
    ,p_body => l_body
    ,p_body_html => l_body_html
    ,p_subj => l_subject
    ,p_cc => l_cc
    ,p_bcc => l_bcc
    ,p_replyto => p_replyto
  );

  ks_log.log('END', l_scope);
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end send;

end ks_email_api;
/
-- @../plsql/ks_notification_api.pls
create or replace package ks_notification_api
is

-- TYPES
type t_WordList is table of varchar2(32000) index by varchar(30);


-- CONSTANTS
g_blank_sub_strings t_WordList; -- Leave blank
------------------------------------------------------------------------------
procedure fetch_user_substitions (
  p_id in ks_users.id%type
 ,p_substrings in out nocopy t_WordList
);

procedure send_email (
   p_to in varchar2 default null
  ,p_from in varchar2
  ,p_cc in varchar2 default null
  ,p_bcc in varchar2 default null
  ,p_subject in varchar2
  ,p_body in clob
  ,p_body_html in clob default null
  ,p_template_name in varchar2 default null
  ,p_substrings in t_WordList default g_blank_sub_strings
);

procedure notify_track_session_load (    
    p_notify_owner in varchar2
  , p_notify_voter in varchar2
);

procedure notify_reset_pwd_request (
    p_id in ks_users.id%type
   ,p_password in ks_users.password%type
   ,p_app_id in ks_parameters.value%type
);

procedure notify_reset_pwd_done (
    p_id in ks_users.id%type
);

end ks_notification_api;
/
-- @../plsql/ks_notification_api.plb
set define off
create or replace package body ks_notification_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';
-- gc_template_load_notif constant ks_parameters.name_key%type := 'LOAD_NOTIFICATION_TEMPLATE';


------------------------------------------------------------------------------
/**
 * Get ready all the parameters to notify by email.
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param
 */
function replace_substr_template (
   p_template_name in varchar2
  ,p_substrings in t_WordList default g_blank_sub_strings
)
return clob
is
  l_scope ks_log.scope := gc_scope_prefix || 'replace_substr_template';

  l_msg clob;
  l_key varchar(30);
  l_substring varchar2(32000);
begin
  ks_log.log('BEGIN', l_scope);

  select  t.template_text 
  into    l_msg 
  from    ks_email_templates t
  where   t.name = p_template_name;

  l_key := p_substrings.first;

  while (l_key is not null)
  loop
    l_msg := replace (l_msg, '#' || upper (l_key) || '#', p_substrings(l_key) );
    l_key := p_substrings.next(l_key);
  end loop;

  ks_log.log('l_msg:' || l_msg, l_scope);
  ks_log.log('END', l_scope);
  return l_msg;
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end replace_substr_template;




/**
 * Populate all the substrings available for a given user so they can be used in
 * a template
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall
 * @created November 10, 2018
 * @param p_id `ks_users.id`
 * @param p_substrings `t_WordList`
 */
procedure fetch_user_substitions (
  p_id in ks_users.id%type
 ,p_substrings in out nocopy t_WordList
)
is 
  l_scope ks_log.scope := gc_scope_prefix || 'fetch_user_substitions';
begin
  ks_log.log('BEGIN', l_scope);

  select  u.id
         ,u.username
         ,u.first_name
         ,u.last_name
         ,u.full_name
         ,u.email
         ,u.active_ind
         ,u.admin_ind
         ,u.external_sys_ref
         ,u.expired_passwd_flag
         ,u.login_attempts
         ,u.last_login_date
  into    p_substrings ('USER_ID')
         ,p_substrings ('USERNAME')
         ,p_substrings ('USER_FIRST_NAME')
         ,p_substrings ('USER_LAST_NAME')
         ,p_substrings ('USER_FULL_NAME')
         ,p_substrings ('USER_EMAIL')
         ,p_substrings ('USER_ACTIVE_IND')
         ,p_substrings ('USER_ADMIN_IND')
         ,p_substrings ('USER_EXTERNAL_SYS_REF')
         ,p_substrings ('USER_EXPIRED_PASSWD_FLAG')
         ,p_substrings ('USER_LOGIN_ATTEMPTS')
         ,p_substrings ('USER_LAST_LOGIN_DATE')
  from    ks_users_v u
  where   u.id = p_id;

  ks_log.log('END', l_scope);
  
end fetch_user_substitions;




/**
 * Fetch common substitution strings that can be used on a template.
 *   * VOTING_APP_LINK
 *   * ADMIN_APP_LINK
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created November 19, 2018
 * @param x_result_status
 * @return
 */
procedure fetch_common_links(p_substrings in out nocopy t_WordList)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_common_links';
begin
  ks_log.log('BEGIN', l_scope);

  p_substrings('VOTING_APP_LINK') := ks_util.get_param('SERVER_URL') || ks_util.get_param('VOTING_APP_ID');
  p_substrings('ADMIN_APP_LINK') := ks_util.get_param('SERVER_URL') || ks_util.get_param('ADMIN_APP_ID');

  ks_log.log('END', l_scope);
end fetch_common_links;





/**
 * Get ready all the parameters to notify by email.
 * If the procedure receives a template name (in `p_template_name`) then the `p_body`
 * and `p_body_html` parameters are ignored and only the template is used.
 * If present, the `p_substrings` "word list" values will be used to merge with the template.
 * Leave `p_template_name` empty to use the `p_body` and `p_body_html` parameters.
 * If all three destination `p_to`, `p_cc` and `p_bcc` are null, the procedure 
 * exits without error.
 *
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param p_template_name optional template name as seen on `ks_email_templates`
 */
procedure send_email (
   p_to in varchar2 default null
  ,p_from in varchar2
  ,p_cc in varchar2 default null
  ,p_bcc in varchar2 default null
  ,p_subject in varchar2
  ,p_body in clob
  ,p_body_html in clob default null
  ,p_template_name in varchar2 default null
  ,p_substrings in t_WordList default g_blank_sub_strings
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'send_email';

  l_body clob;
  l_body_html clob;
begin
  ks_log.log('BEGIN', l_scope);

  if trim (p_to) is null 
      and trim (p_cc) is null
      and trim (p_bcc) is null then 
    return;
  end if;

  if p_template_name is not null then 
    l_body := replace_substr_template (
      p_template_name => p_template_name
     ,p_substrings => p_substrings
    );

    l_body_html := replace (l_body, chr(10), '<br>');
  else 
    l_body := p_body;
    l_body_html := p_body_html;
  end if;

  ks_email_api.send (
     p_to => p_to
    ,p_cc => p_cc
    ,p_bcc => p_bcc
    ,p_from => p_from
    ,p_replyto => null
    ,p_subj => p_subject
    ,p_body => l_body
    ,p_body_html => l_body_html
  );

  ks_log.log('END', l_scope);
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end send_email;




/**
 * 
 * Notify users of newly loaded sessions. The loaded sessions are found in `ks_session_load_coll_v`
 * Only the users for the tracks marked during the Load Session Wizard (`ks_session_load_coll_v.notify_ind`) will be notified.
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_notify_owner Notify "Track Owners", ie Track Leads (OWNER) and Track Observers (VIEWER). Those where `selection_role_code is not null`
 * @param p_notify_voter Notify "Voters": those where `voting_role_code is not null`
 */
procedure notify_track_session_load (
    p_notify_owner in varchar2
  , p_notify_voter in varchar2
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_track_session_load';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('LOAD_NOTIFICATION_TEMPLATE');

  fetch_common_links(l_substrings);

  for rec in (
    with user_emails as (
      select  sl.track_name
             ,sl.session_count
             ,u.email 
      from    ks_user_event_track_roles uetr
      join    ks_users u 
      on      uetr.username = u.username
      join    ks_session_load_coll_v sl 
      on      sl.track_id = uetr.event_track_id
      where   sl.notify_ind = 'Y'
      and     u.email is not null
      and     (
        ('OWNER' = p_notify_owner 
          and uetr.selection_role_code is not null)
        or
        ('VOTER' = p_notify_voter
          and uetr.voting_role_code is not null)
      )
      group   by sl.track_name
             ,sl.session_count
             ,u.email
    )
    select    ue.track_name
             ,ue.session_count
             ,listagg (ue.email,',') within group (order by ue.email desc) as email
    from      user_emails ue 
    group     by ue.track_name
             ,ue.session_count
  )
  loop
    ks_log.log (rec.track_name || '-' || rec.session_count || '-' || rec.email, l_scope);
    
    l_substrings('SESSION_COUNT') := rec.session_count;
    l_substrings('TRACK_NAME') := rec.track_name;

    l_subject := ' New sessions for: ' || rec.track_name;

    send_email (
       p_to => null
      ,p_from => l_from
      ,p_cc => null
      ,p_bcc => rec.email
      ,p_subject => l_subject 
      ,p_body => null
      ,p_body_html => null
      ,p_template_name =>  l_template_name
      ,p_substrings => l_substrings
    );
  end loop;

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_track_session_load;



/**
 * 
 * Send a user an email/notification with their new temporary password after a 
 * "Reset Password" (by an Admin) or a "Forgot Password" action (by a user)
 *
 * The text of the email is defined by the template mentioned in the 
 * `RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE` system parameter 
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_username
 * @param p_password
 * @param p_app_id
 */
procedure notify_reset_pwd_request (
    p_id in ks_users.id%type
   ,p_password in ks_users.password%type
   ,p_app_id in ks_parameters.value%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_reset_pwd_request';

  c_subject_notification constant varchar2(30) := 'Reset Password Request';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE');

  fetch_user_substitions (
    p_id => p_id
   ,p_substrings => l_substrings
  );
  fetch_common_links(l_substrings);

  l_substrings('TEMP_PASSWORD') := p_password;

  l_subject := c_subject_notification;

  send_email (
     p_to => l_substrings('USER_EMAIL')
    ,p_from => l_from
    ,p_cc => null
    ,p_bcc => null
    ,p_subject => l_subject 
    ,p_body => null
    ,p_body_html => null
    ,p_template_name =>  l_template_name
    ,p_substrings => l_substrings
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_reset_pwd_request;



/**
 * 
 * Notify a user after their password has been successfully changed (Reset Password)
 * The text of the email is defined by the template mentioned in the 
 * `RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE` system parameter 
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/13/2019
 * @param p_id ks_users.id
 */
procedure notify_reset_pwd_done (
    p_id in ks_users.id%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_reset_pwd_done';

  c_subject_notification constant varchar2(30) := 'Reset Password Done';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE');
  l_subject := c_subject_notification;

  fetch_user_substitions (
    p_id => p_id
   ,p_substrings => l_substrings
  );
  fetch_common_links(l_substrings);

  send_email (
     p_to => l_substrings('USER_EMAIL')
    ,p_from => l_from
    ,p_cc => null
    ,p_bcc => null
    ,p_subject => l_subject 
    ,p_body => null
    ,p_body_html => null
    ,p_template_name =>  l_template_name
    ,p_substrings => l_substrings
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_reset_pwd_done;





end ks_notification_api;
/

-- #13
-- @../plsql/ks_sec.pls
create or replace package ks_sec
is

C_AUTH_SUCCESS            constant number := 0;
C_AUTH_UNKNOWN_USER       constant number := 1;
C_AUTH_ACCOUNT_LOCKED     constant number := 2;
C_AUTH_ACCOUNT_EXPIRED    constant number := 3;
C_AUTH_PASSWORD_INCORRECT constant number := 4;
C_AUTH_PASSWORD_FIRST_USE constant number := 5;
C_AUTH_ATTEMPTS_EXCEEDED  constant number := 6;
C_AUTH_INTERNAL_ERROR     constant number := 7;

subtype salt_type               is varchar2(16);
subtype password_type           is varchar2(128);
subtype password_with_salt_type is varchar2(145); --Length of salt and password, plus 1 character seperator

user_not_found exception;
pragma exception_init (user_not_found, -20001);

function password_match (
  p_username in ks_users.username%type 
 ,p_password in ks_users.password%type
)
return boolean;

function is_valid_user (
       p_username IN varchar2
     , p_password IN varchar2
)
return boolean;

function password_with_salt (p_password IN varchar2)
   return varchar2;

procedure post_login;
 
function get_name_from_user(p_username in varchar2) return varchar2;

procedure request_reset_password (
    p_username in ks_users.username%type
   ,p_app_id in ks_parameters.value%type
);

procedure reset_password (
    p_username in ks_users.username%type
   ,p_new_password in ks_users.password%type
   ,p_new_password_2 in ks_users.password%type
   ,p_error_msg out varchar2
);

function is_password_expired (p_username in ks_users.username%type)
return boolean;

end ks_sec;
/
-- @../plsql/ks_sec.plb
set define off
-- alter session set PLSQL_CCFLAGS='CRYPTO_AVAILABLE:TRUE';
create or replace package body ks_sec
is

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 * @constance c_max_attempts Maximumn number of invalid login attempts
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';
c_max_attempts  constant number := 5;

/*****************************************************************************/
g_salt salt_type := 'rQ/PfG?Z8(C*4RP';
/*****************************************************************************/

/**
 * Validate if the password respects the format rules
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall
 * @created November 12, 2018
 * @param p_password
 * @return boolean
 */
function is_invalid_password (
  p_password in ks_users.password%type  
)
return boolean
is 
  l_scope ks_log.scope := gc_scope_prefix || 'is_invalid_password';
  
  l_password ks_users.password%type;
  l_char_repetead number;
begin
  ks_log.log('START', l_scope);


  if length (p_password) < 10 then 
    return true;
  end if;

  l_password := upper (p_password);

  if (instr (l_password, 'QUERTY') > 0)
    or (instr (l_password, 'ASDFG') > 0)
    or (instr (l_password, 'ZXCFV') > 0)
    or (instr (l_password, '12345') > 0)
    or (instr (l_password, 'GHJKL') > 0)
    or (instr (l_password, 'YUIOP') > 0)
    or (instr (l_password, 'PASSWORD') > 0)
    or (instr (l_password, 'WELCOME') > 0)
  then
   return true;
  end if;

  --passwords with a character repeated more than 4 times are not valid (ex: 'ppppassword')
  begin
    select  1
    into    l_char_repetead
    from    dual 
    where   regexp_like (p_password, '(.)\1{3,}');
  
    return true;
  exception
    when no_data_found then
      null;
  end;

  ks_log.log('END', l_scope);
  return false;
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end is_invalid_password;



/**
 * Check if the given password match with the registered one.
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created September 2, 2016
 * @param p_username
 * @param p_password
 * @return boolean
 */
function password_match (
  p_username in ks_users.username%type 
 ,p_password in ks_users.password%type
)
return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'password_match';

  l_retval boolean;
  l_password_db ks_users.password%type;
  l_salt salt_type;
  l_old_pass_hash password_type;
  l_new_pass_hash password_type;
begin
  ks_log.log('START', l_scope);

  select  u.password
  into    l_password_db
  from    ks_users u
  where   u.username = upper (p_username);

  l_old_pass_hash := SUBSTR (l_password_db, 1, INSTR (l_password_db, ':') - 1);
  l_salt := SUBSTR (l_password_db, INSTR (l_password_db, ':') + 1);

  $IF $$CRYPTO_AVAILABLE $THEN
  l_new_pass_hash := RAWTOHEX(dbms_crypto.hash(
      src => utl_raw.cast_to_raw(g_salt || p_password || l_salt),
      typ => dbms_crypto.HASH_SH512
  ));
  $ELSE
  -- old 
  -- 
  l_new_pass_hash := RAWTOHEX(dbms_obfuscation_toolkit.md5(
      input => utl_raw.cast_to_raw(g_salt || p_password || l_salt)
  ));
  $END

  l_retval := l_new_pass_hash = l_old_pass_hash;
  ks_log.log('l_retval:' || case l_retval when true then 'true' else 'false' end, l_scope);
  ks_log.log('END', l_scope);
  
  return l_retval;
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end password_match;



/**
 * Validate a given user and password
 *
 * 
 *
 * @author Jorge Rimblas
 * @created September 2, 2016
 * @param p_username case insensitive username
 * @param p_password case sensitive password for the user login in
 * @return true/false
 */
function is_valid_user (
       p_username IN varchar2
     , p_password IN varchar2
)
   return boolean
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'load_sessions';
  -- l_params logger.tab_param;

  l_retval           boolean := FALSE;
  l_old_pass_w_salt  password_with_salt_type;
  l_old_pass_hash    password_type;
  l_new_pass_hash    password_type;
  l_salt             salt_type;
  l_user_id          ks_users.id%TYPE;
  l_active_ind       ks_users.active_ind%TYPE;
  l_login_attempts   ks_users.login_attempts%TYPE;
  l_expired_passwd_flag ks_users.expired_passwd_flag%TYPE;

begin

   select id, password, active_ind, expired_passwd_flag, nvl(login_attempts, 0)
     into l_user_id
        , l_old_pass_w_salt
        , l_active_ind
        , l_expired_passwd_flag
        , l_login_attempts
     from ks_users
    where username = upper(p_username);

   if l_active_ind = 'Y' and l_login_attempts < c_max_attempts then
    
      l_retval := password_match (
         p_username => p_username
        ,p_password => p_password
      );

      if l_retval then
        apex_util.set_authentication_result (p_code => C_AUTH_SUCCESS);
        update ks_users
           set login_attempts = 0
             , last_login_date = sysdate
         where id = l_user_id;
      else
        apex_util.set_authentication_result (p_code => C_AUTH_PASSWORD_INCORRECT);
        update ks_users
           set login_attempts = nvl(login_attempts,0) + 1
             , active_ind = case when nvl(login_attempts,0) + 1 >= c_max_attempts then 'N' else active_ind end
         where id = l_user_id;
      end if;

   else
     apex_util.set_authentication_result (p_code => C_AUTH_ACCOUNT_LOCKED);
     update ks_users
        set active_ind = 'N'
      where id = l_user_id
        and active_ind = 'Y';
   end if;

   return l_retval;

exception

  when NO_DATA_FOUND then
    -- Set APEX authentication Codes
    apex_util.set_authentication_result (p_code => C_AUTH_UNKNOWN_USER);
    return l_retval;

end is_valid_user;





/*****************************************************************************/
function password_with_salt (p_password IN varchar2)
   return varchar2
is
   l_retval password_with_salt_type;
   l_salt   salt_type;
begin

   l_salt := SUBSTR(SYS_GUID(), 1, 16);

   $IF $$CRYPTO_AVAILABLE $THEN
   l_retval := RAWTOHEX(dbms_crypto.hash(
      src => utl_raw.cast_to_raw(g_salt || p_password || l_salt),
      typ => dbms_crypto.HASH_SH512
   ));
   $ELSE
   l_retval := RAWTOHEX(dbms_obfuscation_toolkit.md5(
      input => utl_raw.cast_to_raw(g_salt || p_password || l_salt)
   ));
   $END

   l_retval := l_retval || ':' || l_salt;

   return l_retval;

end password_with_salt;




/**
 * Sets enrionmonet after user successfully logs in.
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param
 * @return
 */
procedure post_login
is
  -- l_scope  logger_logs.scope%type := gc_scope_prefix || 'post_login';
  -- l_params logger.tab_param;
begin
  -- logger.append_param(l_params, 'p_param1', p_param1);
  -- logger.log('BEGIN', l_scope, null, l_params);

  apex_util.set_session_state(
      p_name  => 'G_ADMIN'
    , p_value => case when apex_authorization.is_authorized('ADMIN') then 'YES' else 'NO' end
  );

  -- logger.log('END', l_scope, null, l_params);

  exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end post_login;


/**
 * Get the name for a given user
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created November 8, 2018
 * @param name
 * @return
 */
function get_name_from_user(p_username in varchar2) return varchar2
is
  l_scope  ks_log.scope := gc_scope_prefix || 'get_name_from_user';
begin
  ks_log.log('START', l_scope);

  for n in (select full_name from ks_users_v where username = p_username)
  loop
    return n.full_name;
  end loop;
  
  if instr(p_username, '@') > 0 then
      return regexp_replace ( initcap( replace( substr ( p_username, 1, instr(p_username, '@') - 1 ), '.', ' ' ) ), '\s\w+\s', ' ' );
  else
      return initcap(p_username);
  end if;


  exception
    when OTHERS then
      ks_log.log_error('Unhandled Exception', l_scope);
      raise;
end get_name_from_user;



/**
 * Request a Password Reset for the user
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall
 * @created November 13, 2018
 * @param p_username
 * @param p_app_id
 */
 procedure request_reset_password (
    p_username in ks_users.username%type
  , p_app_id in ks_parameters.value%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'request_reset_password';

  c_not_equal_passwords constant varchar2(50) := 'Password and Repeat Passowrd must be the same.';
  c_password_not_valid constant varchar2(50) := 'The password is not valid.';

  l_id ks_users.id%type;
  l_temp_password ks_users.password%type;
begin
  ks_log.log('START', l_scope);

  begin
    select  u.id 
    into    l_id
    from    ks_users u
    where   u.username = nvl (upper (p_username), '-')
    and     u.active_ind = 'Y';
  exception
    when no_data_found then
      --if p_username is not found, the following application error is raised 
      -- (instead of the exception no_data_found) so the UI does not show any error message.
      -- This was implemented as a security policy to avoid using the "Reset Password"
      -- as a mechanism to know if a username is registered or not.
      ks_log.log('user ' || p_username || ' not found', l_scope);
      raise user_not_found;
  end;
  
  ks_log.log('l_id:' || l_id, l_scope);

  l_temp_password := dbms_random.string (
    opt => 'X'
   ,len => 6
  );

  update  ks_users 
  set     password = l_temp_password
         ,expired_passwd_flag = 'Y'
  where   id = l_id;

  ks_notification_api.notify_reset_pwd_request (
    p_id => l_id
   ,p_app_id => p_app_id
   ,p_password => l_temp_password
  );

  ks_log.log('END', l_scope);
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end request_reset_password;



/**
 * Reset the user's password
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall
 * @created November 12, 2018
 * @param p_username
 * @param p_new_password
 * @param p_new_password_2
 * @param p_error_msg
 * @return
 */
 procedure reset_password (
    p_username in ks_users.username%type
  , p_new_password in ks_users.password%type
  , p_new_password_2 in ks_users.password%type
  , p_error_msg out varchar2
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'reset_password';

  c_not_equal_passwords constant varchar2(50) := 'Password and Repeat Passowrd must be the same.';
  c_password_not_valid constant varchar2(50) := 'The new password is too short or simple.';

  l_id ks_users.id%type;
begin
  ks_log.log('START', l_scope);

  select  u.id 
  into    l_id
  from    ks_users u
  where   u.username = nvl (upper (p_username), '-');

  if nvl (p_new_password, '-') != nvl (p_new_password_2, '-') then
    p_error_msg := c_not_equal_passwords;
    return;
  end if;

  if is_invalid_password (p_new_password) then
    p_error_msg := c_password_not_valid;
    return;
  end if;

  update  ks_users 
  set     password = p_new_password
         ,expired_passwd_flag = null
         ,login_attempts = 0
  where   id = l_id;

  ks_notification_api.notify_reset_pwd_done (
    p_id => l_id
  );

  ks_log.log('END', l_scope);
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end reset_password;


/**
 * Check if the username's password is expired
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created November 13, 2018
 * @param p_username
 * @return boolean
 */
function is_password_expired (p_username in ks_users.username%type)
return boolean
is
begin
  for u in (
    select  1 
    from    ks_users 
    where   username = upper (p_username) 
    and     expired_passwd_flag = 'Y'
  )
  loop
    return true;
  end loop;
  return false;
end is_password_expired;


end ks_sec;
/




-- *** DML ***
insert into constraint_lookup (constraint_name,message) values ('KS_USERNAME_U','User already exists.');

delete from ks_parameters where name_key in ('ADMIN_APP_ID');
insert into ks_parameters(category, name_key, value, description) values ('SYSTEM', 'ADMIN_APP_ID', '83791', 'ID of Admin app');

delete from ks_parameters where name_key in ('SERVER_URL');
insert into ks_parameters(category, name_key, value, description) values ('SYSTEM', 'SERVER_URL', 'https://apex.oracle.com/pls/apex/f?p=', 'Server URL');

delete from ks_parameters where name_key in ('LOAD_NOTIFICATION_TEMPLATE');
insert into ks_parameters(category, name_key, value, description) values ('Notifications', 'LOAD_NOTIFICATION_TEMPLATE', 'SESSION_LOAD', 'Name of email template for load notifications');


insert into ks_parameters (category,name_key,value,description) values ('Notifications','RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE','RESET_PASSWORD_DONE_NOTIFICATION','Name of email template for when a reset password is executed');
insert into ks_parameters (category,name_key,value,description) values ('Notifications','RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE','RESET_PASSWORD_REQUEST_NOTIFICATION','Name of email template for reset password request notifications');


update ks_roles
   set name = 'Public Voter'
 where role_type = 'VOTING'
   and code = 'BLIND';


-- #16
-- New columns presented_anything_ind, presented_anything_where
-- fix order
-- @../conversion/seed_ks_load_mapping.sql
REM INSERTING into KS_LOAD_MAPPING
SET DEFINE OFF;
PRO Removing previous mapping
delete from KS_LOAD_MAPPING;
PRO Populating mapping

Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',1,'SESSION_NUM','Session Number');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',2,'TITLE','Session Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',3,null,'Session Title Link');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',4,'EVENT_TRACK_ID','Track');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',5,'SUB_CATEGORY','Sub-Categorization');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',6,'SESSION_TYPE','Session Type');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',7,null,'Role:Submitter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',8,null,'Session Status');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',9,null,'All roles');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',10,null,'All roles (with line break)');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',11,'ACE_LEVEL','Are you part of the ACE program?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',12,null,'Cross-Listed Tracks');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',13,'PRESENTED_ANYTHING_IND','Have you ever presented before a live audience?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',14,'PRESENTED_BEFORE_IND','Have you presented this session before?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',15,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',16,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',17,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',18,'PRESENTED_ANYTHING_WHERE','If yes, at what events?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',19,'PRESENTED_BEFORE_WHERE','If yes, at what events?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',20,'SUBMISSION_DATE','Initial Submission');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',21,null,'Last Update');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',22,'VIDEO_LINK','Link to your optional abstract submission video');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',23,null,'Review Comments');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',24,null,'Role:Co-Presenter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',25,'CO_PRESENTER_COMPANY','Role:Co-Presenter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',26,null,'Role:Co-Presenter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',27,'CO_PRESENTER','Role:Co-Presenter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',28,null,'Role:Co-Presenter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',29,null,'Role:Co-Presenter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',30,'CO_PRESENTER_USER_ID','Role:Co-Presenter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',31,'PRESENTER_BIOGRAPHY','Role:Primary Presenter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',32,'COMPANY','Role:Primary Presenter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',33,'PRESENTER_EMAIL','Role:Primary Presenter Email');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',34,null,'Role:Primary Presenter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',35,'PRESENTER','Role:Primary Presenter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',36,null,'Role:Primary Presenter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',37,null,'Role:Primary Presenter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',38,'PRESENTER_USER_ID','Role:Primary Presenter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',39,null,'Role:Submitter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',40,null,'Role:Submitter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',41,null,'Role:Submitter Email');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',42,null,'Role:Submitter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',43,null,'Role:Submitter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',44,null,'Role:Submitter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',45,null,'Role:Submitter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',46,'SESSION_ABSTRACT','Session Description');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',47,'EXTERNAL_SYS_REF','Session Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',48,'SESSION_SUMMARY','Short Description');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',49,null,'Status Change');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',50,'TAGS','Tags');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',51,'TARGET_AUDIENCE','Target Audience');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',52,'TECHNOLOGY_PRODUCT','Technologies or Products Used');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',53,null,'Vote Average');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',54,null,'Vote Count');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',55,'CONTAINS_DEMO_IND','Will this presentation include a demo?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',56,'WEBINAR_WILLING_IND','Would you be willing to present this as a webinar?');
-- @../conversion/seed_ks_email_templates.sql
REM INSERTING into KS_EMAIL_TEMPLATES
SET DEFINE OFF
SET SQLBLANKLINES ON
Insert into KS_EMAIL_TEMPLATES (NAME,TEMPLATE_TEXT) values ('RESET_PASSWORD_REQUEST_NOTIFICATION','Hi #USER_FIRST_NAME#,

You either have a brand new account with username #USERNAME# or a reset password has been requested for your account on the ODTUG Kscope Voting Apps.

Your temporary password is: #TEMP_PASSWORD#
You will need to change it when you log in for the first time.

Click on the following link to login to the Voting App:
#VOTING_APP_LINK#

If you''re a Track Lead you can use the Abstract Review App:
#ADMIN_APP_LINK#
');
Insert into KS_EMAIL_TEMPLATES (NAME,TEMPLATE_TEXT) values ('RESET_PASSWORD_DONE_NOTIFICATION','Hi #USER_FIRST_NAME#,
Your password has been reset.

If you did not reset it, please contact info@odtug.com
');
Insert into KS_EMAIL_TEMPLATES (NAME,TEMPLATE_TEXT) values ('SESSION_LOAD','The "#TRACK_NAME#" track has received #SESSION_COUNT# sessions.

If the voting period is open go vote at:
#VOTING_APP_LINK#

If you''re a Track Lead you can use the Abstract Review App:
#ADMIN_APP_LINK#
');



-- DO NOT TOUCH/UPDATE BELOW THIS LINE


PRO Recompiling objects
exec dbms_utility.compile_schema(schema => user, compile_all => false);

