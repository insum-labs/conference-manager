-- =============================================================================
-- ==========================  Full _release.sql file
-- =============================================================================

-- =============================================================================

insert into ks_session_status (display_seq, code, name, active_ind) values (35, 'ALT', 'Alternate', 'Y');



-- =============================================================================

-- install new version of the staging table to accomodate the new columns
-- @../install/ks_full_session_load.sql

-- drop table ks_full_session_load purge;
create table ks_full_session_load (
    app_user                      varchar2(60) default coalesce(
                                         sys_context('APEX$SESSION','app_user')
                                       , sys_context ('userenv', 'os_user'), user)
 , external_sys_ref              varchar2(4000)
 , session_num                   varchar2(4000)
 , event_track_id                varchar2(4000)
 , sub_category                  varchar2(4000)
 , session_type                  varchar2(4000)
 , title                         varchar2(4000)
 , ace_level                     varchar2(4000)
 , presented_before_ind          varchar2(4000)
 , presented_before_where        varchar2(4000)
 , video_link                    varchar2(4000)
 , co_presenter                  varchar2(4000)
 , presenter_biography           clob
 , company                       varchar2(4000)
 , presenter                     varchar2(4000)
 , session_abstract              clob
 , session_summary               varchar2(4000)
 , tags                          varchar2(4000)
 , target_audience               varchar2(4000)
 , technology_product            varchar2(4000)
 , contains_demo_ind             varchar2(4000)
 , webinar_willing_ind           varchar2(4000)
 , presenter_email               varchar2(4000)
 , presenter_user_id             varchar2(4000)
 , co_presenter_user_id          varchar2(4000)
)
/





comment on table ks_full_session_load is 'Staging table for loading sessions.';


-- install staging table's "lookup table" for what columns in it match what columns in the export file
-- @../install/ks_load_mapping.sql
PRO ..ks_load_mapping 

-- drop table ks_load_mapping purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_load_mapping (
    id                  number        generated by default on null as identity (start with 1) primary key not null
  , table_name          varchar2(32)   not null
  , display_seq         number         not null
  , header_name         varchar2(4000) not null
  , to_column_name      varchar2(30)
  , created_by          varchar2(60) default on null coalesce(
                           sys_context('APEX$SESSION','app_user')
                         , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                         , sys_context('userenv','session_user')
                        )  not null
  , created_on          date default on null sysdate not null
  , updated_by          varchar2(60)
  , updated_on          date
  , constraint load_mapping_unique unique(table_name,header_name,display_seq)
)
/

comment on table ks_load_mapping is 'Contains a map of which columns in correspond to the export file.';


create or replace trigger ks_load_mapping_bu
  before update on ks_load_mapping
  referencing new as new
  for each row
begin
  :new.updated_on := sysdate;
  if :new.updated_by is null then
    :new.updated_by := coalesce(
          sys_context('APEX$SESSION','app_user')
         ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
         ,sys_context('userenv','session_user')
         );
  end if;
end;
/
-- @../conversion/seed_ks_load_mapping.sql
/*
These inserts are based on these export columns.

Session Number
Session Title
Session Title Link
Track
Sub-Categorization
Session Type
Role:Submitter
Full Name	Session
Status	All roles
All roles (with line break)
Are you part of the ACE program?
Cross-Listed Tracks
Have you presented this session before?
I Agree	I Agree	I Agree
If yes, at what events?
Initial Submission
Last Update
Link to your optional abstract submission video
Review Comments
Role:Co-Presenter Biography
Role:Co-Presenter Company
Role:Co-Presenter First Name
Role:Co-Presenter Full Name
Role:Co-Presenter Last Name
Role:Co-Presenter Title
Role:Co-Presenter User Id
Role:Primary Presenter Biography
Role:Primary Presenter Company
Role:Primary Presenter First Name
Role:Primary Presenter Full Name
Role:Primary Presenter Last Name
Role:Primary Presenter Title
Role:Primary Presenter User Id
Role:Submitter Biography
Role:Submitter Company
Role:Submitter First Name
Role:Submitter Last Name
Role:Submitter Title
Role:Submitter User Id
Session Description	Session Id
Short Description	Status Change
Tags
Target Audience
Technologies or Products Used
Vote Average	Vote Count
Will this presentation include a demo?
Would you be willing to present this as a webinar?
Role:Primary Presenter Email
Role:Submitter Email
*/


delete from ks_load_mapping;

SET DEFINE OFF;




insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 1, 'SESSION_NUM', 'Session Number'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 2, 'TITLE', 'Session Title'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 3, null, 'Session Title Link'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 4, 'EVENT_TRACK_ID', 'Track'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 5, 'SUB_CATEGORY', 'Sub-Categorization'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 6, 'SESSION_TYPE', 'Session Type'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 7, null, 'Role:Submitter Full Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 8, null, 'Session Status'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 9, null, 'All roles'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 10, null, 'All roles (with line break)'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 11, 'ACE_LEVEL', 'Are you part of the ACE program?'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 12, null, 'Cross-Listed Tracks'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 13, 'PRESENTED_BEFORE_IND', 'Have you presented this session before?'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 14, null, 'I Agree'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 15, null, 'I Agree'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 16, null, 'I Agree'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 17, 'PRESENTED_BEFORE_WHERE', 'If yes, at what events?'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 18, null, 'Initial Submission'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 19, null, 'Last Update'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 20, 'VIDEO_LINK', 'Link to your optional abstract submission video'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 21, null, 'Review Comments'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 22, null, 'Role:Co-Presenter Biography'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 23, null, 'Role:Co-Presenter Company'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 24, null, 'Role:Co-Presenter First Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 25, 'CO_PRESENTER', 'Role:Co-Presenter Full Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 26, null, 'Role:Co-Presenter Last Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 27, null, 'Role:Co-Presenter Title'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 28, 'CO_PRESENTER_USER_ID', 'Role:Co-Presenter User Id'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 29, 'PRESENTER_BIOGRAPHY', 'Role:Primary Presenter Biography'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 30, 'COMPANY', 'Role:Primary Presenter Company'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 31, null, 'Role:Primary Presenter First Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 32, 'PRESENTER', 'Role:Primary Presenter Full Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 33, null, 'Role:Primary Presenter Last Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 34, null, 'Role:Primary Presenter Title'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 35, 'PRESENTER_USER_ID', 'Role:Primary Presenter User Id'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 36, null, 'Role:Submitter Biography'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 37, null, 'Role:Submitter Company'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 38, null, 'Role:Submitter First Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 39, null, 'Role:Submitter Last Name'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 40, null, 'Role:Submitter Title'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 41, null, 'Role:Submitter User Id'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 42, 'SESSION_ABSTRACT', 'Session Description'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 43, 'EXTERNAL_SYS_REF', 'Session Id'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 44, 'SESSION_SUMMARY', 'Short Description'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 45, null, 'Status Change'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 46, 'TAGS', 'Tags'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 47, 'TARGET_AUDIENCE', 'Target Audience'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 48, 'TECHNOLOGY_PRODUCT', 'Technologies or Products Used'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 49, null, 'Vote Average'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 50, null, 'Vote Count'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 51, 'CONTAINS_DEMO_IND', 'Will this presentation include a demo?'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 52, 'WEBINAR_WILLING_IND', 'Would you be willing to present this as a webinar?'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 53, 'PRESENTER_EMAIL', 'Role:Primary Presenter Email'
  );
insert into ks_load_mapping(
  table_name, display_seq, to_column_name, header_name
  )
values(
  'KS_FULL_SESSION_LOAD', 54, null, 'Role:Submitter Email'
  );


-- new tables to accomdate roles
-- @../install/ks_roles.sql
PRO ..ks_roles

-- drop table ks_user_event_track_roles purge;
-- drop table ks_roles purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_roles (
    id            number        generated by default on null as identity (start with 1) primary key
  , display_seq   number        not null
  , role_type     varchar2(10)  not null
  , code          varchar2(20)  not null
  , name          varchar2(32)  not null
  , active_ind    varchar2(1)   not null
  , created_by    varchar2(60) default
                  coalesce(
                     sys_context('APEX$SESSION','app_user')
                     ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                     ,sys_context('userenv','session_user')
                     )
                  not null
  , created_on    date         default sysdate not null
  , updated_by    varchar2(60)
  , updated_on    date
  , constraint ks_role_u unique (code)
  , constraint ks_role_types_check check (role_type in ('SELECTION', 'VOTING'))
)
enable primary key using index
/

create unique index ks_roles_u01
  on ks_roles(upper(code))
/

comment on table ks_roles is 'Roles';

comment on column ks_roles.id is 'surrogate unique identifier';
comment on column ks_roles.role_type is  'Role type is either SELECTION | VOTING';
comment on column ks_roles.code is  'unchanging unique identifier for the role';
comment on column ks_roles.name is  'Friendly name of the role';
comment on column ks_session_status.display_seq is 'Order for displaying the fav lines';
comment on column ks_session_status.active_ind is 'Is the record enabled Y/N?';

--------------------------------------------------------
--  DDL for Trigger ks_roles_u_trg
--------------------------------------------------------
create or replace trigger ks_roles_u_trg
before update
on ks_roles
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                     sys_context('APEX$SESSION','app_user')
                     ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                     ,sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_roles_u_trg enable;
-- @../conversion/seed_ks_roles.sql
PRO seed ks_roles

SET DEFINE OFF;

delete from ks_roles;
insert into ks_roles (display_seq, code, name, role_type, active_ind) values (10, 'OWNER', 'Owner', 'SELECTION', 'Y');
insert into ks_roles (display_seq, code, name, role_type, active_ind) values (20, 'VIEWER', 'Viewer', 'SELECTION', 'Y');
insert into ks_roles (display_seq, code, name, role_type, active_ind) values (30, 'COMMITTEE', 'Abstract Reviewer', 'VOTING','Y');
insert into ks_roles (display_seq, code, name, role_type, active_ind) values (40, 'BLIND', 'Blind Voter','VOTING', 'Y');


-- @../install/ks_user_event_track_roles.sql
PRO ..ks_user_event_track_roles

-- drop table ks_user_event_track_roles purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_user_event_track_roles (
    id                  number        generated by default on null as identity (start with 1) primary key
  , username            varchar2(60) not null
  , event_track_id      number       not null
  , selection_role_code varchar2(20)
  , voting_role_code    varchar2(20)
  , created_by          varchar2(60) default
                        coalesce(
                          sys_context('APEX$SESSION','app_user')
                          ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                          ,sys_context('userenv','session_user')
                          )
                        not null
  , created_on          date         default sysdate not null
  , updated_by          varchar2(60)
  , updated_on          date
  , constraint ks_user_evt_trk_role_user_fk foreign key ( username ) references ks_users ( username ) not deferrable
  , constraint ks_usr_evt_trk_rol_evt_trk_fk foreign key ( event_track_id ) references ks_event_tracks ( id ) not deferrable
  , constraint ks_user_evt_vote_role_role_fk foreign key ( voting_role_code ) references ks_roles ( code ) not deferrable
  , constraint ks_user_evt_vote_sel_role_fk foreign key ( selection_role_code ) references ks_roles ( code ) not deferrable
  , constraint ks_user_evt_trk_role_u1 unique (username, event_track_id)
)
enable primary key using index
/

comment on table ks_user_event_track_roles is 'User Event-Track Roles.';

comment on column ks_user_event_track_roles.id is 'unique surrogate key value ';
comment on column ks_user_event_track_roles.username is 'FK to users table';
comment on column ks_user_event_track_roles.event_track_id is 'FK to event_track table';
comment on column ks_user_event_track_roles.voting_role_code is 'FK to role table for voting role';
comment on column ks_user_event_track_roles.selection_role_code is 'FK to role table for selection role';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_user_event_track_role_u_trg
before update
on ks_user_event_track_roles
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                     sys_context('APEX$SESSION','app_user')
                     ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                     ,sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_user_event_track_role_u_trg enable;



-- =============================================================================
-- @../conversion/move_owners_to_roles.sql
PRO seed ks_user_event_track_roles

SET DEFINE OFF;

-- Insert track owners in ks_user_event_track_roles (All Owners for Kscope16, Kscope17 and Kscope18)
insert into ks_user_event_track_roles (username,event_track_id,selection_role_code,voting_role_code)
select owner,id,'OWNER','COMMITTEE'
from ks_event_tracks
where owner is not null
/
-- drop track owner from the track instance
alter table ks_event_tracks drop column owner;




-- =============================================================================
-- add voting date fields to events and event-tracks
alter table ks_events add (
    blind_vote_begin_date  date
  , blind_vote_end_date    date
  , committee_vote_begin_date date
  , committee_vote_end_date   date
)
/
comment on column ks_events.blind_vote_begin_date is 'Begin date of blind voting';
comment on column ks_events.blind_vote_end_date is 'End date of blind voting';
comment on column ks_events.committee_vote_begin_date is 'Begin date of committee voting';
comment on column ks_events.committee_vote_end_date is 'End date of committee voting';

alter table ks_event_tracks add (
    blind_vote_begin_date  date
  , blind_vote_end_date    date
  , committee_vote_begin_date date
  , committee_vote_end_date   date
)
/

comment on column ks_event_tracks.blind_vote_begin_date is 'Track Override for Begin date of blind voting';
comment on column ks_event_tracks.blind_vote_end_date is 'Track Override for End date of blind voting';
comment on column ks_event_tracks.committee_vote_begin_date is 'Track Override for Begin date of committee voting';
comment on column ks_event_tracks.committee_vote_end_date is 'Track Override for End date of committee voting';


-- =============================================================================
alter table ks_event_tracks add (
    blind_vote_help        varchar2(4000)
  , committee_vote_help    varchar2(4000)
)
/
comment on column ks_event_tracks.blind_vote_help is 'Help for blind voters';
comment on column ks_event_tracks.committee_vote_help is 'Help for committee voters';




-- =============================================================================
alter table ks_users add external_sys_ref varchar2(20);
comment on column ks_users.external_sys_ref is 'Unique "ID" for external system.';





-- =============================================================================

--Update ks_sessions to allow for scoring, and other input from the user's uploading of an excel file.
alter table ks_sessions add presenter_email varchar2(500);
alter table ks_sessions add session_summary varchar2(4000);
alter table ks_sessions add session_abstract clob;
alter table ks_sessions add target_audience varchar2(60);
alter table ks_sessions add presented_before_ind varchar2(1) default on null 'N';
alter table ks_sessions add presented_before_where varchar2(4000);
alter table ks_sessions add technology_product varchar2(500);
alter table ks_sessions add ace_level varchar2(30);
alter table ks_sessions add video_link varchar2(4000);
alter table ks_sessions add contains_demo_ind varchar2(1) default on null 'N';
alter table ks_sessions add webinar_willing_ind varchar2(1) default on null 'N';
alter table ks_sessions add presenter_biography clob;
alter table ks_sessions add external_sys_ref varchar2(20);
alter table ks_sessions add presenter_user_id varchar2(20);
alter table ks_sessions add co_presenter_user_id varchar2(20);

alter table ks_sessions add constraint sessions_ck_presb4_is_yn check (presented_before_ind in ('Y', 'N'));
alter table ks_sessions add constraint sessions_ck_demo_is_yn check (contains_demo_ind in ('Y', 'N'));
alter table ks_sessions add constraint sessions_ck_web_will_is_yn check (webinar_willing_ind in ('Y', 'N'));

comment on column ks_sessions.presenter_email is 'The email address to contact the presenter.';
comment on column ks_sessions.session_summary is 'Summary/Short description. This is cut off at 4000 characters since anything submitted that''s longer is not short.';
comment on column ks_sessions.session_abstract is 'The full abstract of the session. This is a clob b/c it can be > 4000 characters';
comment on column ks_sessions.target_audience is 'The audience the session is intended for. Can be multiple audiences.';
comment on column ks_sessions.presented_before_ind is 'Whether the presenter has presented this session before.';
comment on column ks_sessions.presented_before_where is 'Where the presenter has presented this session before. ';
comment on column ks_sessions.technology_product is 'Technologies or products discussed in the presentation.';
comment on column ks_sessions.ace_level is 'Whether the presenter is part of an ace program. The common values are No, Oracle Ace, Oracle Ace Director, Oracle Ace Associate.';
comment on column ks_sessions.video_link is 'Link to a video for furth info about the session.';
comment on column ks_sessions.contains_demo_ind is 'Whether a demo is included. Correct values or Y or N.';
comment on column ks_sessions.webinar_willing_ind is 'Whether the presenter is willing to do the session as a webinar. Correct values are Y or N.';
comment on column ks_sessions.presenter_biography is 'The biography of this session''s presenter.';
comment on column ks_sessions.external_sys_ref is 'Unique "ID" for external system.';
comment on column ks_sessions.presenter_user_id is 'External System User ID of the presenter';
comment on column ks_sessions.co_presenter_user_id is 'External System User ID of the co-presenter';


alter table ks_sessions modify tags varchar2(1000);





-- =============================================================================
-- adding event-types
-- @../install/ks_event_types.sql
PRO ..ks_event_types

-- drop table ks_event_types purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_types (
    id            number        generated by default on null as identity (start with 1) primary key
  , display_seq   number        not null
  , code          varchar2(20)  not null
  , name          varchar2(60)  not null
  , active_ind    varchar2(1)   default 'Y' not null
  , created_by    varchar2(60)  default
                  coalesce(
                     sys_context('APEX$SESSION','app_user')
                     ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                     ,sys_context('userenv','session_user')
                     )
                  not null
  , created_on    date         default sysdate not null
  , updated_by    varchar2(60)
  , updated_on    date
  , constraint ks_event_type_u unique (code)
)
enable primary key using index
/

create unique index ks_event_types_u01
  on ks_event_types(upper(code))
/

comment on table ks_event_types is 'Event Type';

comment on column ks_event_types.id is 'surrogate unique identifier';
comment on column ks_event_types.code is  'unchanging unique identifier for the event type';
comment on column ks_event_types.name is  'Friendly name of the event type';
comment on column ks_session_status.display_seq is 'Order for displaying the fav lines';
comment on column ks_session_status.active_ind is 'Is the record enabled Y/N?';

--------------------------------------------------------
--  DDL for Trigger ks_event_types_u_trg
--------------------------------------------------------
create or replace trigger ks_event_types_u_trg
before update
on ks_event_types
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                     sys_context('APEX$SESSION','app_user')
                     ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                     ,sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_event_types_u_trg enable;
-- @../conversion/seed_ks_event_types.sql
PRO seed ks_event_types

SET DEFINE OFF;

delete from ks_event_types;
insert into ks_event_types (display_seq, code, name, active_ind) values (10, 'KSCOPE', 'ODTUG Kscope', 'Y');

alter table ks_events add
  event_type varchar2(20);

comment on column ks_events.event_type is 'type of event';

update ks_events
  set event_type = 'KSCOPE';

-- add foreign key constraint from events to event-types
alter table ks_events add constraint ks_events_event_type_fk foreign key (event_type) references ks_event_types (code);
alter table ks_events modify event_type not null;





-- =============================================================================

-- modifications for voting by community and committee
alter table ks_session_votes add (
    vote_type varchar2(10)  -- COMMITTEE | BLIND
  , username  varchar2(60)
)
/

comment on column ks_session_votes.vote_type is 'Identifies the type of vote recorded: COMMITTEE or BLIND';
comment on column ks_session_votes.username is 'User that casted the vote.';


alter table ks_session_votes modify vote_type not null;
alter table ks_session_votes modify username not null;


--Now Add users that are existent in ks_session_voter but not in ks_users
merge into ks_users u
  using (select distinct username, voter from ks_session_votes) v
  on (u.username = v.username)
  when not matched
    then
      insert (username, first_name, active_ind, admin_ind) values (v.username, v.voter, 'Y', 'N')
/

--Finally drop the voter column
alter table ks_session_votes drop column voter
/

-- one vote per user per session
create unique index ks_session_votes_u01 on ks_session_votes(username, session_id);


-- =============================================================================
-- Seed ks_parameters
delete from ks_parameters where name_key = 'DEFAULT_BLIND_VOTING_HELP';
insert into ks_parameters(category, name_key, value, description)
                   values('Messages',
                          'DEFAULT_BLIND_VOTING_HELP'
                        , 'Vote on all sessions to the best of your ability.<br>'
                       || '1 is the lowest rating and 5 is the highest. Use 1 or 2 for sessions you have no interest in.'
                        , 'The default help message for blind voters viewed while voting on a track.');

delete from ks_parameters where name_key = 'DEFAULT_COMMITTEE_VOTING_HELP';
insert into ks_parameters(category, name_key, value, description)
                   values('Messages'
                        , 'DEFAULT_COMMITTEE_VOTING_HELP'
                        , 'Vote on all sessions to the best of your ability.<br>'
                       || '1 is the lowest rating and 5 is the highest. Use 1 or 2 for sessions you have no interest in.'
                        , 'The default help message for blind voters viewed while voting on a track.');

delete from ks_parameters where name_key = 'REVIEW_PRIVACY_NOTICE';
insert into ks_parameters(category, name_key, value, description)
                   values('Messages',
                          'REVIEW_PRIVACY_NOTICE',
                          'Remember, all the votes and comments are private information and can only be discussed with other members of the committee.',
                          'This message is viewed once by anyone using the review app.');

delete from ks_parameters where name_key = 'VOTING_PRIVACY_NOTICE';
insert into ks_parameters(category, name_key, value, description)
                   values('Messages',
                          'VOTING_PRIVACY_NOTICE',
                          'Remember, all the votes and comments are private information and can only be discussed with the content committee.',
                          'This message is viewed once by anyone using the voting app.');


-- 
delete from ks_parameters where name_key = 'ANONYMIZE_EXTRA_TOKENS';
insert into ks_parameters(category, name_key, value, description)
                   values('Sessions'
                        , 'ANONYMIZE_EXTRA_TOKENS'
                        , ''
                        , 'Case-insensitive, space-delimited list of words to anonymize. E.g. "Word1 Word2 Word3"');

-- 
delete from ks_parameters where name_key in ('EMAIL_FROM_ADDRESS', 'FEEDBACK_EMAIL', 'EMAIL_OVERRIDE', 'EMAIL_PREFIX');
insert into ks_parameters(category, name_key, value, description) values ('SYSTEM', 'EMAIL_FROM_ADDRESS', 'info@noname.com', 'Email addresses used to send emails.');
insert into ks_parameters(category, name_key, value, description) values ('SYSTEM', 'FEEDBACK_EMAIL', 'info@noname.com', 'Email addresses that will receive system feedback.');
insert into ks_parameters(category, name_key, value, description) values ('SYSTEM', 'EMAIL_OVERRIDE', '', 'Comma delimited list of emails that will be used to override all emails from the system.  For use during dev and test.');
insert into ks_parameters(category, name_key, value, description) values ('SYSTEM', 'EMAIL_PREFIX', '[VOTEAPP] ', 'Prefix used when sending emails');

delete from ks_parameters where name_key in ('VOTING_APP_ID');
insert into ks_parameters(category, name_key, value, description) values ('SYSTEM', 'VOTING_APP_ID', '120124', 'ID of voting app');

-- =============================================================================

-- @../conversion/seed_constraint_lookup.sql
prompt seed constraint_lookup

SET DEFINE OFF;
delete from constraint_lookup;
insert into constraint_lookup (constraint_name,message) values ('KS_USERS_U01','User already exists.');
insert into constraint_lookup (constraint_name,message) values ('KS_USERS_U02','Email already exists.');
insert into constraint_lookup (constraint_name,message) values ('KS_SESSIONS_U01','Session already exists.');
insert into constraint_lookup (constraint_name,message) values ('KS_TRACKS_U01','Track already exists.');
insert into constraint_lookup (constraint_name,message) values ('KS_EVENT_OWNER_FK','Owner already assigned, cannot change.');

--- Add New Constrainst Below ----
-- vvvvvvvvvvvvvvvvvvvvvvvvvvvv --
insert into constraint_lookup (constraint_name,message) values ('KS_USER_EVT_TRK_ROLE_U1','User already assigned to a track.');
insert into constraint_lookup (constraint_name,message) values ('KS_USER_EVT_TRK_ROLE_USER_FK','User cannot be deleted. Remove all assignments for this user first.');
insert into constraint_lookup (constraint_name,message) values ('KS_EVENT_TYPE_U','That code is already in use.');
insert into constraint_lookup (constraint_name,message) values ('KS_EVENTS_EVENT_TYPE_FK','Cannot delete an event type that is in use already.');




-- =============================================================================

-- @../views/ks_users_v.sql
PRO ks_users_v
create or replace view ks_users_v
as
select u.id
     , u.username
     , u.password
     , u.first_name
     , u.last_name
     , u.first_name || nvl2(u.last_name, ' ' || u.last_name, '') full_name
     , u.email
     , u.active_ind
     , u.admin_ind
     , u.external_sys_ref
     , u.created_by
     , u.created_on
     , u.updated_by
     , u.updated_on
  from ks_users u
/
-- @../views/ks_events_tracks_v.sql
create or replace view ks_events_tracks_v
as
  select e.id event_id
       , t.id event_track_id
       , e.name event_name
       , t.display_seq
       , t.name track_name
       , nvl(t.alias, t.name) track_alias
       , nvl(t.blind_vote_begin_date , e.blind_vote_begin_date ) blind_vote_begin_date
       , nvl(t.committee_vote_begin_date, e.committee_vote_begin_date) committee_vote_begin_date
       , nvl(nvl(t.blind_vote_end_date   , e.blind_vote_end_date ), sysdate) blind_vote_end_date
       , nvl(nvl(t.committee_vote_end_date  , e.committee_vote_end_date), sysdate) committee_vote_end_date
       , case when sysdate between nvl(t.blind_vote_begin_date , e.blind_vote_begin_date)
                               and nvl(nvl(t.blind_vote_end_date, e.blind_vote_end_date), trunc(sysdate))+.99999 then 'Y' else 'N' end blind_voting_current_ind
       , case when sysdate between nvl(t.committee_vote_begin_date, e.committee_vote_begin_date)
                               and nvl(nvl(t.committee_vote_end_date, e.committee_vote_end_date), trunc(sysdate))+.99999 then 'Y' else 'N' end committee_voting_current_ind
       , case when sysdate between e.begin_date and nvl(e.end_date, e.begin_date) then 'Y' else 'N' end event_current_ind
       , e.begin_date begin_date
       , nvl(e.end_date, e.begin_date) end_date
       , e.active_ind event_active_ind
       , t.active_ind track_active_ind
       , t.blind_vote_help
       , t.committee_vote_help
       , (case
            when sysdate < nvl(t.blind_vote_begin_date,e.blind_vote_begin_date ) then
              'Opens ' || to_char(nvl(t.blind_vote_begin_date,e.blind_vote_begin_date ), 'fmDay, fmMonth fmDD, YYYY')
            when sysdate >= nvl(t.blind_vote_begin_date,e.blind_vote_begin_date )
                        and nvl(t.blind_vote_end_date,e.blind_vote_end_date ) is null then
              'Opened Indefinately'
            when sysdate >= nvl(t.blind_vote_begin_date,e.blind_vote_begin_date )
             and sysdate < nvl(t.blind_vote_end_date,e.blind_vote_end_date )+.99999 then
              'Closes ' || to_char(nvl(t.blind_vote_end_date,e.blind_vote_end_date), 'fmDay, fmMonth fmDD, YYYY')
            when sysdate >= nvl(t.blind_vote_end_date,e.blind_vote_end_date)
             and sysdate <= (nvl(t.blind_vote_end_date,e.blind_vote_end_date) + 7 + .99999) then
              'Closed ' || to_char(nvl(t.blind_vote_end_date,e.blind_vote_end_date), 'fmDay, fmMonth fmDD, YYYY')
            else ''
          end) blind_vote_date_desc
       , (case
            when sysdate < nvl(t.committee_vote_begin_date,e.committee_vote_begin_date ) then
              'Opens ' || to_char(nvl(t.committee_vote_begin_date,e.committee_vote_begin_date ), 'fmDay, fmMonth fmDD, YYYY')
            when sysdate >= nvl(t.committee_vote_begin_date,e.committee_vote_begin_date )
                        and nvl(t.committee_vote_end_date,e.committee_vote_end_date ) is null then
              'Open Indefinately'
            when sysdate >= nvl(t.committee_vote_begin_date,e.committee_vote_begin_date )
             and sysdate < nvl(t.committee_vote_end_date,e.committee_vote_end_date )+.99999 then
              'Closes ' || to_char(nvl(t.committee_vote_end_date,e.committee_vote_end_date), 'fmDay, fmMonth fmDD, YYYY')
            when sysdate >= nvl(t.committee_vote_end_date,e.committee_vote_end_date)
             and sysdate <= (nvl(t.committee_vote_end_date,e.committee_vote_end_date) + 7 + .99999) then
              'Closed ' || to_char(nvl(t.committee_vote_end_date,e.committee_vote_end_date), 'fmDay, fmMonth fmDD, YYYY')
            else ''
          end) committee_vote_date_desc
       , t.max_comps
       , t.max_sessions
  from ks_events e
     , ks_event_tracks t
 where 1=1
   and t.event_id = e.id
/




-- =============================================================================
PRO PACKAGES
PRO .Specs
--install .xlsx reader
PRO .package_read_xlsx_clob
-- @../plsql/package_read_xlsx_clob.pks
CREATE OR REPLACE PACKAGE "AS_READ_XLSX_CLOB"
is
/**********************************************
**
** Author: Anton Scheffer
** Date: 19-01-2013
** Website: http://technology.amis.nl/blog
**
** Changelog:
** 18-02-2013 - Ralph Bieber
                Handle cell type "str" to prevent ORA-06502
                if cell content is a string calculated by formula,
                then cell type is "str" instead of "s" and value is inside <v> tag
** 19-02-2013 - Ralph Bieber
                Add column formula in tp_one_cell record, to show, if value is calculated by formula
** 20-02-2013 - Anton Scheffer
                Handle cell types 'inlineStr' and 'e' to prevent ORA-06502
** 19-03-2013 - Anton Scheffer
                Support for formatted and empty strings
                Handle columns per row to prevent ORA-31186: Document contains too many nodes
** 12-06-2013 - Anton Scheffer
                Handle sharedStrings.xml on older Oracle database versions
** 18-09-2013 - Anton Scheffer
                Fix for LPX-00200 could not convert from encoding UTF-8 to ...
                (Note, this is an error I can't reproduce myself, maybe depending on database version and characterset)
                Thank you Stanislav Safonov for this solution
                Handle numbers with scientific notation
** 20-01-2014 - Anton Scheffer
                Fix for a large number (60000+) of strings
** 16-05-2014 - Anton Scheffer
                round to 15 digits
** 10-08-2015 - Karen cannell
                Mod to allow CLOBs for cells where content > 4000 char. Use

******************************************************************************
******************************************************************************
Copyright (C) 2013 by Anton Scheffer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

******************************************************************************
*************************************************************************** */
/*
**
** Some examples
**
--
-- every sheet and every cell
    select *
    from table( as_read_xlsx.read( as_read_xlsx.file2blob( 'DOC', 'Book1.xlsx' ) ) )
--
-- cell A3 from the first and the second sheet
    select *
    from table( as_read_xlsx.read( as_read_xlsx.file2blob( 'DOC', 'Book1.xlsx' ), '1:2', 'A3' ) )
--
-- every cell from the sheet with the name "Sheet3"
    select *
    from table( as_read_xlsx.read( as_read_xlsx.file2blob( 'DOC', 'Book1.xlsx' ), 'Sheet3' ) )
--
*/
  type tp_one_cell is record
    ( sheet_nr number(2)
    , sheet_name varchar(4000)
    , row_nr number(10)
    , col_nr number(10)
    , cell varchar2(100)
    , cell_type VARCHAR2(1)
    , string_val clob        --KC: was --varchar2(4000)
    , number_val number
    , date_val date
    , formula varchar2(4000)
  );
  type tp_all_cells is table of tp_one_cell;
--
  function read( p_xlsx blob, p_sheets varchar2 := null, p_cell varchar2 := null )
  return tp_all_cells pipelined;
--
  function file2blob
    ( p_dir varchar2
    , p_file_name varchar2
    )
  return blob;
--
end as_read_xlsx_clob;
/
PRO .ks_log
-- @../plsql/ks_log.pls
create or replace package ks_log
is

--------------------------------------------------------------------------------
--*
--*
--*
--------------------------------------------------------------------------------

subtype scope is varchar2(61);
-- logger_logs.scope%type

--------------------------------------------------------------------------------
procedure log(p_msg  in varchar2, p_scope  in varchar2);

procedure log_error(p_msg  in varchar2, p_scope  in varchar2);


end ks_log;
/
PRO .ks_user_dml
-- @../plsql/ks_user_dml.pls
-- table API for application ks_user_dml, generated 13-OCT-2017
-- package specification
-- 
   
create or replace package ks_user_dml is

--------------------------------------------------------------
-- create procedure for table KS_USERS

   procedure INS_KS_USERS (
      P_ID         in out number,
      P_USERNAME   in varchar2,
      P_PASSWORD   in varchar2                        default null,
      P_FIRST_NAME in varchar2                        default null,
      P_LAST_NAME  in varchar2                        default null,
      P_EMAIL      in varchar2                        default null,
      P_ACTIVE_IND in varchar2,
      P_ADMIN_IND  in varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY in varchar2                        default null,
      P_CREATED_ON in date                            default null,
      P_UPDATED_BY in varchar2                        default null,
      P_UPDATED_ON in date                            default null
   );


--------------------------------------------------------------
-- update procedure for table KS_USERS

   procedure UPD_KS_USERS (
      P_ID in number,
      P_USERNAME   in varchar2,
      P_PASSWORD   in varchar2                        default null,
      P_FIRST_NAME in varchar2                        default null,
      P_LAST_NAME  in varchar2                        default null,
      P_EMAIL      in varchar2                        default null,
      P_ACTIVE_IND in varchar2,
      P_ADMIN_IND  in varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY in varchar2                        default null,
      P_CREATED_ON in date                            default null,
      P_UPDATED_BY in varchar2                        default null,
      P_UPDATED_ON in date                            default null,
      P_MD5        in varchar2                        default null
   );


--------------------------------------------------------------
-- delete procedure for table KS_USERS

   procedure DEL_KS_USERS (
      P_ID in number
   );

--------------------------------------------------------------
-- get procedure for table KS_USERS

   procedure GET_KS_USERS (
      P_ID in number,
      P_USERNAME   out varchar2,
      P_PASSWORD   out varchar2,
      P_FIRST_NAME out varchar2,
      P_LAST_NAME  out varchar2,
      P_EMAIL      out varchar2,
      P_ACTIVE_IND out varchar2,
      P_ADMIN_IND  out varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY out varchar2,
      P_CREATED_ON out date,
      P_UPDATED_BY out varchar2,
      P_UPDATED_ON out date
   );

--------------------------------------------------------------
-- get procedure for table KS_USERS

   procedure GET_KS_USERS (
      P_ID in number,
      P_USERNAME   out varchar2,
      P_PASSWORD   out varchar2,
      P_FIRST_NAME out varchar2,
      P_LAST_NAME  out varchar2,
      P_EMAIL      out varchar2,
      P_ACTIVE_IND out varchar2,
      P_ADMIN_IND  out varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY out varchar2,
      P_CREATED_ON out date,
      P_UPDATED_BY out varchar2,
      P_UPDATED_ON out date,
      P_MD5        out varchar2
   );

--------------------------------------------------------------
-- build MD5 function for table KS_USERS

   function BUILD_KS_USERS_MD5 (
      P_ID in number,
      P_USERNAME   in varchar2,
      P_PASSWORD   in varchar2                        default null,
      P_FIRST_NAME in varchar2                        default null,
      P_LAST_NAME  in varchar2                        default null,
      P_EMAIL      in varchar2                        default null,
      P_ACTIVE_IND in varchar2,
      P_ADMIN_IND  in varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY in varchar2                        default null,
      P_CREATED_ON in date                            default null,
      P_UPDATED_BY in varchar2                        default null,
      P_UPDATED_ON in date                            default null
   ) return varchar2;
 
end ks_user_dml;
/
PRO .ks_util
-- @../plsql/ks_util.pls
create or replace package ks_util
as

type gc_clob_arr_type is table of clob;

--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2;

--------------------------------------------------------------------------------
procedure set_param(
    p_name_key  in ks_parameters.name_key%TYPE
  , p_value     in ks_parameters.value%TYPE
);


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2;


--------------------------------------------------------------------------------
function format_full_name
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2;


--------------------------------------------------------------------------------
function is_number
(
  p_value        in         varchar2
) return boolean;

--------------------------------------------------------------------------------
function string_to_coll (p_string in varchar2) return sys.ODCIVarchar2List;

--------------------------------------------------------------------------------
function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         )
  return varchar2;

--------------------------------------------------------------------------------
function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report;


---------------------------------------------------------------------------------
function blob2clob(
  p_blob in blob,
  p_blob_csid in integer default dbms_lob.default_csid)
  return clob;

function replace_tokens (p_string in varchar2,
                         p_tokens in varchar2,
                         p_token_exceptions in varchar2)
 return varchar2;

function clob_to_varchar2_table (p_clob in out nocopy clob)
  return gc_clob_arr_type;


end ks_util;



/
PRO .ks_session_load_api
-- @../plsql/ks_session_load_api.pls
create or replace package ks_session_load_api
is

--------------------------------------------------------------------------------
--*
--*
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


procedure load_xlsx_data(
            p_xlsx in blob,
            p_app_user in varchar2
);

function validate_data(
             p_into_event_id in ks_event_tracks.event_id%TYPE
  ) return boolean;

procedure purge_event(
	p_event_id			in ks_sessions.event_id%TYPE
  , p_track_id			in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind	in varchar2
  , p_force_ind			in varchar2
);

end ks_session_load_api;
/
PRO .ks_users_api
-- @../plsql/ks_users_api.pls
create or replace package ks_users_api
as

--------------------------------------------------------------------------------
--*
--* Recieves the User information (Existing User, First Name, Last Name,
--* Email, Password, Is Admin) and Event / Track information (Event Id,
--* Track Id, Selection and Voting Role) and inserts this data into the
--* user table (ks_user) and/or relational table (ks_user_event_track_roles).
--*
--------------------------------------------------------------------------------
procedure set_user_information (
	p_existing_user    in   ks_users.username%TYPE,
	p_first_name       in   ks_users.first_name%TYPE,
	p_last_name        in   ks_users.last_name%TYPE,
	p_email            in   ks_users.email%TYPE,
	p_password         in   ks_users.password%TYPE,
	p_is_admin         in   ks_users.admin_ind%TYPE,
	p_event_id         in   ks_event_tracks.event_id%TYPE,
	p_track_id         in   ks_event_tracks.id%TYPE,
	p_selection_code   in   ks_roles.code%TYPE,
	p_voting_code      in   ks_roles.code%TYPE,
	p_external_sys_ref in   ks_users.external_sys_ref%TYPE
);

end ks_users_api;
/
PRO .ks_session_api
-- @../plsql/ks_session_api.pls
create or replace package ks_session_api
is

--------------------------------------------------------------------------------
--*
--* 
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter in ks_sessions.presenter%TYPE);
  
procedure switch_votes (
	p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username 	  in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
);


function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N')
  return varchar2;
  
end ks_session_api;
/
PRO .ks_user_event_track_roles_dml
-- @../plsql/ks_user_event_track_roles_dml.pls
create or replace package KS_USER_EVENT_TRACK_ROLES_DML is 
 
-------------------------------------------------------------- 
-- create procedure for table "KS_USER_EVENT_TRACK_ROLES" 
 
   procedure INS_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID                  in out number, 
      P_USERNAME            in varchar2, 
      P_EVENT_TRACK_ID      in number, 
      P_SELECTION_ROLE_CODE in varchar2                        default null, 
      P_VOTING_ROLE_CODE    in varchar2                        default null, 
      P_CREATED_BY          in varchar2                        default null, 
      P_CREATED_ON          in date                            default null, 
      P_UPDATED_BY          in varchar2                        default null, 
      P_UPDATED_ON          in date                            default null 
   ); 
 
 
-------------------------------------------------------------- 
-- update procedure for table "KS_USER_EVENT_TRACK_ROLES" 
 
   procedure UPD_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID				    in number, 
      P_USERNAME            in varchar2, 
      P_EVENT_TRACK_ID      in number, 
      P_SELECTION_ROLE_CODE in varchar2                        default null, 
      P_VOTING_ROLE_CODE    in varchar2                        default null, 
      P_CREATED_BY          in varchar2                        default null, 
      P_CREATED_ON          in date                            default null, 
      P_UPDATED_BY          in varchar2                        default null, 
      P_UPDATED_ON          in date                            default null, 
      P_MD5                 in varchar2                        default null 
   ); 
 
 
-------------------------------------------------------------- 
-- delete procedure for table "KS_USER_EVENT_TRACK_ROLES" 
 
   procedure DEL_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID in number 
   ); 
 
-------------------------------------------------------------- 
-- get procedure for table "KS_USER_EVENT_TRACK_ROLES" 
 
   procedure GET_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID 					in number, 
      P_USERNAME            out varchar2, 
      P_EVENT_TRACK_ID      out number, 
      P_SELECTION_ROLE_CODE out varchar2, 
      P_VOTING_ROLE_CODE    out varchar2, 
      P_CREATED_BY          out varchar2, 
      P_CREATED_ON          out date, 
      P_UPDATED_BY          out varchar2, 
      P_UPDATED_ON          out date 
   ); 
 
-------------------------------------------------------------- 
-- get procedure for table "KS_USER_EVENT_TRACK_ROLES" 
 
   procedure GET_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID 					in number, 
      P_USERNAME            out varchar2, 
      P_EVENT_TRACK_ID      out number, 
      P_SELECTION_ROLE_CODE out varchar2, 
      P_VOTING_ROLE_CODE    out varchar2, 
      P_CREATED_BY          out varchar2, 
      P_CREATED_ON          out date, 
      P_UPDATED_BY          out varchar2, 
      P_UPDATED_ON          out date, 
      P_MD5                 out varchar2 
   ); 
 
-------------------------------------------------------------- 
-- build MD5 function for table "KS_USER_EVENT_TRACK_ROLES" 
 
   function BUILD_KS_USR_EVNT_TRCK_RLE_MD5 ( 
      P_ID in number, 
      P_USERNAME            in varchar2, 
      P_EVENT_TRACK_ID      in number, 
      P_SELECTION_ROLE_CODE in varchar2                        default null, 
      P_VOTING_ROLE_CODE    in varchar2                        default null, 
      P_CREATED_BY          in varchar2                        default null, 
      P_CREATED_ON          in date                            default null, 
      P_UPDATED_BY          in varchar2                        default null, 
      P_UPDATED_ON          in date                            default null 
   ) return varchar2; 
  
end KS_USER_EVENT_TRACK_ROLES_DML;
/
PRO .Body
PRO .ks_log
-- @../plsql/ks_log.plb
alter session set PLSQL_CCFLAGS='LOGGER:FALSE';
create or replace package body ks_log
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';



------------------------------------------------------------------------------
/**
 * Description
 *
 *
 * @example
 *
 * @issue
 *
 * @author Jorge Rimblas
 * @created October 11, 2017
 * @param
 * @return
 */
procedure log(p_msg in varchar2, p_scope  in varchar2)
is
begin

  $IF $$LOGGER $THEN
  logger.log(p_msg, p_scope);
  $ELSE
  apex_debug.message(p_msg);
  $END

end log;


procedure log_error(p_msg in varchar2, p_scope  in varchar2)
is
begin

  $IF $$LOGGER $THEN
  logger.log_error(p_msg, p_scope);
  $ELSE
  apex_debug.message(p_msg);
  $END

end log_error;




end ks_log;
/
PRO ks_user_dml
-- @../plsql/ks_user_dml.plb
-- table API for application KS_USER_DML, generated 13-OCT-2017
-- package body
-- 
   
create or replace package body ks_user_dml is

--------------------------------------------------------------
-- create procedure for table KS_USERS

   procedure INS_KS_USERS (
      P_ID         in out number,
      P_USERNAME   in varchar2,
      P_PASSWORD   in varchar2                        default null,
      P_FIRST_NAME in varchar2                        default null,
      P_LAST_NAME  in varchar2                        default null,
      P_EMAIL      in varchar2                        default null,
      P_ACTIVE_IND in varchar2,
      P_ADMIN_IND  in varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY in varchar2                        default null,
      P_CREATED_ON in date                            default null,
      P_UPDATED_BY in varchar2                        default null,
      P_UPDATED_ON in date                            default null
   ) is 
 
   begin
 
      insert into KS_USERS (
         -- ID,
         USERNAME,
         PASSWORD,
         FIRST_NAME,
         LAST_NAME,
         EMAIL,
         ACTIVE_IND,
         ADMIN_IND,
		 EXTERNAL_SYS_REF
         --CREATED_BY,
         --CREATED_ON,
         --UPDATED_BY,
         --UPDATED_ON
      ) values ( 
         -- P_ID,
         P_USERNAME,
         P_PASSWORD,
         P_FIRST_NAME,
         P_LAST_NAME,
         P_EMAIL,
         P_ACTIVE_IND,
         P_ADMIN_IND,
		 P_EXTERNAL_SYS_REF
         --P_CREATED_BY,
         --P_CREATED_ON,
         --P_UPDATED_BY,
         --P_UPDATED_ON
      )
      returning id into p_id;
 
   end INS_KS_USERS;


--------------------------------------------------------------
-- update procedure for table KS_USERS

   procedure UPD_KS_USERS (
      P_ID in number,
      P_USERNAME   in varchar2,
      P_PASSWORD   in varchar2                        default null,
      P_FIRST_NAME in varchar2                        default null,
      P_LAST_NAME  in varchar2                        default null,
      P_EMAIL      in varchar2                        default null,
      P_ACTIVE_IND in varchar2,
      P_ADMIN_IND  in varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY in varchar2                        default null,
      P_CREATED_ON in date                            default null,
      P_UPDATED_BY in varchar2                        default null,
      P_UPDATED_ON in date                            default null,
      P_MD5        in varchar2                        default null
   ) is 
 
      L_MD5 varchar2(32767) := null;
 
   begin
 
      if P_MD5 is not null then
         for c1 in (
            select * from KS_USERS 
            where ID = P_ID FOR UPDATE
         ) loop
 
            L_MD5 := BUILD_KS_USERS_MD5(
               c1.ID,
               c1.USERNAME,
               c1.PASSWORD,
               c1.FIRST_NAME,
               c1.LAST_NAME,
               c1.EMAIL,
               c1.ACTIVE_IND,
               c1.ADMIN_IND,
			   c1.EXTERNAL_SYS_REF,
               c1.CREATED_BY,
               c1.CREATED_ON,
               c1.UPDATED_BY,
               c1.UPDATED_ON
            );
 
         end loop;
 
      end if;
 
      if (P_MD5 is null) or (L_MD5 = P_MD5) then 
         update KS_USERS set
            ID           = P_ID,
            USERNAME     = P_USERNAME,
            PASSWORD     = P_PASSWORD,
            FIRST_NAME   = P_FIRST_NAME,
            LAST_NAME    = P_LAST_NAME,
            EMAIL        = P_EMAIL,
            ACTIVE_IND   = P_ACTIVE_IND,
            ADMIN_IND    = P_ADMIN_IND,
			EXTERNAL_SYS_REF = P_EXTERNAL_SYS_REF,
            CREATED_BY   = P_CREATED_BY,
            CREATED_ON   = P_CREATED_ON,
            UPDATED_BY   = P_UPDATED_BY,
            UPDATED_ON   = P_UPDATED_ON
         where ID = P_ID;
      else
         raise_application_error (-20001,'Current version of data in database has changed since user initiated update process. current checksum = '||L_MD5||', item checksum = '||P_MD5||'.');  
      end if;
 
   end UPD_KS_USERS;


--------------------------------------------------------------
-- delete procedure for table KS_USERS

   procedure DEL_KS_USERS (
      P_ID in number
   ) is 
 
   begin
 
      delete from KS_USERS 
      where ID = P_ID;
 
   end DEL_KS_USERS;

--------------------------------------------------------------
-- get procedure for table KS_USERS

   procedure GET_KS_USERS (
      P_ID in number,
      P_USERNAME   out varchar2,
      P_PASSWORD   out varchar2,
      P_FIRST_NAME out varchar2,
      P_LAST_NAME  out varchar2,
      P_EMAIL      out varchar2,
      P_ACTIVE_IND out varchar2,
      P_ADMIN_IND  out varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY out varchar2,
      P_CREATED_ON out date,
      P_UPDATED_BY out varchar2,
      P_UPDATED_ON out date
   ) is 
 
      ignore varchar2(32676);
   begin
 
      GET_KS_USERS (
         P_ID,
         P_USERNAME,
         P_PASSWORD,
         P_FIRST_NAME,
         P_LAST_NAME,
         P_EMAIL,
         P_ACTIVE_IND,
         P_ADMIN_IND,
		 P_EXTERNAL_SYS_REF,
         P_CREATED_BY,
         P_CREATED_ON,
         P_UPDATED_BY,
         P_UPDATED_ON,
         ignore
      );
 
   end GET_KS_USERS;

--------------------------------------------------------------
-- get procedure for table KS_USERS

   procedure GET_KS_USERS (
      P_ID in number,
      P_USERNAME   out varchar2,
      P_PASSWORD   out varchar2,
      P_FIRST_NAME out varchar2,
      P_LAST_NAME  out varchar2,
      P_EMAIL      out varchar2,
      P_ACTIVE_IND out varchar2,
      P_ADMIN_IND  out varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY out varchar2,
      P_CREATED_ON out date,
      P_UPDATED_BY out varchar2,
      P_UPDATED_ON out date,
      P_MD5        out varchar2
   ) is 
 
   begin
 
      for c1 in (
         select * from KS_USERS 
         where ID = P_ID 
      ) loop
         P_USERNAME   := c1.USERNAME;
         P_PASSWORD   := c1.PASSWORD;
         P_FIRST_NAME := c1.FIRST_NAME;
         P_LAST_NAME  := c1.LAST_NAME;
         P_EMAIL      := c1.EMAIL;
         P_ACTIVE_IND := c1.ACTIVE_IND;
         P_ADMIN_IND  := c1.ADMIN_IND;
         P_CREATED_BY := c1.CREATED_BY;
         P_CREATED_ON := c1.CREATED_ON;
         P_UPDATED_BY := c1.UPDATED_BY;
         P_UPDATED_ON := c1.UPDATED_ON;
 
         P_MD5 := BUILD_KS_USERS_MD5(
            c1.ID,
            c1.USERNAME,
            c1.PASSWORD,
            c1.FIRST_NAME,
            c1.LAST_NAME,
            c1.EMAIL,
            c1.ACTIVE_IND,
            c1.ADMIN_IND,
			c1.EXTERNAL_SYS_REF,
            c1.CREATED_BY,
            c1.CREATED_ON,
            c1.UPDATED_BY,
            c1.UPDATED_ON
         );
      end loop;
 
   end GET_KS_USERS;

--------------------------------------------------------------
-- build MD5 function for table KS_USERS

   function BUILD_KS_USERS_MD5 (
      P_ID in number,
      P_USERNAME   in varchar2,
      P_PASSWORD   in varchar2                        default null,
      P_FIRST_NAME in varchar2                        default null,
      P_LAST_NAME  in varchar2                        default null,
      P_EMAIL      in varchar2                        default null,
      P_ACTIVE_IND in varchar2,
      P_ADMIN_IND  in varchar2,
	  P_EXTERNAL_SYS_REF in varchar2,
      P_CREATED_BY in varchar2                        default null,
      P_CREATED_ON in date                            default null,
      P_UPDATED_BY in varchar2                        default null,
      P_UPDATED_ON in date                            default null
   ) return varchar2 is 
 
   begin
 
      return apex_util.get_hash(apex_t_varchar2(
         P_USERNAME,
         P_PASSWORD,
         P_FIRST_NAME,
         P_LAST_NAME,
         P_EMAIL,
         P_ACTIVE_IND,
         P_ADMIN_IND,
		 P_EXTERNAL_SYS_REF,
         P_CREATED_BY,
         to_char(P_CREATED_ON,'yyyymmddhh24:mi:ss'),
         P_UPDATED_BY,
         to_char(P_UPDATED_ON,'yyyymmddhh24:mi:ss') ));
 
   end BUILD_KS_USERS_MD5;
 
end ks_user_dml;
/
PRO package_read_xlsx_clob
-- @../plsql/package_read_xlsx_clob.pkb

CREATE OR REPLACE PACKAGE BODY       "AS_READ_XLSX_CLOB" 
is
--
  function read( p_xlsx blob, p_sheets varchar2 := null, p_cell varchar2 := null )
  return tp_all_cells pipelined
  is
    t_date1904 boolean;
    type tp_date is table of boolean index by pls_integer;
    t_xf_date tp_date;
    t_numfmt_date tp_date;
    type tp_strings is table of varchar2(32767) index by pls_integer;
    t_strings tp_strings;
    t_sheet_ids tp_strings;
    t_sheet_names tp_strings;
    t_r varchar2(32767);
    t_s varchar2(32767);
    t_val varchar2(32767);
    t_t varchar2(400);
    t_nr number;
    t_c pls_integer;
    t_x pls_integer;
    t_xx pls_integer;
    t_ns varchar2(200) := 'xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"';
    t_nd dbms_xmldom.domnode;
    t_nd2 dbms_xmldom.domnode;
    t_nl dbms_xmldom.domnodelist;
    t_nl2 dbms_xmldom.domnodelist;
    t_nl3 dbms_xmldom.domnodelist;
    t_one_cell tp_one_cell;
--
    function blob2node( p_blob blob )
    return dbms_xmldom.domnode
    is
    begin
      if p_blob is null or dbms_lob.getlength( p_blob ) = 0
      then
        return null;
      end if;
      return dbms_xmldom.makenode( dbms_xmldom.getdocumentelement( dbms_xmldom.newdomdocument( xmltype( p_blob, nls_charset_id( 'AL32UTF8' ) ) ) ) );
    exception
      when others
      then
        declare
          t_nd dbms_xmldom.domnode;
          t_clob         clob;
          t_dest_offset  integer;
          t_src_offset   integer;
          t_lang_context number := dbms_lob.default_lang_ctx;
          t_warning      integer;
        begin
          dbms_lob.createtemporary( t_clob, true );
          t_dest_offset := 1;
          t_src_offset  := 1;
          dbms_lob.converttoclob( t_clob
                                , p_blob
                                , dbms_lob.lobmaxsize
                                , t_dest_offset
                                , t_src_offset
                                , nls_charset_id('AL32UTF8')
                                , t_lang_context
                                , t_warning
                                );
          t_nd := dbms_xmldom.makenode( dbms_xmldom.getdocumentelement( dbms_xmldom.newdomdocument( t_clob ) ) );
          dbms_lob.freetemporary( t_clob );
          return t_nd;
      end;
    end;
--
    function blob2num( p_blob blob, p_len integer, p_pos integer )
    return number
    is
    begin
      return utl_raw.cast_to_binary_integer( dbms_lob.substr( p_blob, p_len, p_pos ), utl_raw.little_endian );
    end;
--
    function little_endian( p_big number, p_bytes pls_integer := 4 )
    return raw
    is
    begin
      return utl_raw.substr( utl_raw.cast_from_binary_integer( p_big, utl_raw.little_endian ), 1, p_bytes );
    end;
--
    function col_alfan( p_col varchar2 )
    return pls_integer
    is
    begin
      return ascii( substr( p_col, -1 ) ) - 64
           + nvl( ( ascii( substr( p_col, -2, 1 ) ) - 64 ) * 26, 0 )
           + nvl( ( ascii( substr( p_col, -3, 1 ) ) - 64 ) * 676, 0 );
    end;
--
    function get_file
      ( p_zipped_blob blob
      , p_file_name varchar2
      )
    return blob
    is
      t_tmp blob;
      t_ind integer;
      t_hd_ind integer;
      t_fl_ind integer;
      t_encoding varchar2(10);
      t_len integer;
    begin
      t_ind := dbms_lob.getlength( p_zipped_blob ) - 21;
      loop
        exit when t_ind < 1 or dbms_lob.substr( p_zipped_blob, 4, t_ind ) = hextoraw( '504B0506' ); -- End of central directory signature
        t_ind := t_ind - 1;
      end loop;
--
      if t_ind <= 0
      then
        return null;
      end if;
--
      t_hd_ind := blob2num( p_zipped_blob, 4, t_ind + 16 ) + 1;
      for i in 1 .. blob2num( p_zipped_blob, 2, t_ind + 8 )
      loop
        if utl_raw.bit_and( dbms_lob.substr( p_zipped_blob, 1, t_hd_ind + 9 ), hextoraw( '08' ) ) = hextoraw( '08' )
        then
          t_encoding := 'AL32UTF8'; -- utf8
        else
          t_encoding := 'US8PC437'; -- IBM codepage 437
        end if;
        if p_file_name = utl_i18n.raw_to_char
                           ( dbms_lob.substr( p_zipped_blob
                                            , blob2num( p_zipped_blob, 2, t_hd_ind + 28 )
                                            , t_hd_ind + 46
                                            )
                           , t_encoding
                           )
        then
          t_len := blob2num( p_zipped_blob, 4, t_hd_ind + 24 ); -- uncompressed length
          if t_len = 0
          then
            if substr( p_file_name, -1 ) in ( '/', '\' )
            then  -- directory/folder
              return null;
            else -- empty file
              return empty_blob();
            end if;
          end if;
--
          if dbms_lob.substr( p_zipped_blob, 2, t_hd_ind + 10 ) = hextoraw( '0800' ) -- deflate
          then
            t_fl_ind := blob2num( p_zipped_blob, 4, t_hd_ind + 42 );
            t_tmp := hextoraw( '1F8B0800000000000003' ); -- gzip header
            dbms_lob.copy( t_tmp
                         , p_zipped_blob
                         ,  blob2num( p_zipped_blob, 4, t_hd_ind + 20 )
                         , 11
                         , t_fl_ind + 31
                         + blob2num( p_zipped_blob, 2, t_fl_ind + 27 ) -- File name length
                         + blob2num( p_zipped_blob, 2, t_fl_ind + 29 ) -- Extra field length
                         );
            dbms_lob.append( t_tmp, utl_raw.concat( dbms_lob.substr( p_zipped_blob, 4, t_hd_ind + 16 ) -- CRC32
                                                  , little_endian( t_len ) -- uncompressed length
                                                  )
                           );
            return utl_compress.lz_uncompress( t_tmp );
          end if;
--
          if dbms_lob.substr( p_zipped_blob, 2, t_hd_ind + 10 ) = hextoraw( '0000' ) -- The file is stored (no compression)
          then
            t_fl_ind := blob2num( p_zipped_blob, 4, t_hd_ind + 42 );
            dbms_lob.createtemporary( t_tmp, true );
            dbms_lob.copy( t_tmp
                         , p_zipped_blob
                         , t_len
                         , 1
                         , t_fl_ind + 31
                         + blob2num( p_zipped_blob, 2, t_fl_ind + 27 ) -- File name length
                         + blob2num( p_zipped_blob, 2, t_fl_ind + 29 ) -- Extra field length
                         );
            return t_tmp;
          end if;
        end if;
        t_hd_ind := t_hd_ind + 46
                  + blob2num( p_zipped_blob, 2, t_hd_ind + 28 )  -- File name length
                  + blob2num( p_zipped_blob, 2, t_hd_ind + 30 )  -- Extra field length
                  + blob2num( p_zipped_blob, 2, t_hd_ind + 32 ); -- File comment length
      end loop;
--
      return null;
    end;
--
  begin
    t_one_cell.cell_type := 'S';
    t_one_cell.sheet_name := 'This doesn''t look like an Excel (xlsx) file to me!';
    t_one_cell.string_val := t_one_cell.sheet_name;
    if dbms_lob.substr( p_xlsx, 4, 1 ) != hextoraw( '504B0304' )
    then
      pipe row( t_one_cell );
      return;
    end if;
    t_nd := blob2node( get_file( p_xlsx, 'xl/workbook.xml' ) );
    if dbms_xmldom.isnull( t_nd )
    then
      pipe row( t_one_cell );
      return;
    end if;
    t_date1904 := lower( dbms_xslprocessor.valueof( t_nd, '/workbook/workbookPr/@date1904', t_ns ) ) in ( 'true', '1' );
    t_nl := dbms_xslprocessor.selectnodes( t_nd, '/workbook/sheets/sheet', t_ns );
    for i in 0 .. dbms_xmldom.getlength( t_nl ) - 1
    loop
      t_sheet_ids( i + 1 ) := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '@r:id', 'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"' );
      t_sheet_names( i + 1 ) := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '@name' );
    end loop;
    t_nd := blob2node( get_file( p_xlsx, 'xl/styles.xml' ) );
    t_nl := dbms_xslprocessor.selectnodes( t_nd, '/styleSheet/numFmts/numFmt', t_ns );
    for i in 0 .. dbms_xmldom.getlength( t_nl ) - 1
    loop
      t_val := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '@formatCode' );
      if (  instr( t_val, 'dd' ) > 0
         or instr( t_val, 'mm' ) > 0
         or instr( t_val, 'yy' ) > 0
         )
      then
        t_numfmt_date( dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '@numFmtId' ) ) := true;
      end if;
    end loop;
    t_numfmt_date( 14 ) := true;
    t_numfmt_date( 15 ) := true;
    t_numfmt_date( 16 ) := true;
    t_numfmt_date( 17 ) := true;
    t_numfmt_date( 22 ) := true;
    t_nl := dbms_xslprocessor.selectnodes( t_nd, '/styleSheet/cellXfs/xf/@numFmtId', t_ns );
    for i in 0 .. dbms_xmldom.getlength( t_nl ) - 1
    loop
      t_xf_date( i ) := t_numfmt_date.exists( dbms_xmldom.getnodevalue( dbms_xmldom.item( t_nl, i ) ) );
    end loop;
    t_nd := blob2node( get_file( p_xlsx, 'xl/sharedStrings.xml' ) );
    if not dbms_xmldom.isnull( t_nd )
    then
      t_x := 0;
      t_xx := 5000;
      loop
        t_nl := dbms_xslprocessor.selectnodes( t_nd, '/sst/si[position()>="' || to_char( t_x * t_xx + 1 ) || '" and position()<=" ' || to_char( ( t_x + 1 ) * t_xx ) || '"]', t_ns );
        exit when dbms_xmldom.getlength( t_nl ) = 0;
        t_x := t_x + 1;
        for i in 0 .. dbms_xmldom.getlength( t_nl ) - 1
        loop
          t_c := t_strings.count;
         ---------kc:  use proc instead   t_strings( t_c ) := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '.' );
          dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '.', t_strings( t_c ) );
          if t_strings( t_c ) is null
          then
          ------kc:   use proc instead  t_strings( t_c ) := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '*/text()' );   --******************************* this is the line that fails
            dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '*/text()',  t_strings( t_c ) );
            if t_strings( t_c ) is null
            then
              t_nl2 := dbms_xslprocessor.selectnodes( dbms_xmldom.item( t_nl, i ), 'r/t/text()' );
              for j in 0 .. dbms_xmldom.getlength( t_nl2 ) - 1
              loop
                t_strings( t_c ) := t_strings( t_c ) || dbms_xmldom.getnodevalue( dbms_xmldom.item( t_nl2, j ) );
              end loop;
            end if;
          end if;
        end loop;
      end loop;
    end if;
    t_nd2 := blob2node( get_file( p_xlsx, 'xl/_rels/workbook.xml.rels' ) );
    for i in 1 .. t_sheet_ids.count
    loop
      if ( p_sheets is null
         or instr( ':' || p_sheets || ':', ':' || to_char( i ) || ':' ) > 0
         or instr( ':' || p_sheets || ':', ':' || t_sheet_names( i ) || ':' ) > 0
         )
      then
        t_val := dbms_xslprocessor.valueof( t_nd2, '/Relationships/Relationship[@Id="' || t_sheet_ids( i ) || '"]/@Target', 'xmlns="http://schemas.openxmlformats.org/package/2006/relationships"' );
        t_one_cell.sheet_nr := i;
        t_one_cell.sheet_name := t_sheet_names( i );
        t_nd := blob2node( get_file( p_xlsx, 'xl/' || t_val ) );
        t_nl3 := dbms_xslprocessor.selectnodes( t_nd, '/worksheet/sheetData/row' );
        for r in 0 .. dbms_xmldom.getlength( t_nl3 ) - 1
        loop
          t_nl2 := dbms_xslprocessor.selectnodes( dbms_xmldom.item( t_nl3, r ), 'c' );
          for j in 0 .. dbms_xmldom.getlength( t_nl2 ) - 1
          loop
            t_one_cell.date_val := null;
            t_one_cell.number_val := null;
            t_one_cell.string_val := null;
            t_r := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), '@r', t_ns );
            t_val := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), 'v' );
            -- see Changelog 2013-02-19 formula column
            t_one_cell.formula := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), 'f' );
            -- see Changelog 2013-02-18 type='str'
            t_t := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), '@t' );
            if t_t in ( 'str', 'inlineStr', 'e' )
            then
              t_one_cell.cell_type := 'S';
              t_one_cell.string_val := t_val;
            elsif t_t = 's'
            then
              t_one_cell.cell_type := 'S';
              if t_val is not null
              then
                t_one_cell.string_val := t_strings( to_number( t_val ) );  ----------------*************
              end if;
            else
              t_s := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), '@s' );
              t_nr := to_number( t_val
                               , case when instr( t_val, 'E' ) = 0
                                   then translate( t_val, '.012345678,-+', 'D999999999' )
                                   else translate( substr( t_val, 1, instr( t_val, 'E' ) - 1 ), '.012345678,-+', 'D999999999' ) || 'EEEE'
                                 end
                               , 'NLS_NUMERIC_CHARACTERS=.,'
                               );
              if t_s is not null and t_xf_date( to_number( t_s ) )
              then
                t_one_cell.cell_type := 'D';
                if t_date1904
                then
                  t_one_cell.date_val := to_date('01-01-1904','DD-MM-YYYY') + to_number( t_nr );
                else
                  t_one_cell.date_val := to_date('01-03-1900','DD-MM-YYYY') + ( to_number( t_nr ) - 61 );
                end if;
              else
                t_one_cell.cell_type := 'N';
                t_nr := round( t_nr, 14 - substr( to_char( t_nr, 'TME' ), -3 ) );
                t_one_cell.number_val := t_nr;
              end if;
            end if;
            t_one_cell.row_nr := ltrim( t_r, rtrim( t_r, '0123456789' ) );
            t_one_cell.col_nr := col_alfan( rtrim( t_r, '0123456789' ) );
            t_one_cell.cell := t_r;
            if p_cell is null or t_r = upper( p_cell )
            then
              pipe row( t_one_cell );
            end if;
          end loop;
        end loop;
      end if;
    end loop;
    return;
  end;
--
  function file2blob
    ( p_dir varchar2
    , p_file_name varchar2
    )
  return blob
  is
    file_lob bfile;
    file_blob blob;
  begin
    file_lob := bfilename( p_dir, p_file_name );
    dbms_lob.open( file_lob, dbms_lob.file_readonly );
    dbms_lob.createtemporary( file_blob, true );
    dbms_lob.loadfromfile( file_blob, file_lob, dbms_lob.lobmaxsize );
    dbms_lob.close( file_lob );
    return file_blob;
  exception
    when others then
      if dbms_lob.isopen( file_lob ) = 1
      then
        dbms_lob.close( file_lob );
      end if;
      if dbms_lob.istemporary( file_blob ) = 1
      then
        dbms_lob.freetemporary( file_blob );
      end if;
      raise;
  end;
--
END as_read_xlsx_clob;
/
PRO ks_util
-- @../plsql/ks_util.plb
create or replace package body ks_util
as

--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';


--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2
is
  l_value ks_parameters.value%TYPE;
begin

  select value
    into l_value
    from ks_parameters
   where name_key = p_name_key;

  return l_value;

exception
  when NO_DATA_FOUND then
    return null;

end get_param;



--------------------------------------------------------------------------------
procedure set_param(
    p_name_key      in ks_parameters.name_key%TYPE
  , p_value         in ks_parameters.value%TYPE
)
is
begin

  update ks_parameters
     set value = p_value
   where name_key = p_name_key;

  if sql%rowcount = 0 then
    raise_application_error(
        -20001
      , 'Parameter ' || p_name_key || ' does not exist.'
    );
  end if;

end set_param;


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2
is
  -- l_scope   logger_logs.scope%type := gc_scope_prefix || 'get_email';
  -- l_params  logger.tab_param;

  l_email ks_users.email%TYPE;
begin
  -- logger.append_param(l_params, 'p_username', p_username);
  -- logger.log('START', l_scope, null, l_params);

  select email
    into l_email
    from ks_users
   where username = p_username;

  return l_email;

exception
  when NO_DATA_FOUND then
    -- logger.log_error('Probably an invalid user.');
    return null;

end get_email;




function format_full_name
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2
IS
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'format_full_name';
  -- l_params logger.tab_param;
begin
--  logger.append_param(l_params, 'p_text', p_text);

  RETURN rtrim(p_first_name || ' ' || p_last_name);

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end format_full_name;






function is_number
(
  p_value        in         varchar2
) return boolean
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'is_number';
  -- l_params            logger.tab_param;

  non_numeric      exception;
  pragma exception_init (non_numeric, -06502);

  l_number     number;
begin
   l_number := p_value;

   return true;

exception
  when non_numeric then
    return false;
end is_number;





function string_to_coll (p_string in VARCHAR2) return sys.ODCIVarchar2List
is
  l_table wwv_flow_global.vc_arr2;
  l_list  sys.ODCIVarchar2List := new sys.ODCIVarchar2List();
begin
  l_table := apex_util.string_to_table(p_string);
  l_list.extend(l_table.count());
  for i in 1..l_table.count()
  loop
    l_list(i) := l_table(i);
  end loop;
  return l_list;
end string_to_coll;




function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         )
  return varchar2
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_order_by';
  -- l_params            logger.tab_param;

  l_order_by          varchar2(32000);
  l_instr             number;
begin
  -- logger.log('START', l_scope, null, l_params);

  l_instr := instr (p_ir_query, 'order by', -1);

  if l_instr > 0
  then
     -- grab the final order by from the IR query and trim off any trailing ")"
     l_order_by := rtrim (substr (p_ir_query, l_instr), ')');

  else -- add default order by for use by analytics lead/gag functions
    l_order_by := 'order by ' || p_default_pk; -- Use a column that's always present
  end if;

  -- logger.log('order by:' || l_order_by, l_scope, null, l_params);
  return l_order_by;

exception
  when others then
    null;
end get_ir_order_by;





function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_report';
  -- l_params            logger.tab_param;

  l_region_id          number;
begin
  -- logger.append_param(l_params, 'p_page_id', p_page_id);
  -- logger.append_param(l_params, 'p_static_id', p_static_id);
  -- logger.log('START', l_scope, null, l_params);

  select region_id
    into l_region_id
    from apex_application_page_regions
   where static_id = p_static_id
     and page_id   = p_page_id
     and application_id = (select v('APP_ID') from dual);

  return apex_ir.get_report
         (
            p_page_id   => p_page_id
          , p_region_id => l_region_id
         );

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end get_ir_report;


/**
  * Converts blob to clob
  *
  * Notes:
  *  - Copied from OOS Utils https://github.com/OraOpenSource/oos-utils/blob/master/source/packages/oos_util_lob.pkb
  *
  */
 function blob2clob(
   p_blob in blob,
   p_blob_csid in integer default dbms_lob.default_csid)
   return clob
 as
   l_clob clob;
   l_dest_offset integer := 1;
   l_src_offset integer := 1;
   l_lang_context integer := dbms_lob.default_lang_ctx;
   l_warning integer;
 begin
   if p_blob is null then
     return null;
   end if;

   dbms_lob.createtemporary(
     lob_loc => l_clob,
     cache => false);

   dbms_lob.converttoclob(
     dest_lob => l_clob,
     src_blob => p_blob,
     amount => dbms_lob.lobmaxsize,
     dest_offset => l_dest_offset,
     src_offset => l_src_offset,
     blob_csid => p_blob_csid,
     lang_context => l_lang_context,
     warning => l_warning);

   return l_clob;
 end blob2clob;



--==============================================================================
-- Function: clob_to_varchar2_table
-- Purpose: takes a clob and returns it as a table of varchar2s with size 4000
--
-- Inputs:  p_clob - the clob to be passed in
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:  Some of this code taken from https://stackoverflow.com/questions/11647041/reading-clob-line-by-line-with-pl-sql
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function clob_to_varchar2_table (p_clob in out nocopy clob)
  return gc_clob_arr_type
is
  l_scope varchar2(255) := 'clob_to_varchar2_table';
  l_varchar2s gc_clob_arr_type;
  l_varchar2 varchar2(4000);
  l_offset number := 1;
  l_amount number := 3000;
  len    number;
  i number := 1;
begin

  ks_log.log('START', l_scope);

  l_varchar2s := gc_clob_arr_type();

  if p_clob is null
  then
    return l_varchar2s;
  end if;

  if ( dbms_lob.isopen(p_clob) != 1 ) then
    dbms_lob.open(p_clob,0);
  end if;

  len := dbms_lob.getlength(p_clob);

  while(l_offset < len)
  loop
    apex_debug.message('inside main loop "while(l_offset < len)"');
    dbms_lob.read(p_clob, l_amount, l_offset, l_varchar2);
    l_offset := l_offset + l_amount;
    l_varchar2s.extend;
    apex_debug.message('len: ' || len || ', l_offset: ' || l_offset || ', l_varchar2: ' || l_varchar2);
    l_varchar2s(i) := l_varchar2;
    i := i + 1;
  end loop;

  if ( dbms_lob.isopen(p_clob) = 1 ) then
    dbms_lob.close(p_clob);
  end if;


  return l_varchar2s;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  clob_to_varchar2_table;


--==============================================================================
-- Function: tokenize_string
-- Purpose: helper function for html_whitelist_tokenize
--
-- Inputs:  p_string - the to have its tokens replaced
--          p_tokens - a string containing the tokens
-- Output:
-- Scope: Publicly accessible
-- Errors: logged and raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/27/2017
--==============================================================================
function replace_tokens (p_string in varchar2,
                         p_tokens in varchar2,
                         p_token_exceptions in varchar2)
 return varchar2
is
  l_scope varchar2(255) := 'tokenize_string';
  l_output varchar2(32767);
  l_tokens_table apex_application_global.vc_arr2;
  l_tokens varchar2(4000);
  found_match boolean := true;
  l_index number := -1;

  l_infinite_loop_check number := 0;
begin
  if trim(p_tokens) is null
  then
    return p_string;
  end if;

  --Cleanse p_tokens so that it only contains alphanumeric characters.
  --Get rid of all non-alphanumerics
  l_tokens := regexp_replace(p_tokens,'[^A-Za-z0-9]', ' ');
  --Remove from tokens the token exceptions
  l_tokens := regexp_replace(l_tokens,p_token_exceptions, '', 1, 0, 'i');
  --Get rid of all multiple spaces so that everything is only one space apart
  l_tokens := regexp_replace(l_tokens,'\s{2,}?', '');
  l_tokens := trim(l_tokens);
  --Replace spaces with |
  l_tokens := regexp_replace(l_tokens,'\s', '|');


  --I wanted to use something like the oneliner below, but pl/sql doesn't support lookaheads (yet)
  --l_output := regexp_replace(p_string, '(\W)('|| l_tokens || ')(?=\W)', '\1XXXX', 1, 0, 'i');

  l_output := p_string;
  while(l_index != 0)
  loop
    l_index  := regexp_instr(l_output, '(^|\W)('|| l_tokens || ')(\W|$)', 1, 1, 0, 'i');

    if(l_index != 0)
    then
      -- l_output := regexp_replace(l_output, '(^|\W)('|| l_tokens || ')(\W|$)', '\1XXXXX\3', l_index, 1, 'i');
      l_output := regexp_replace(l_output, '(^|\W)('|| l_tokens || ')(\W|$)', '\1\3', l_index, 1, 'i');

    end if;

    l_infinite_loop_check := l_infinite_loop_check + 1;
    if l_infinite_loop_check > 9999
    then
      --Something's gone wrong
      raise_application_error(-20001, 'Error Tokenizing Data');
    end if;

  end loop;

  apex_debug.message(l_output);
  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  replace_tokens;






end ks_util;
/
PRO ks_session_load_api
-- @../plsql/ks_session_load_api.plb
create or replace package body ks_session_load_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix: Standard logger package name
 * @constant gc_all_clob_columns: comma separeted list of columns that are clobs
 * @column_names_t: is the table type for columns taken from the export file.
 * @c_max_errors_to_display: the maximum number of errors to display to the user.
 * @index_map_t: maps column numbers from the export file to column names in ks_full_session_load
*/
gc_scope_prefix      constant varchar2(31) := lower($$PLSQL_UNIT) || '.';

gc_all_clob_columns  constant varchar2(4000) := 'SESSION_DESCRIPTION';

c_session_load_table constant varchar2(30) := 'KS_FULL_SESSION_LOAD';

c_max_errors_to_display constant number := 4;

type column_names_t is varray(4000) of varchar2(4000);

type index_map_t is table of varchar2(30) index by varchar2(10);



--==============================================================================
-- Function: add_error_check_continue
-- Purpose: Wrapper function for apex_error. It logs the error and if we've reached the threshold c_max_errors_to_display we return false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function add_error_check_continue (p_message in varchar2,
                                   p_display_location in varchar2)
  return boolean
is
  l_scope ks_log.scope := 'add_error_check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);

  apex_error.add_error(
            p_message => p_message
          , p_display_location => p_display_location
        );

  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end add_error_check_continue;

--==============================================================================
-- Function: add_error_check_continue
-- Purpose: Checks if we've reached the threshold c_max_errors_to_display. If so, then it returns false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function check_continue
  return boolean
is
  l_scope ks_log.scope := 'check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);


  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end check_continue;


--==============================================================================
-- Function: validate_column_names
-- Purpose: This makes sure that the first row of the .xlsx file contains row names FOR EACH column in ks_session_load (minus event_id, track_id, and app_user)
--
-- Inputs: l_column_names - varray of column names
-- Output: returns true if valid, false if invalid
-- Scope: Not  Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/09/2017
--==============================================================================
function validate_column_names (l_column_names in column_names_t)
return boolean
is
  l_scope ks_log.scope := 'validate_column_names';
  --l_params logger.tab_param;
  type column_names_dict_t is table of varchar2(20) index by varchar2(4000);
  l_column_names_dict column_names_dict_t;

  i number := 0;
  idx varchar2(4000);
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);


  for row in (select trim(upper(lm.header_name)) header
                from ks_load_mapping lm
                where 1=1
                  and table_name = c_session_load_table)
  loop
    l_column_names_dict(row.header) := 'not_matched';
  end loop;

  for i in 1..l_column_names.count
  loop
      if not l_column_names_dict.exists(trim(upper(l_column_names(i))))
      then
        if not add_error_check_continue(p_message => 'The column "' || l_column_names(i) || '" does not match any column names specified in the instructions.'
                                     ,  p_display_location => apex_error.c_inline_in_notification
                            )
        then
          return false;
        end if;
      else
        l_column_names_dict(trim(upper(l_column_names(i)))) := 'matched';
      end if;
  end loop;

  ks_log.log('trace before l_column_names_dict loop', l_scope);

  idx := l_column_names_dict.first;
  while idx is not null
  loop
    ks_log.log('trace inside l_column_names_dict loop', l_scope);
    if l_column_names_dict(idx) = 'not_matched'
    then
      if not add_error_check_continue(p_message => 'The column "' || initcap(idx) || '", was not found in the file. Please ensure this column exists in the file.'
                       ,  p_display_location => apex_error.c_inline_in_notification
                            )
       then
        return false;
       end if;
    end if;
    idx := l_column_names_dict.next(idx);
  end loop;

  ks_log.log('trace after l_column_names_dict loop', l_scope);

  if apex_error.get_error_count > 0 then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_names;


--==============================================================================
-- Function: validate_column_order
-- Purpose: validates that the columns provided in the export file are in the correct order
--
-- Inputs:  l_column_names - an array of colum names
-- Output: returns true if valid, false if invalid
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes: THIS FUNCTION IS NOT USED - the function works, but turned out to not be useful.
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
function validate_column_order (l_column_names in column_names_t)
  return boolean
is
  l_scope ks_log.scope := 'validate_column_order';
  --l_params logger.tab_param;
  l_idx number := 1;
  l_columns_in_their_order varchar2(4000);
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);

  for row in (select trim(upper(lm.header_name)) header_name,
                     display_seq
              from ks_load_mapping lm
             where 1=1
            and table_name = c_session_load_table
            and lm.to_column_name is not null
            order by lm.display_seq
            )
  loop
    if l_column_names(row.display_seq) != row.header_name
    then
      select listagg(lm.header_name, ', ') within group (order by lm.display_seq) value
        into l_columns_in_their_order
        from ks_load_mapping lm
        where 1=1
          and table_name = c_session_load_table;


        apex_error.add_error(
                  p_message => 'The columns in the export file are in an incorrect order. The proper order is: ' ||
                                  l_columns_in_their_order || '. At least this column is out of order: ' || l_column_names(l_idx)
                , p_display_location => apex_error.c_inline_in_notification
              );
      --This is a big error (lots of text), so exit here regardless of number of errors.
      return false;
    end if;

  end loop;

  return true;
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_order;



--==============================================================================
-- Procedure: init_index_map
-- Purpose: After the column names have been validated from the file,
--            we need to map which columns headers in the export go to which columns in ks_full_session_load
-- ASUMPTION(S): Column names are valid, and there aren't any missing
-- Inputs:  l_column_names - column names from the import file
--          l_cells - the final table we will create our view from.
-- Output:
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
procedure init_index_map ( l_index_map in out nocopy index_map_t)
is
  l_scope ks_log.scope := 'init_index_map';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);

  for row in (select trim(upper(lm.to_column_name)) to_column,
                     display_seq
                from ks_load_mapping lm
               where 1=1
               and table_name = c_session_load_table
          order by display_seq)
  loop
    if row.to_column is not null
    then
      l_index_map(to_char(row.display_seq)) := row.to_column;
      ks_log.log('mapped: ' || row.display_seq || ' to '  || row.to_column, l_scope);
    end if;
  end loop;

  return;
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end init_index_map;

--==============================================================================
-- Procedure: load_xlsx_data
-- Purpose: load data from xlsx into appropriate collection for parsing
--
-- Inputs: p_xlsx is an excel file that was a .csv but got saved as a .xlsx in excel
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/09/2017
--==============================================================================
procedure load_xlsx_data (p_xlsx in blob,
                          p_app_user in varchar2)
is
  l_scope ks_log.scope := 'load_xlsx_data';
  --l_params logger.tab_param;


   l_column_names column_names_t;

   l_cells as_read_xlsx_clob.tp_all_cells;
   l_curr_row number;

   l_rows_row number;

   type session_load_row_t is table of ks_full_session_load%rowtype;
   l_rows session_load_row_t;

   l_curr_col varchar2(30);

   --column index for spreadsheet_content
   l_col_ind number;

   l_index_map index_map_t;
   l_index varchar2(4000);

   --used to get the first 4000 bytes of any string data
   l_substr varchar2(4000);
   --used to get the length of the string data
   l_substr_len number;

   l_string_val clob;
   l_number_val number;
   l_date_val date;

   l_reached_final_line boolean := false;

    --An array of tags
    l_tags apex_application_global.vc_arr2;
    

begin
   --logger.append_param(l_params, 'p_app_user', p_app_user);
   --logger.append_param(l_params, 'p_into_event_id', p_into_event_id);
   --logger.append_param(l_params, 'p_into_track_id', p_into_track_id);
   ks_log.log('START', l_scope);
   ks_log.log('DEBUG - ran in load_xlsx_data', l_scope);
   l_column_names := column_names_t();
   l_rows := session_load_row_t();

   select *
    bulk collect into l_cells
    from
    table(AS_READ_XLSX_CLOB.read(p_xlsx => p_xlsx))
    order by row_nr, col_nr;

   for i in 1 ..  l_cells.count
   loop
      l_curr_row := to_number(l_cells(i).row_nr);
      apex_debug.message('BEGIN cell: ' ||  l_cells(i).row_nr || ',' || l_cells(i).col_nr);

      --NOTE: Assumption, the bulk collect gets all cells in order by row then column
      if l_curr_row = 2 and l_cells(i).col_nr = '1'
      then
        apex_debug.message('Length of l_column_names: ' || l_column_names.count);
        if not ks_session_load_api.validate_column_names(l_column_names) then
          return;
        end if;

        --modify l_cells so that the column names are correct
        init_index_map(l_index_map);

        ks_log.log('l_index_map size: ' || l_index_map.count, l_scope);
        l_index := l_index_map.first;
        while l_index is not null
        loop
          apex_debug.message('l_index_map(' || l_index ||'): ' || l_index_map(l_index));
          
          l_index := l_index_map.next(l_index);
        end loop;

      elsif l_curr_row = '1'
      then
        l_column_names.extend;
        --Get the column name (allows the .xlsx header to be defined "fuzzilly"
        apex_debug.message('Adding to l_column_names: ' || l_cells(i).string_val);
        l_column_names(i) := trim(upper(cast(l_cells(i).string_val as varchar2)));
     end if;

     apex_debug.message('trace of i at ' || i);

     if l_curr_row > 1 then
        if l_rows.count < l_curr_row -1
        then
          if l_reached_final_line
          then
            l_rows.delete(l_rows.count);
            exit;
          else
            l_reached_final_line := true; --Considered true until proven otherwise
          end if;
          l_rows.extend;
        end if;

        -- l_string_val := coalesce(l_cells(i).string_val, to_char(l_cells(i).number_val), to_char(l_cells(i).date_val));

        l_string_val := trim(l_cells(i).string_val);
        l_number_val := l_cells(i).number_val;
        l_date_val := l_cells(i).date_val;

        l_rows_row := l_curr_row -1;

        if   l_string_val is not null
          or l_number_val is not null
          or l_date_val is not null
        then
          l_reached_final_line := false;
        end if;
        
        if l_number_val is not null
        then
          l_string_val := to_char(l_number_val);
        end if;


        --The commented out code shows when the as_read_xlsx_clob package skips cells
        /*apex_debug.message('Checking existence of: ' || to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end) || ', l_cells(i).col_nr: ' || l_cells(i).col_nr 
                                                                       || ', string_val: ' || l_cells(i).string_val );
        l_index := to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end);*/
        l_index := l_cells(i).col_nr;                                                  
        if l_index_map.exists(l_index)
        then
          l_curr_col := l_index_map(l_index);
          apex_debug.message('l_curr_col: ' || l_curr_col);
          
          if l_curr_col = 'EXTERNAL_SYS_REF'
          then            
            l_rows(l_rows_row).external_sys_ref := l_string_val;
          elsif l_curr_col = 'SESSION_NUM'
          then
            l_rows(l_rows_row).session_num :=  l_string_val;
          elsif l_curr_col = 'EVENT_TRACK_ID'
          then
            l_rows(l_rows_row).event_track_id := l_string_val;
          elsif l_curr_col = 'SUB_CATEGORY'
          then
            l_rows(l_rows_row).sub_category := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_TYPE'
          then
            l_rows(l_rows_row).session_type := substr(l_string_val,1,500);
          elsif l_curr_col = 'TITLE'
          then
            l_rows(l_rows_row).title := substr(l_string_val,1,500);
          elsif l_curr_col = 'ACE_LEVEL'
          then
            l_rows(l_rows_row).ace_level := substr(l_string_val,1,30);
          elsif l_curr_col = 'COMPANY'
          then
            l_rows(l_rows_row).company := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_ABSTRACT'
          then
            l_rows(l_rows_row).session_abstract := l_string_val;
          elsif l_curr_col = 'SESSION_SUMMARY'
          then
            l_rows(l_rows_row).session_summary := substr(l_string_val,1,4000);
          elsif l_curr_col = 'TARGET_AUDIENCE'
          then
            l_rows(l_rows_row).target_audience := substr(l_string_val,1,60);
          elsif l_curr_col = 'TECHNOLOGY_PRODUCT'
          then
            l_rows(l_rows_row).technology_product := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTED_BEFORE_IND'
          then
            l_rows(l_rows_row).presented_before_ind := l_string_val;
          elsif l_curr_col = 'PRESENTED_BEFORE_WHERE'
          then
            l_rows(l_rows_row).presented_before_where := substr(l_string_val,1,4000);
          elsif l_curr_col = 'VIDEO_LINK'
          then
            l_rows(l_rows_row).video_link := substr(l_string_val,1,4000);
          elsif l_curr_col = 'CO_PRESENTER'
          then
            l_rows(l_rows_row).co_presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTER_BIOGRAPHY'
          then
            l_rows(l_rows_row).presenter_biography := l_string_val;
          elsif l_curr_col = 'PRESENTER'
          then
            l_rows(l_rows_row).presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'TAGS'
          then
            l_tags := apex_util.string_to_table(l_string_val,',');
            for i in 1..l_tags.count
            loop
              l_tags(i) := trim(l_tags(i));
            end loop;
            l_rows(l_rows_row).tags := substr(apex_util.table_to_string(l_tags,':'),1,1000);
          elsif l_curr_col = 'CONTAINS_DEMO_IND'
          then
            l_rows(l_rows_row).contains_demo_ind := l_string_val;
          elsif l_curr_col = 'WEBINAR_WILLING_IND'
          then
            l_rows(l_rows_row).webinar_willing_ind := l_string_val;
          elsif l_curr_col = 'PRESENTER_EMAIL'
          then
            l_rows(l_rows_row).presenter_email := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).co_presenter_user_id := case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).presenter_user_id :=  case when l_number_val = 0 then null else l_number_val end;
          end if;

        end if;
      end if;
    end loop;



    delete from ks_full_session_load s;


    forall i in l_rows.first .. l_rows.last
        insert into ks_full_session_load(
                  external_sys_ref
                , session_num
                , event_track_id
                , sub_category
                , session_type
                , title
                , ace_level
                , presented_before_ind
                , presented_before_where
                , video_link
                , co_presenter
                , presenter_biography
                , company
                , presenter
                , session_abstract
                , session_summary
                , tags
                , target_audience
                , technology_product
                , contains_demo_ind
                , webinar_willing_ind
                , presenter_email
                , co_presenter_user_id
                , presenter_user_id
            )
     values (
                 l_rows(i).external_sys_ref
               , l_rows(i).session_num
               , l_rows(i).event_track_id
               , l_rows(i).sub_category
               , l_rows(i).session_type
               , l_rows(i).title
               , l_rows(i).ace_level
               , l_rows(i).presented_before_ind
               , l_rows(i).presented_before_where
               , l_rows(i).video_link
               , l_rows(i).co_presenter
               , l_rows(i).presenter_biography
               , l_rows(i).company
               , l_rows(i).presenter
               , l_rows(i).session_abstract
               , l_rows(i).session_summary
               , l_rows(i).tags
               , l_rows(i).target_audience
               , l_rows(i).technology_product
               , l_rows(i).contains_demo_ind
               , l_rows(i).webinar_willing_ind
               , l_rows(i).presenter_email
               , l_rows(i).co_presenter_user_id
               , l_rows(i).presenter_user_id
            );
end;

--==============================================================================
-- Function: validate_uniqueness
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_uniqueness
  return boolean
is
  l_scope ks_log.scope := 'validate_uniqueness';
  --l_params logger.tab_param;
  l_unique_count number;
  l_count number;
begin
  ks_log.log('START', l_scope);


  for row in (select distinct session_num
                from ks_full_session_load
               where session_num in
              (select session_num
                 FROM ks_full_session_load
                 group by session_num
                 having count(*) > 1))
  loop
    if not add_error_check_continue(p_message => 'The session_number, "' || row.session_num || '", is not unique. Session numbers must be unique to continue.'
                             ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;

  --Do the same thing for external_sys_ref
  for row in (select distinct external_sys_ref
                from ks_full_session_load
               where external_sys_ref in
              (select external_sys_ref
                 FROM ks_full_session_load
                 group by external_sys_ref
                 having count(*) > 1))
  loop
    if not add_error_check_continue(p_message => 'The session id (external system reference), "' || row.external_sys_ref || '", is not unique. Session id''s must be unique to continue.'
                             ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;

  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_uniqueness;

--==============================================================================
-- Function: validate_not_null
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_not_null
  return boolean
is
  l_scope ks_log.scope := 'validate_not_null';
  --l_params logger.tab_param;
  l_unique_count number;
  l_count number;
begin
  ks_log.log('START', l_scope);


  for row in (select 1
                from ks_full_session_load
               where session_num is null)

  loop
    if not add_error_check_continue(p_message => 'One of the session numbers does not have a value. Every session number must have a value.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                 )
    then
      return false;
    end if;
  end loop;

  for row in (select 1
                from ks_full_session_load
               where external_sys_ref is null)

  loop
    if not add_error_check_continue(p_message => 'One of the session id''s (represented in the external_sys_ref column) does not have a value. '
                                              || 'Every session id must have a value.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                 )
    then
      return false;
    end if;
  end loop;

  for row in (select 1
                from ks_full_session_load
               where event_track_id is null)

  loop
    if not add_error_check_continue(p_message => 'One of the tracks does not have a value. Every track must have a value.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                 )
    then
      return false;
    end if;
  end loop;



  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_not_null;


--==============================================================================
-- Function: validate_new_session
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_new_session(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := 'validate_new_session';
  --l_params logger.tab_param;
  l_unique_count number;
  l_count number;
begin

  ks_log.log('START', l_scope);

  for row in (select sl.session_num
                from ks_full_session_load sl,
                     ks_sessions s
               where 1=1
                 and s.session_num = sl.session_num
                 and s.event_id = p_into_event_id)

  loop
    if not add_error_check_continue(p_message => 'A session with session number "' || row.session_num || '" already exists for this event.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                 )
    then
      return false;
    end if;
  end loop;


  for row in (select sl.external_sys_ref
                from ks_full_session_load sl,
                     ks_sessions s
               where 1=1
                 and s.external_sys_ref = sl.external_sys_ref
                 and s.event_id = p_into_event_id)

  loop
    if not add_error_check_continue(p_message => 'A session with session id (external_sys_ref) "' || row.external_sys_ref || '" already exists for this event.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                 )
    then
      return false;
    end if;
  end loop;





  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_new_session;


--==============================================================================
-- Function: validate_correct_types
-- Purpose:
--
-- Inputs: p_into_event_id - the id of the event
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_correct_types(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := 'validate_correct_types';
  --l_params logger.tab_param;
  l_unique_count number;
  l_count number;
begin
  ks_log.log('START', l_scope);


  --First check the track
  for row in (select distinct sl.event_track_id
                from ks_full_session_load sl
               where event_track_id not in (select name
                                     from ks_event_tracks
                                    where event_id = p_into_event_id
                                      )
                )
  loop
    if not add_error_check_continue(p_message => 'The track "'|| row.event_track_id ||'" does not exist for this event. Either change the name of the track, or create a new track for this event.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;
  
  --The validations below are for yes/no columns
  --I (Ben) commented this out because David Schleiss says that
  -- any value that's not a Y,Yes or N,No should simply default to no. (10/16/2017)
  /*
  --Now check "Presented Before Ind"
  for row in (select distinct sl.presented_before_ind
                from ks_full_session_load sl
               where lower(presented_before_ind) not in ('yes', 'no')
                )
  loop
    if not add_error_check_continue(p_message => 'An invalid value for "Presented Before" exists. This value is "'
                                               || row.presented_before_ind ||'". It should only be Yes or No.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;  

  --Now check "demo_included_ind"
  for row in (select distinct sl.demo_included_ind
                from ks_full_session_load sl
               where lower(demo_included_ind) not in ('yes', 'no')
                )
  loop
    if not add_error_check_continue(p_message => 'An invalid value for "Demo Included" exists. This value is "'
                                               || row.demo_included_ind ||'". It should only be Yes or No.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;  


  --Now check "webinar_willing_ind"
  for row in (select distinct sl.webinar_willing_ind
                from ks_full_session_load sl
               where lower(webinar_willing_ind) not in ('yes', 'no')
                )
  loop
    if not add_error_check_continue(p_message => 'An invalid value for "Webinar Willing" exists. This value is "'
                                               || row.webinar_willing_ind ||'". It should only be Yes or No.'
                                 ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;  
  if apex_error.get_error_count > 0
  then
    return false;
  end if;
  */
  
  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_correct_types;





--==============================================================================
-- Function: validate_data
-- Purpose: Runs validations checks on the data. This occurs after ks_full_session_load is loaded and it's columns are validated,
--             but before we have submitted it's data to the corresponding tables.
--
-- Inputs: p_into_event_id, the id the of the event
-- Output: whether the data is avalid or not
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function validate_data(p_into_event_id ks_event_tracks.event_id%TYPE)
  return boolean
is
  l_scope ks_log.scope := 'validate_data';
  l_an_error_occurred boolean := false;
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, '', );
  ks_log.log('START', l_scope);

  if not validate_uniqueness
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_not_null
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_new_session(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_correct_types(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;




  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_data;







/**
 * Process to purge votes, sessions and tags from and event and/or track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 25, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_votes_only_ind to specify that only votes should be deleted.
 * @param p_force_ind to force the execution of the process even when votes
 *                    are present.
 */
procedure purge_event(
  p_event_id          in ks_sessions.event_id%TYPE
  , p_track_id        in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind  in varchar2
  , p_force_ind       in varchar2
)
is

  no_action exception;

  l_votes_count number := 0;

begin

  -- This count is for pretection.
  -- We don't want to delete when there are votes present.
  select count(1)
    into l_votes_count
    from ks_session_votes v
       , ks_sessions s
   where v.session_id = s.id
     and s.event_id = p_event_id
     and (p_track_id is null or s.event_track_id = p_track_id)
     and p_votes_only_ind = 'N';


  if l_votes_count > 0 then
    -- if this parameter equals No 'N' then the process raises an error indicating no action will be done.
    raise no_action;
  end if;


  -- Delete the votes when the user selects "Votes Only" or "Force Purge"
  delete 
    from ks_session_votes v
   where v.session_id in (
      select ss.id
        from ks_sessions ss
       where ss.event_id = p_event_id
         and (p_track_id is null or ss.event_track_id = p_track_id)
   )
     and (p_votes_only_ind = 'Y' or p_force_ind = 'Y');


  -- Only delete sessions when the there are no votes and user selected Votes Only
  -- OR 
  -- Delete when user selected "Force Purge"
  delete
    from ks_sessions
   where event_id = p_event_id
     and (p_track_id is null or event_track_id = p_track_id)
     and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
         or p_force_ind = 'Y'
       );


  -- Remove unused tags after the "delete ks_sessions"
  --   When the there are no votes and user selected Votes Only
  --   OR 
  --   Delete when user selected "Force Purge"
  delete
    from ks_tag_type_sums ts
   where exists (
    select 1
     from ks_tag_type_sums s
        , ks_event_tracks t
    where s.content_type = 'SESSION' || ':' || t.id
      and s.tag_count = 0
      and s.rowid = ts.rowid
      and t.event_id = p_event_id
      and (p_track_id is null or t.id = p_track_id)
   )
    and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
        or p_force_ind = 'Y'
      );

  
  exception
    when no_action then
      raise_application_error (-20000,'Votes are present. Purge action aborted.');
    
end purge_event;






end ks_session_load_api;
/
PRO ks_users_api
-- @../plsql/ks_users_api.plb
create or replace package body ks_users_api
as

--------------------------------------------------------------------------------
--*
--* Recieves the User information (Existing User, First Name, Last Name,
--* Email, Password, Is Admin) and Event / Track information (Event Id,
--* Track Id, Selection and Voting Role) and inserts this data into the
--* user table (ks_user) and/or relational table (ks_user_event_track_roles).
--*
--------------------------------------------------------------------------------
procedure set_user_information (
	p_existing_user    in   ks_users.username%TYPE,
	p_first_name       in   ks_users.first_name%TYPE,
	p_last_name        in   ks_users.last_name%TYPE,
	p_email            in   ks_users.email%TYPE,
	p_password         in   ks_users.password%TYPE,
	p_is_admin         in   ks_users.admin_ind%TYPE,
	p_event_id         in   ks_event_tracks.event_id%TYPE,
	p_track_id         in   ks_event_tracks.id%TYPE,
	p_selection_code   in   ks_roles.code%TYPE,
	p_voting_code      in   ks_roles.code%TYPE,
	p_external_sys_ref in   ks_users.external_sys_ref%TYPE
)
is

	l_is_active ks_users.active_ind%TYPE := 'Y';
	l_user_id ks_users.id%TYPE;
	l_username ks_users.username%TYPE;
	l_user_event_track_role ks_user_event_track_roles.id%TYPE;
	
begin

	if p_existing_user is null then
		
		ks_user_dml.ins_ks_users(
			l_user_id,
			upper(p_email),
			p_password,
			p_first_name,
			p_last_name,
			p_email,
			l_is_active,
			p_is_admin,
			p_external_sys_ref
		);
		
		select username 
			into l_username
			from ks_users
		where id = l_user_id;
		
		ks_user_event_track_roles_dml.ins_ks_user_event_track_roles(
            l_user_event_track_role,
			l_username,
			p_track_id,
			p_selection_code,
			p_voting_code
		);
		
	else
	
		l_username := p_existing_user;
	
		ks_user_event_track_roles_dml.ins_ks_user_event_track_roles(
			l_user_event_track_role,
			l_username,
			p_track_id,
			p_selection_code,
			p_voting_code
		);
		
	end if;

	exception
	
    when OTHERS then
	
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
	  
      raise;
	
end set_user_information;

end ks_users_api;
/
PRO .ks_session_api
-- @../plsql/ks_session_api.plb
create or replace package body ks_session_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 * @constant gc_html_whitelist_tags a list of strings to NOT escape from. Same as the apex version but includes span and em
 * @constant gc_token_exceptions is a "|" separated list that gets passed into ks_util. It contains the tokens which we want to ommit from escaping.
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';
gc_html_whitelist_tags constant varchar2(500) := '<h1>,</h1>,<h2>,</h2>,<h3>,</h3>,<h4>,</h4>,<p>,<span>,</span>,</p>,<b>,</b>,<strong>,</strong>,<i>,</i>,<ul>,</ul>,<ol>,</ol>,<li>,</li>,<br />,<hr/>,<em>,</em>';
gc_token_exceptions constant varchar2(4000) := 'oracle|apex';
gc_parameter_tokens_name constant ks_parameters.name_key%type := 'ANONYMIZE_EXTRA_TOKENS';


------------------------------------------------------------------------------
/**
 * Description
 *
 *
 * @example
 *
 * @issue
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param p_event_id
 * @param p_presenter
 * @return
 */
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter in ks_sessions.presenter%TYPE)
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'presenter_tracks_json';
  -- l_params logger.tab_param;

  list_cur sys_refcursor;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter', p_presenter);
  -- logger.log('BEGIN', l_scope, null, l_params);

  -- open list_cur for
  -- select p_presenter "presenter", '<ul><li>' || listagg(nvl(t.alias, t.name), '</li><li>') within group (order by t.display_seq) || '</li></ul>' "trackList"
  --   from ks_event_tracks t
  --      , ks_sessions s
  --  where t.id s.event_track_id
  --    and s.event_id = to_number(p_event_id)
  --    and s.presenter = p_presenter
  -- );

  open list_cur for
    select p_presenter "presenter"
         , '<ul><li>' ||listagg(n || ' in ' || p || ' (' || status || ')', '</li><li>') within group (order by display_seq) || '</li></ul>' "trackList"
    from (
      select t.display_seq, nvl(t.alias, t.name) p, count(*) n
           , listagg(nvl(st.name, '?'), ',') within group (order by st.display_seq) status
        from ks_event_tracks t
           , ks_sessions s
           , ks_session_status st
       where t.id = s.event_track_id
         and s.event_id = to_number(p_event_id)
         and s.presenter = p_presenter
         and s.status_code = st.code (+)
       group by t.display_seq, nvl(t.alias, t.name)
    );

  apex_json.write(list_cur);

  -- apex_json.open_object;
  -- apex_json.write('presenter', p_presenter);
  -- apex_json.write('trackList', '<ul><li>Track 1</li></ul>');
  -- apex_json.close_object;


  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    apex_json.open_array;
    apex_json.open_object;
    apex_json.write('presenter', p_presenter);
    apex_json.write('trackList', 'Unable to fetch list:<br>' || sqlerrm || '<br>');
    apex_json.close_object;
    apex_json.close_array;
end presenter_tracks_json;






/**
 * Switch votes and voting role of an user for a selected event / track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 26, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_username username of the user.
 * @param p_voting_role selected voting role for the user.
 */
procedure switch_votes (
  p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username    in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
)
is

begin

  -- Move all votes to new vote_type
  update ks_session_votes
     set vote_type = p_voting_role
   where id in (
      select sv.id
        from ks_session_votes sv
           , ks_sessions s
       where sv.username = p_username
         and s.event_id = p_event_id
         and s.event_track_id = p_track_id
         and sv.session_id = s.id);

  update ks_user_event_track_roles
     set voting_role_code = p_voting_role
   where username = p_username
     and event_track_id = p_track_id;

end switch_votes;







--==============================================================================
-- Function: html_whitelist_clob
-- Purpose: returns a varchar2 where every chunk of 4000 characters has been html_whitelisted and tokenized
--
-- Inputs:  p_string - the clob or varchar2 to be escaped/tokenized
--          p_session_id - the session id. We use this to get the name of the presenter/company/co-presenter
--          p_anonymize - whether to hide the info
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N')
  return varchar2
is
  l_scope varchar2(255) := 'html_whitelist_tokenize';
  l_output varchar2(32767);
  l_presenter ks_sessions.presenter%type;
  l_co_presenter ks_sessions.co_presenter%type;
  l_company ks_sessions.company%type;
  l_parameter_tokens varchar2(4000);
begin
  ks_log.log('START', l_scope);

  --The id is usually null when the user's session got reset
  --We don't want to create an ugly error on top of the page already showing errors
  --So silently exit.
  if p_session_id is null then
    return '';
  end if;

  l_output := apex_escape.html_whitelist(p_string, gc_html_whitelist_tags);
  l_output := regexp_replace(l_output, '_x000D_', '', 1, 0, 'i');

  if p_anonymize = 'Y'
  then
    select presenter, company, co_presenter
    into l_presenter, l_company, l_co_presenter
    from ks_sessions
   where 1=1
     and id = p_session_id;

     l_output := ks_util.replace_tokens(l_output 
                                      , l_presenter || ' ' || l_company || ' ' || l_co_presenter || ' ' || ks_util.get_param(gc_parameter_tokens_name)
                                      , gc_token_exceptions);


  end if;



  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  html_whitelist_tokenize;


end ks_session_api;
/
PRO ks_user_event_track_roles_dml
-- @../plsql/ks_user_event_track_roles_dml.plb
create or replace package body KS_USER_EVENT_TRACK_ROLES_DML is 
 
-------------------------------------------------------------- 
-- create procedure for table KS_USER_EVENT_TRACK_ROLES 
 
   procedure INS_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID                  in out number, 
      P_USERNAME            in varchar2, 
      P_EVENT_TRACK_ID      in number, 
      P_SELECTION_ROLE_CODE in varchar2                        default null, 
      P_VOTING_ROLE_CODE    in varchar2                        default null, 
      P_CREATED_BY          in varchar2                        default null, 
      P_CREATED_ON          in date                            default null, 
      P_UPDATED_BY          in varchar2                        default null, 
      P_UPDATED_ON          in date                            default null 
   ) is  
  
   begin 
  
      insert into KS_USER_EVENT_TRACK_ROLES ( 
         --ID, 
         USERNAME, 
         EVENT_TRACK_ID, 
         SELECTION_ROLE_CODE, 
         VOTING_ROLE_CODE 
         --CREATED_BY, 
         --CREATED_ON, 
         --UPDATED_BY, 
         --UPDATED_ON 
      ) values (  
         --P_ID, 
         P_USERNAME, 
         P_EVENT_TRACK_ID, 
         P_SELECTION_ROLE_CODE, 
         P_VOTING_ROLE_CODE 
         --P_CREATED_BY, 
         --P_CREATED_ON, 
         --P_UPDATED_BY, 
         --P_UPDATED_ON 
      ) 
	  returning id into p_id; 
  
   end INS_KS_USER_EVENT_TRACK_ROLES; 
 
 
-------------------------------------------------------------- 
-- update procedure for table KS_USER_EVENT_TRACK_ROLES 
 
   procedure UPD_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID in number, 
      P_USERNAME            in varchar2, 
      P_EVENT_TRACK_ID      in number, 
      P_SELECTION_ROLE_CODE in varchar2                        default null, 
      P_VOTING_ROLE_CODE    in varchar2                        default null, 
      P_CREATED_BY          in varchar2                        default null, 
      P_CREATED_ON          in date                            default null, 
      P_UPDATED_BY          in varchar2                        default null, 
      P_UPDATED_ON          in date                            default null, 
      P_MD5                 in varchar2                        default null 
   ) is  
  
      L_MD5 varchar2(32767) := null; 
  
   begin 
  
      if P_MD5 is not null then 
         for c1 in ( 
            select * from KS_USER_EVENT_TRACK_ROLES  
            where ID = P_ID FOR UPDATE 
         ) loop 
  
            L_MD5 := BUILD_KS_USR_EVNT_TRCK_RLE_MD5( 
               c1.ID, 
               c1.USERNAME, 
               c1.EVENT_TRACK_ID, 
               c1.SELECTION_ROLE_CODE, 
               c1.VOTING_ROLE_CODE, 
               c1.CREATED_BY, 
               c1.CREATED_ON, 
               c1.UPDATED_BY, 
               c1.UPDATED_ON 
            ); 
  
         end loop; 
  
      end if; 
  
      if (P_MD5 is null) or (L_MD5 = P_MD5) then  
         update KS_USER_EVENT_TRACK_ROLES set 
            ID                    = P_ID, 
            USERNAME              = P_USERNAME, 
            EVENT_TRACK_ID        = P_EVENT_TRACK_ID, 
            SELECTION_ROLE_CODE   = P_SELECTION_ROLE_CODE, 
            VOTING_ROLE_CODE      = P_VOTING_ROLE_CODE, 
            CREATED_BY            = P_CREATED_BY, 
            CREATED_ON            = P_CREATED_ON, 
            UPDATED_BY            = P_UPDATED_BY, 
            UPDATED_ON            = P_UPDATED_ON 
         where ID = P_ID; 
      else 
         raise_application_error (-20001,'Current version of data in database has changed since user initiated update process. current checksum = '||L_MD5||', item checksum = '||P_MD5||'.');   
      end if; 
  
   end UPD_KS_USER_EVENT_TRACK_ROLES; 
 
 
-------------------------------------------------------------- 
-- delete procedure for table KS_USER_EVENT_TRACK_ROLES 
 
   procedure DEL_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID in number 
   ) is  
  
   begin 
  
      delete from KS_USER_EVENT_TRACK_ROLES  
      where ID = P_ID; 
  
   end DEL_KS_USER_EVENT_TRACK_ROLES; 
 
-------------------------------------------------------------- 
-- get procedure for table KS_USER_EVENT_TRACK_ROLES 
 
   procedure GET_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID in number, 
      P_USERNAME            out varchar2, 
      P_EVENT_TRACK_ID      out number, 
      P_SELECTION_ROLE_CODE out varchar2, 
      P_VOTING_ROLE_CODE    out varchar2, 
      P_CREATED_BY          out varchar2, 
      P_CREATED_ON          out date, 
      P_UPDATED_BY          out varchar2, 
      P_UPDATED_ON          out date 
   ) is  
  
      ignore varchar2(32676); 
   begin 
  
      GET_KS_USER_EVENT_TRACK_ROLES ( 
         P_ID, 
         P_USERNAME, 
         P_EVENT_TRACK_ID, 
         P_SELECTION_ROLE_CODE, 
         P_VOTING_ROLE_CODE, 
         P_CREATED_BY, 
         P_CREATED_ON, 
         P_UPDATED_BY, 
         P_UPDATED_ON, 
         ignore 
      ); 
  
   end GET_KS_USER_EVENT_TRACK_ROLES; 
 
-------------------------------------------------------------- 
-- get procedure for table KS_USER_EVENT_TRACK_ROLES 
 
   procedure GET_KS_USER_EVENT_TRACK_ROLES ( 
      P_ID in number, 
      P_USERNAME            out varchar2, 
      P_EVENT_TRACK_ID      out number, 
      P_SELECTION_ROLE_CODE out varchar2, 
      P_VOTING_ROLE_CODE    out varchar2, 
      P_CREATED_BY          out varchar2, 
      P_CREATED_ON          out date, 
      P_UPDATED_BY          out varchar2, 
      P_UPDATED_ON          out date, 
      P_MD5                 out varchar2 
   ) is  
  
   begin 
  
      for c1 in ( 
         select * from KS_USER_EVENT_TRACK_ROLES  
         where ID = P_ID  
      ) loop 
         P_USERNAME            := c1.USERNAME; 
         P_EVENT_TRACK_ID      := c1.EVENT_TRACK_ID; 
         P_SELECTION_ROLE_CODE := c1.SELECTION_ROLE_CODE; 
         P_VOTING_ROLE_CODE    := c1.VOTING_ROLE_CODE; 
         P_CREATED_BY          := c1.CREATED_BY; 
         P_CREATED_ON          := c1.CREATED_ON; 
         P_UPDATED_BY          := c1.UPDATED_BY; 
         P_UPDATED_ON          := c1.UPDATED_ON; 
  
         P_MD5 := BUILD_KS_USR_EVNT_TRCK_RLE_MD5( 
            c1.ID, 
            c1.USERNAME, 
            c1.EVENT_TRACK_ID, 
            c1.SELECTION_ROLE_CODE, 
            c1.VOTING_ROLE_CODE, 
            c1.CREATED_BY, 
            c1.CREATED_ON, 
            c1.UPDATED_BY, 
            c1.UPDATED_ON 
         ); 
      end loop; 
  
   end GET_KS_USER_EVENT_TRACK_ROLES; 
 
-------------------------------------------------------------- 
-- build MD5 function for table KS_USER_EVENT_TRACK_ROLES 
 
   function BUILD_KS_USR_EVNT_TRCK_RLE_MD5 ( 
      P_ID in number, 
      P_USERNAME            in varchar2, 
      P_EVENT_TRACK_ID      in number, 
      P_SELECTION_ROLE_CODE in varchar2                        default null, 
      P_VOTING_ROLE_CODE    in varchar2                        default null, 
      P_CREATED_BY          in varchar2                        default null, 
      P_CREATED_ON          in date                            default null, 
      P_UPDATED_BY          in varchar2                        default null, 
      P_UPDATED_ON          in date                            default null 
   ) return varchar2 is  
  
   begin 
  
      return apex_util.get_hash(apex_t_varchar2( 
         P_USERNAME, 
         P_EVENT_TRACK_ID, 
         P_SELECTION_ROLE_CODE, 
         P_VOTING_ROLE_CODE, 
         P_CREATED_BY, 
         to_char(P_CREATED_ON,'yyyymmddhh24:mi:ss'), 
         P_UPDATED_BY, 
         to_char(P_UPDATED_ON,'yyyymmddhh24:mi:ss') )); 
  
   end BUILD_KS_USR_EVNT_TRCK_RLE_MD5; 
  
end KS_USER_EVENT_TRACK_ROLES_DML;
/

----------------------------------------
-- =============================================================================
-- ==========================  Full consolidated_v2.sql file
-- =============================================================================
--- 

PRO Installing 2.0.1
/*
# Voting Apps upgrade to v2.0.1

## Voting App: Changes and Enhancements
* Session "Summary" and "Abstract" are now available columns in the session list.
* Committee Members can now opt to hide speaker and company information (Go to Preferences)
* By Popular demand: "Voting Region" has now been relocated to the top of the screen.
* When present, Co-Presenter is now displayed right below the Presenter


## Content Selection App: Changes and Enhancements
* Session "Summary" and "Abstract" are now available columns in the session list.

*/

alter table ks_full_session_load add co_presenter_company varchar2(4000);
alter table ks_sessions add co_presenter_company varchar2(500);

update ks_load_mapping
   set to_column_name = 'CO_PRESENTER_COMPANY'
 where header_name = 'Role:Co-Presenter Company'
/


PRO Installing 2.0.2
/*
# Voting Apps upgrade to v2.0.2

## Changes and Enhancements
* New report: All Sessions Report (with cross track priviledges)
* New report: Presenters with Multiple Sessions
* Submission Date is now loaded
* Submission Video is now more prominent and displayed for Committee voters
* Changes and enhancements to XLS sesison load

## Small Technical Changes
* Session should be unique by event

*/

drop index ks_sessions_u01;
create unique index ks_sessions_u01 on ks_sessions(event_id, session_num);

alter table ks_full_session_load add submission_date date;
alter table ks_sessions add submission_date date;

update ks_load_mapping
   set to_column_name = 'SUBMISSION_DATE'
 where header_name = 'Initial Submission'
/


PRO Installing 2.0.3
/*
# Voting Apps upgrade to v2.0.3

## Changes and Enhancements
* Full Summary & Abstract are now included in the Additional section.
* "Summary?" & "Abstract?" icon columns are searched if included in the report.
* Enhancements for censored words

## Small Technical Changes

*/


PRO Installing 2.0.4
/*
# Voting Apps upgrade to v2.0.4

## Changes and Enhancements
* Fixed issue on Voting App where long abstracts would fail the report
* Dont show events that ended more than 6 months ago.

## Small Technical Changes
* epm added to the "token_exceptions" list
* Speed for Tokenizer and Token Replacement.
* Speed for Data Load

*/


PRO Installing 2.0.5
/*
# Voting Apps upgrade to v2.0.5

## Changes and Enhancements
* Added ability for Admin to move sessions to a different track

## Small Technical Changes
* New large "Check" mark to indicate you have voted
* Security enhancements on p2

*/



-- @../plsql/ks_session_load_api.pls
create or replace package ks_session_load_api
is

--------------------------------------------------------------------------------
--*
--*
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


procedure load_xlsx_data (
    p_xlsx      in blob
  , p_username  in varchar2 default v('APP_USER')
);

function validate_data(
    p_into_event_id in ks_event_tracks.event_id%TYPE
) return boolean;

procedure load_sessions (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
  , x_load_count in out number
);

procedure purge_event(
  p_event_id      in ks_sessions.event_id%TYPE
  , p_track_id      in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind  in varchar2
  , p_force_ind     in varchar2
);

end ks_session_load_api;
/
-- @../plsql/ks_util.pls
create or replace package ks_util
as

type gc_clob_arr_type is table of clob;

--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2;

--------------------------------------------------------------------------------
procedure set_param(
    p_name_key  in ks_parameters.name_key%TYPE
  , p_value     in ks_parameters.value%TYPE
);


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2;


--------------------------------------------------------------------------------
function format_full_name
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2;


--------------------------------------------------------------------------------
function is_number
(
  p_value        in         varchar2
) return boolean;

--------------------------------------------------------------------------------
function string_to_coll (p_string in varchar2) return sys.ODCIVarchar2List;

--------------------------------------------------------------------------------
function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         )
  return varchar2;

--------------------------------------------------------------------------------
function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report;


---------------------------------------------------------------------------------
function blob2clob(
  p_blob in blob,
  p_blob_csid in integer default dbms_lob.default_csid)
  return clob;

function replace_tokens (p_string in varchar2,
                         p_tokens in varchar2,
                         p_token_exceptions in varchar2)
 return varchar2;

function clob_to_varchar2_table (p_clob in out nocopy clob)
  return gc_clob_arr_type;


end ks_util;
/
-- @../plsql/ks_session_api.pls
create or replace package ks_session_api
is

--------------------------------------------------------------------------------
--*
--* 
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter in ks_sessions.presenter%TYPE);
  
procedure switch_votes (
  p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username    in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
);


function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N',
                                  p_escape_html in varchar2 default 'Y')
  return varchar2;
  
end ks_session_api;
/


-- @../plsql/ks_session_load_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
create or replace package body ks_session_load_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix: Standard logger package name
 * @constant gc_all_clob_columns: comma separeted list of columns that are clobs
 * @column_names_t: is the table type for columns taken from the export file.
 * @c_max_errors_to_display: the maximum number of errors to display to the user.
 * @index_map_t: maps column numbers from the export file to column names in ks_full_session_load
*/
gc_scope_prefix      constant varchar2(31) := lower($$PLSQL_UNIT) || '.';

gc_all_clob_columns  constant varchar2(4000) := 'SESSION_DESCRIPTION';

c_session_load_table constant varchar2(30) := 'KS_FULL_SESSION_LOAD';

c_max_errors_to_display constant number := 4;

type column_names_t is varray(4000) of varchar2(4000);

type index_map_t is table of varchar2(30) index by varchar2(10);



--==============================================================================
-- Function: add_error_check_continue
-- Purpose: Wrapper function for apex_error. It logs the error and if we've reached the threshold c_max_errors_to_display we return false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function add_error_check_continue (p_message in varchar2,
                                   p_display_location in varchar2)
  return boolean
is
  l_scope ks_log.scope := 'add_error_check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);

  apex_error.add_error(
            p_message => p_message
          , p_display_location => p_display_location
        );

  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end add_error_check_continue;




--==============================================================================
-- Function: add_error_check_continue
-- Purpose: Checks if we've reached the threshold c_max_errors_to_display. If so, then it returns false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function check_continue
  return boolean
is
  l_scope ks_log.scope := 'check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);


  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end check_continue;




--==============================================================================
-- Function: validate_uniqueness
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_uniqueness
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_uniqueness';

  l_count number;
begin
  ks_log.log('START', l_scope);

  for row in (
    select session_num
      from ks_full_session_load
     group by session_num
    having count(*) > 1
  )
  loop
    if not add_error_check_continue(p_message => 'The session_number "' || row.session_num || '", is not unique. Correct to continue.'
                             ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;

  --Do the same thing for external_sys_ref
  for row in (
    select external_sys_ref
      from ks_full_session_load
     group by external_sys_ref
     having count(*) > 1
  )
  loop
    if not add_error_check_continue(
        p_message => 'The session id (external system reference) "' || row.external_sys_ref || '", is not unique. Correct to continue.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;

  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_uniqueness;



--==============================================================================
-- Function: validate_not_null
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_not_null
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_not_null';

begin
  ks_log.log('START', l_scope);

  for row in (
    select title
      from ks_full_session_load
     where session_num is null
        or external_sys_ref is null
  )
  loop
    if not add_error_check_continue(
        p_message => 'Session "' || substr(row.title,1,20) || '" is missing a session_num or external_sys_ref.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  for row in (
    select session_num || ':' || title name
      from ks_full_session_load
     where event_track_id is null
  )
  loop
    if not add_error_check_continue(
        p_message => 'Session "' || substr(row.name,1,20) || '" is missing a track.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;



  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_not_null;



--==============================================================================
-- Function: validate_new_session
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_new_session(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_new_session';

begin

  ks_log.log('START', l_scope);

  for row in (
    select sl.session_num
      from ks_full_session_load sl
         , ks_sessions s
     where s.session_num = sl.session_num
       and s.event_id = p_into_event_id
  )
  loop
    if not add_error_check_continue(
        p_message => 'A session with session number "' || row.session_num || '" already exists for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  for row in (
    select sl.external_sys_ref
      from ks_full_session_load sl
         , ks_sessions s
     where s.external_sys_ref = sl.external_sys_ref
       and s.event_id = p_into_event_id
  )
  loop
    if not add_error_check_continue(
        p_message => 'A session with session id (external_sys_ref) "' || row.external_sys_ref || '" already exists for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_new_session;




--==============================================================================
-- Function: validate_correct_tracks
-- Purpose:
--
-- Inputs: p_into_event_id - the id of the event
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_correct_tracks(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_correct_tracks';

begin
  ks_log.log('START', l_scope);

  --First check the track
  -- Sorry, ks_full_session_load.event_track_id is not an ID at all but a name!
  for row in (
    select distinct sl.event_track_id
      from ks_full_session_load sl
     where event_track_id not in (
        select name
          from ks_event_tracks
         where event_id = p_into_event_id
     )
  )
  loop
    if not add_error_check_continue(
        p_message => 'The track "'|| row.event_track_id ||'" does not exist for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      ks_log.log('Missing track, Abort!', l_scope);
      return false;
    end if;
  end loop;

  ks_log.log('END', l_scope);
  
  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_correct_tracks;





--==============================================================================
-- Function: validate_data
-- Purpose: Runs validations checks on the data. This occurs after ks_full_session_load is loaded and it's columns are validated,
--             but before we have submitted it's data to the corresponding tables.
--
-- Inputs: p_into_event_id, the id the of the event
-- Output: whether the data is avalid or not
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function validate_data(p_into_event_id ks_event_tracks.event_id%TYPE)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_data';

begin
  ks_log.log('START', l_scope);

  if not validate_uniqueness
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_not_null
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_new_session(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_correct_tracks(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_data;





--==============================================================================
-- Function: validate_column_names
-- Purpose: This makes sure that the first row of the .xlsx file contains row names FOR EACH column in ks_session_load (minus event_id, track_id, and app_user)
--
-- Inputs: l_column_names - varray of column names
-- Output: returns true if valid, false if invalid
-- Scope: Not  Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/09/2017
--==============================================================================
function validate_column_names (l_column_names in column_names_t)
return boolean
is
  l_scope ks_log.scope := 'validate_column_names';
  --l_params logger.tab_param;
  type column_names_dict_t is table of varchar2(20) index by varchar2(4000);
  l_column_names_dict column_names_dict_t;

  i number := 0;
  idx varchar2(4000);
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);


  for row in (select trim(upper(lm.header_name)) header
                from ks_load_mapping lm
                where 1=1
                  and table_name = c_session_load_table)
  loop
    l_column_names_dict(row.header) := 'not_matched';
  end loop;

  for i in 1..l_column_names.count
  loop
      if not l_column_names_dict.exists(trim(upper(l_column_names(i))))
      then
        if not add_error_check_continue(p_message => 'The column "' || l_column_names(i) || '" does not match any column names specified in the instructions.'
                                     ,  p_display_location => apex_error.c_inline_in_notification
                            )
        then
          return false;
        end if;
      else
        l_column_names_dict(trim(upper(l_column_names(i)))) := 'matched';
      end if;
  end loop;

  ks_log.log('before l_column_names_dict loop', l_scope);

  idx := l_column_names_dict.first;
  while idx is not null
  loop
    if l_column_names_dict(idx) = 'not_matched'
    then
      ks_log.log('Not matched l_column_names_dict(' || idx || '):', l_scope);
      if not add_error_check_continue(p_message => 'The column "' || initcap(idx) || '", was not found in the file. Please ensure this column exists in the file.'
                       ,  p_display_location => apex_error.c_inline_in_notification
                            )
       then
        return false;
       end if;
    end if;
    idx := l_column_names_dict.next(idx);
  end loop;

  ks_log.log('after l_column_names_dict loop. Errors:' || apex_error.get_error_count, l_scope);

  if apex_error.get_error_count > 0 then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_names;




--==============================================================================
-- Function: validate_column_order
-- Purpose: validates that the columns provided in the export file are in the correct order
--
-- Inputs:  l_column_names - an array of colum names
-- Output: returns true if valid, false if invalid
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes: THIS FUNCTION IS NOT USED - the function works, but turned out to not be useful.
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
function validate_column_order (l_column_names in column_names_t)
  return boolean
is
  l_scope ks_log.scope := 'validate_column_order';
  --l_params logger.tab_param;
  l_idx number := 1;
  l_columns_in_their_order varchar2(4000);
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);

  for row in (select trim(upper(lm.header_name)) header_name,
                     display_seq
              from ks_load_mapping lm
             where 1=1
            and table_name = c_session_load_table
            and lm.to_column_name is not null
            order by lm.display_seq
            )
  loop
    if l_column_names(row.display_seq) != row.header_name
    then
      select listagg(lm.header_name, ', ') within group (order by lm.display_seq) value
        into l_columns_in_their_order
        from ks_load_mapping lm
        where 1=1
          and table_name = c_session_load_table;


        apex_error.add_error(
                  p_message => 'The columns in the export file are in an incorrect order. The proper order is: ' ||
                                  l_columns_in_their_order || '. At least this column is out of order: ' || l_column_names(l_idx)
                , p_display_location => apex_error.c_inline_in_notification
              );
      --This is a big error (lots of text), so exit here regardless of number of errors.
      return false;
    end if;

  end loop;

  return true;
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_order;



--==============================================================================
-- Procedure: init_index_map
-- Purpose: After the column names have been validated from the file,
--            we need to map which columns headers in the export go to which columns in ks_full_session_load
-- ASUMPTION(S): Column names are valid, and there aren't any missing
-- Inputs:  l_column_names - column names from the import file
--          l_cells - the final table we will create our view from.
-- Output:
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
procedure init_index_map ( l_index_map in out nocopy index_map_t)
is
  l_scope ks_log.scope := gc_scope_prefix || 'init_index_map';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);

  for row in (
    select m.to_column_name
         , m.display_seq
      from ks_load_mapping m
     where m.table_name = c_session_load_table
       and m.to_column_name is not null
     order by m.display_seq
  )
  loop
    l_index_map(to_char(row.display_seq)) := row.to_column_name;
    ks_log.log('mapped: ' || row.display_seq || ' to '  || row.to_column_name, l_scope);
  end loop;

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end init_index_map;



/**
 * Description
 * Load data from xlsx into appropriate collection for parsing. All data is
 * loaded to into the session APP_USER
 *
 * @example
 * 
 * @issue
 *
 * @author Ben Shumway (Insum Solutions)
 * @created Oct/09/2017
 * @param p_xlsx blob with all data
 */
procedure load_xlsx_data (
    p_xlsx      in blob
  , p_username  in varchar2 default v('APP_USER')
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'load_xlsx_data';

  l_column_names column_names_t;

  l_cells as_read_xlsx_clob.tp_all_cells;
  l_curr_row number;

  l_rows_row number;

  type session_load_row_t is table of ks_full_session_load%rowtype;
  l_rows session_load_row_t;

  l_curr_col varchar2(30);

  --column index for spreadsheet_content
  l_col_ind number;

  l_index_map index_map_t;
  l_index varchar2(4000);

  --used to get the first 4000 bytes of any string data
  l_substr varchar2(4000);
  --used to get the length of the string data
  l_substr_len number;

  l_string_val clob;
  l_number_val number;
  l_date_val date;

  l_reached_final_line boolean := false;

  --An array of tags
  l_tags apex_application_global.vc_arr2;
    

begin
   --logger.append_param(l_params, 'p_username', p_username);
   --logger.append_param(l_params, 'p_into_event_id', p_into_event_id);
   --logger.append_param(l_params, 'p_into_track_id', p_into_track_id);
   ks_log.log('BEGIN', l_scope);

   l_column_names := column_names_t();
   l_rows := session_load_row_t();

   select *
    bulk collect into l_cells
    from
    table(AS_READ_XLSX_CLOB.read(p_xlsx => p_xlsx))
    order by row_nr, col_nr;

   for i in 1 ..  l_cells.count
   loop
      l_curr_row := to_number(l_cells(i).row_nr);
      $IF $$VERBOSE_OUTPUT $THEN
      ks_log.log('BEGIN cell: ' ||  l_cells(i).row_nr || ',' || l_cells(i).col_nr, l_scope);
      $END

      --NOTE: Assumption, the bulk collect gets all cells in order by row then column
      if l_curr_row = 2 and l_cells(i).col_nr = '1'
      then
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('Length of l_column_names: ' || l_column_names.count, l_scope);
        $END
        if not ks_session_load_api.validate_column_names(l_column_names) then
          return;
        end if;

        --modify l_cells so that the column names are correct
        init_index_map(l_index_map);

        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('l_index_map size: ' || l_index_map.count, l_scope);
        $END
        l_index := l_index_map.first;
        while l_index is not null
        loop
          $IF $$VERBOSE_OUTPUT $THEN
          ks_log.log('l_index_map(' || l_index ||'): ' || l_index_map(l_index), l_scope);
          $END
          
          l_index := l_index_map.next(l_index);
        end loop;

      elsif l_curr_row = '1'
      then
        l_column_names.extend;
        --Get the column name (allows the .xlsx header to be defined "fuzzilly"
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('Adding name: ' || l_cells(i).string_val, l_scope);
        $END
        l_column_names(i) := trim(upper(cast(l_cells(i).string_val as varchar2)));
     end if;

     $IF $$VERBOSE_OUTPUT $THEN
     ks_log.log('i: ' || i, l_scope);
     $END

     if l_curr_row > 1 then
        if l_rows.count < l_curr_row -1
        then
          if l_reached_final_line
          then
            l_rows.delete(l_rows.count);
            exit;
          else
            l_reached_final_line := true; --Considered true until proven otherwise
          end if;
          l_rows.extend;
        end if;

        -- l_string_val := coalesce(l_cells(i).string_val, to_char(l_cells(i).number_val), to_char(l_cells(i).date_val));

        l_string_val := trim(l_cells(i).string_val);
        l_number_val := l_cells(i).number_val;
        l_date_val := l_cells(i).date_val;

        l_rows_row := l_curr_row -1;

        if   l_string_val is not null
          or l_number_val is not null
          or l_date_val is not null
        then
          l_reached_final_line := false;
        end if;
        
        if l_number_val is not null
        then
          l_string_val := to_char(l_number_val);
        end if;


        --The commented out code shows when the as_read_xlsx_clob package skips cells
        /*ks_log.log('Checking existence of: ' || to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end) || ', l_cells(i).col_nr: ' || l_cells(i).col_nr 
                                                                       || ', string_val: ' || l_cells(i).string_val );
        l_index := to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end);*/
        l_index := l_cells(i).col_nr;                                                  
        if l_index_map.exists(l_index)
        then
          l_curr_col := l_index_map(l_index);
          $IF $$VERBOSE_OUTPUT $THEN
          ks_log.log('l_curr_col: ' || l_curr_col, l_scope);
          $END
          
          if l_curr_col = 'EXTERNAL_SYS_REF'
          then            
            l_rows(l_rows_row).external_sys_ref := l_string_val;
          elsif l_curr_col = 'SESSION_NUM'
          then
            l_rows(l_rows_row).session_num :=  l_string_val;
          elsif l_curr_col = 'EVENT_TRACK_ID'
          then
            l_rows(l_rows_row).event_track_id := l_string_val;
          elsif l_curr_col = 'SUB_CATEGORY'
          then
            l_rows(l_rows_row).sub_category := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_TYPE'
          then
            l_rows(l_rows_row).session_type := substr(l_string_val,1,500);
          elsif l_curr_col = 'TITLE'
          then
            l_rows(l_rows_row).title := substr(l_string_val,1,500);
          elsif l_curr_col = 'ACE_LEVEL'
          then
            l_rows(l_rows_row).ace_level := substr(l_string_val,1,30);
          elsif l_curr_col = 'COMPANY'
          then
            l_rows(l_rows_row).company := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_ABSTRACT'
          then
            l_rows(l_rows_row).session_abstract := l_string_val;
          elsif l_curr_col = 'SESSION_SUMMARY'
          then
            l_rows(l_rows_row).session_summary := substr(l_string_val,1,4000);
          elsif l_curr_col = 'TARGET_AUDIENCE'
          then
            l_rows(l_rows_row).target_audience := substr(l_string_val,1,60);
          elsif l_curr_col = 'TECHNOLOGY_PRODUCT'
          then
            l_rows(l_rows_row).technology_product := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTED_BEFORE_IND'
          then
            l_rows(l_rows_row).presented_before_ind := l_string_val;
          elsif l_curr_col = 'PRESENTED_BEFORE_WHERE'
          then
            l_rows(l_rows_row).presented_before_where := substr(l_string_val,1,4000);
          elsif l_curr_col = 'VIDEO_LINK'
          then
            l_rows(l_rows_row).video_link := substr(l_string_val,1,4000);
          elsif l_curr_col = 'CO_PRESENTER'
          then
            l_rows(l_rows_row).co_presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_COMPANY'
          then
            l_rows(l_rows_row).co_presenter_company := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTER_BIOGRAPHY'
          then
            l_rows(l_rows_row).presenter_biography := l_string_val;
          elsif l_curr_col = 'PRESENTER'
          then
            l_rows(l_rows_row).presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'TAGS'
          then
            l_tags := apex_util.string_to_table(l_string_val,',');
            for i in 1..l_tags.count
            loop
              l_tags(i) := trim(l_tags(i));
            end loop;
            l_rows(l_rows_row).tags := substr(apex_util.table_to_string(l_tags,':'),1,1000);
          elsif l_curr_col = 'CONTAINS_DEMO_IND'
          then
            l_rows(l_rows_row).contains_demo_ind := l_string_val;
          elsif l_curr_col = 'WEBINAR_WILLING_IND'
          then
            l_rows(l_rows_row).webinar_willing_ind := l_string_val;
          elsif l_curr_col = 'PRESENTER_EMAIL'
          then
            l_rows(l_rows_row).presenter_email := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).co_presenter_user_id := case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).presenter_user_id :=  case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'SUBMISSION_DATE'
          then
            -- l_rows(l_rows_row).submission_date := to_date(l_string_val, 'DD/MM/RR HH24:MI');
            l_rows(l_rows_row).submission_date := l_date_val;
          end if;

        end if;
      end if;
    end loop;


    ks_log.log('Removing previous load data (if present)', l_scope);
    delete 
      from ks_full_session_load s
     where app_user = p_username;


    ks_log.log('Inserting into ks_full_session_load', l_scope);
    forall i in l_rows.first .. l_rows.last
      insert into ks_full_session_load (
          app_user
        , external_sys_ref
        , session_num
        , event_track_id
        , sub_category
        , session_type
        , title
        , ace_level
        , presented_before_ind
        , presented_before_where
        , video_link
        , co_presenter
        , co_presenter_company
        , presenter_biography
        , company
        , presenter
        , session_abstract
        , session_summary
        , tags
        , target_audience
        , technology_product
        , contains_demo_ind
        , webinar_willing_ind
        , presenter_email
        , co_presenter_user_id
        , presenter_user_id
        , submission_date
      )
      values (
          p_username
        , l_rows(i).external_sys_ref
        , l_rows(i).session_num
        , l_rows(i).event_track_id
        , l_rows(i).sub_category
        , l_rows(i).session_type
        , l_rows(i).title
        , l_rows(i).ace_level
        , l_rows(i).presented_before_ind
        , l_rows(i).presented_before_where
        , l_rows(i).video_link
        , l_rows(i).co_presenter
        , l_rows(i).co_presenter_company
        , l_rows(i).presenter_biography
        , l_rows(i).company
        , l_rows(i).presenter
        , l_rows(i).session_abstract
        , l_rows(i).session_summary
        , l_rows(i).tags
        , l_rows(i).target_audience
        , l_rows(i).technology_product
        , l_rows(i).contains_demo_ind
        , l_rows(i).webinar_willing_ind
        , l_rows(i).presenter_email
        , l_rows(i).co_presenter_user_id
        , l_rows(i).presenter_user_id
        , l_rows(i).submission_date
      );

  ks_log.log('END', l_scope);

end load_xlsx_data;



/**
 * Description
 *
 *
 * @example
 *  ks_session_load_api.load_sessions(
 *      p_event_id   => :P5040_EVENT_ID
 *    , x_load_count => :P5041_ROW_COUNT
 *  );
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created January 6, 2018
 * @param p_event_id
 * @param p_username (optional)
 * @param x_load_count - final load count
 * @return
 */
procedure load_sessions (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
  , x_load_count in out number
)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'load_sessions';
begin
  ks_log.log('BEGIN', l_scope);

  insert into ks_sessions(
      event_id
    , event_track_id
    , external_sys_ref
    , session_num
    , sub_category
    , session_type
    , title
    , presenter
    , company
    , co_presenter
    , co_presenter_company
    , tags
    , presenter_email
    , session_abstract
    , session_summary
    , target_audience
    , presented_before_ind
    , presented_before_where
    , technology_product
    , ace_level
    , video_link        
    , contains_demo_ind
    , webinar_willing_ind
    , presenter_biography
    , co_presenter_user_id
    , presenter_user_id
    , submission_date
   )            
  select p_event_id
       , e.id
       , s.external_sys_ref
       , s.session_num
       , s.sub_category
       , s.session_type
       , s.title
       , s.presenter
       , s.company
       , s.co_presenter
       , s.co_presenter_company
       , s.tags
       , s.presenter_email
       , s.session_abstract
       , s.session_summary
       , s.target_audience
       , decode(trim(lower(s.presented_before_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presented_before_where
       , s.technology_product        
       , s.ace_level
       , s.video_link        
       , decode(trim(lower(s.contains_demo_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , decode(trim(lower(s.webinar_willing_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presenter_biography
       , co_presenter_user_id
       , presenter_user_id
       , coalesce(submission_date, sysdate)
    from ks_full_session_load s
         left outer join ks_event_tracks e on s.event_track_id = e.name and e.event_id = p_event_id
   where s.app_user = p_username;
      
  x_load_count := SQL%ROWCOUNT;

  ks_log.log('END', l_scope);

  exception
    when OTHERS then
      ks_log.log_error('Unhandled Exception', l_scope);
      raise;
end load_sessions;






/**
 * Process to purge votes, sessions and tags from and event and/or track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 25, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_votes_only_ind to specify that only votes should be deleted.
 * @param p_force_ind to force the execution of the process even when votes
 *                    are present.
 */
procedure purge_event(
  p_event_id          in ks_sessions.event_id%TYPE
  , p_track_id        in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind  in varchar2
  , p_force_ind       in varchar2
)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'purge_event';

  no_action exception;

  l_votes_count number := 0;

begin
  ks_log.log('BEGIN', l_scope);

  -- This count is for pretection.
  -- We don't want to delete when there are votes present.
  select count(1)
    into l_votes_count
    from ks_session_votes v
       , ks_sessions s
   where v.session_id = s.id
     and s.event_id = p_event_id
     and (p_track_id is null or s.event_track_id = p_track_id)
     and p_votes_only_ind = 'N';


  if l_votes_count > 0 then
    -- if this parameter equals No 'N' then the process raises an error indicating no action will be done.
    raise no_action;
  end if;


  -- Delete the votes when the user selects "Votes Only" or "Force Purge"
  delete 
    from ks_session_votes v
   where v.session_id in (
      select ss.id
        from ks_sessions ss
       where ss.event_id = p_event_id
         and (p_track_id is null or ss.event_track_id = p_track_id)
   )
     and (p_votes_only_ind = 'Y' or p_force_ind = 'Y');


  -- Only delete sessions when the there are no votes and user selected Votes Only
  -- OR 
  -- Delete when user selected "Force Purge"
  delete
    from ks_sessions
   where event_id = p_event_id
     and (p_track_id is null or event_track_id = p_track_id)
     and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
         or p_force_ind = 'Y'
       );


  -- Remove unused tags after the "delete ks_sessions"
  --   When the there are no votes and user selected Votes Only
  --   OR 
  --   Delete when user selected "Force Purge"
  delete
    from ks_tag_type_sums ts
   where exists (
    select 1
     from ks_tag_type_sums s
        , ks_event_tracks t
    where s.content_type = 'SESSION' || ':' || t.id
      and s.tag_count = 0
      and s.rowid = ts.rowid
      and t.event_id = p_event_id
      and (p_track_id is null or t.id = p_track_id)
   )
    and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
        or p_force_ind = 'Y'
      );

  ks_log.log('END', l_scope);

  exception
    when no_action then
      raise_application_error (-20000,'Votes are present. Purge action aborted.');
    
end purge_event;



end ks_session_load_api;
/
-- @../plsql/ks_log.plb
alter session set PLSQL_CCFLAGS='LOGGER:FALSE';
create or replace package body ks_log
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';



------------------------------------------------------------------------------
/**
 * Description
 *
 *
 * @example
 *
 * @issue
 *
 * @author Jorge Rimblas
 * @created October 11, 2017
 * @param
 * @return
 */
procedure log(p_msg in varchar2, p_scope  in varchar2)
is
begin

  $IF $$LOGGER $THEN
  logger.log(p_msg, p_scope);
  $ELSE
  apex_debug.message(p_scope || ':' || substr(p_msg,1,3000));
  $END

end log;


procedure log_error(p_msg in varchar2, p_scope  in varchar2)
is
begin

  $IF $$LOGGER $THEN
  logger.log_error(p_msg, p_scope);
  $ELSE
  apex_debug.message(p_scope || ': ' || p_msg);
  $END

end log_error;




end ks_log;
/
-- @../plsql/ks_util.plb
create or replace package body ks_util
as

--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';


--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2
is
  l_value ks_parameters.value%TYPE;
begin

  select value
    into l_value
    from ks_parameters
   where name_key = p_name_key;

  return l_value;

exception
  when NO_DATA_FOUND then
    return null;

end get_param;



--------------------------------------------------------------------------------
procedure set_param(
    p_name_key      in ks_parameters.name_key%TYPE
  , p_value         in ks_parameters.value%TYPE
)
is
begin

  update ks_parameters
     set value = p_value
   where name_key = p_name_key;

  if sql%rowcount = 0 then
    raise_application_error(
        -20001
      , 'Parameter ' || p_name_key || ' does not exist.'
    );
  end if;

end set_param;


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2
is
  -- l_scope   logger_logs.scope%type := gc_scope_prefix || 'get_email';
  -- l_params  logger.tab_param;

  l_email ks_users.email%TYPE;
begin
  -- logger.append_param(l_params, 'p_username', p_username);
  -- logger.log('START', l_scope, null, l_params);

  select email
    into l_email
    from ks_users
   where username = p_username;

  return l_email;

exception
  when NO_DATA_FOUND then
    -- logger.log_error('Probably an invalid user.');
    return null;

end get_email;




function format_full_name
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2
IS
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'format_full_name';
  -- l_params logger.tab_param;
begin
--  logger.append_param(l_params, 'p_text', p_text);

  RETURN rtrim(p_first_name || ' ' || p_last_name);

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end format_full_name;






function is_number
(
  p_value        in         varchar2
) return boolean
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'is_number';
  -- l_params            logger.tab_param;

  non_numeric      exception;
  pragma exception_init (non_numeric, -06502);

  l_number     number;
begin
   l_number := p_value;

   return true;

exception
  when non_numeric then
    return false;
end is_number;





function string_to_coll (p_string in VARCHAR2) return sys.ODCIVarchar2List
is
  l_table wwv_flow_global.vc_arr2;
  l_list  sys.ODCIVarchar2List := new sys.ODCIVarchar2List();
begin
  l_table := apex_util.string_to_table(p_string);
  l_list.extend(l_table.count());
  for i in 1..l_table.count()
  loop
    l_list(i) := l_table(i);
  end loop;
  return l_list;
end string_to_coll;




function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         )
  return varchar2
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_order_by';
  -- l_params            logger.tab_param;

  l_order_by          varchar2(32000);
  l_instr             number;
begin
  -- logger.log('START', l_scope, null, l_params);

  l_instr := instr (p_ir_query, 'order by', -1);

  if l_instr > 0
  then
     -- grab the final order by from the IR query and trim off any trailing ")"
     l_order_by := rtrim (substr (p_ir_query, l_instr), ')');

  else -- add default order by for use by analytics lead/gag functions
    l_order_by := 'order by ' || p_default_pk; -- Use a column that's always present
  end if;

  -- logger.log('order by:' || l_order_by, l_scope, null, l_params);
  return l_order_by;

exception
  when others then
    null;
end get_ir_order_by;





function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_report';
  -- l_params            logger.tab_param;

  l_region_id          number;
begin
  -- logger.append_param(l_params, 'p_page_id', p_page_id);
  -- logger.append_param(l_params, 'p_static_id', p_static_id);
  -- logger.log('START', l_scope, null, l_params);

  select region_id
    into l_region_id
    from apex_application_page_regions
   where static_id = p_static_id
     and page_id   = p_page_id
     and application_id = (select v('APP_ID') from dual);

  return apex_ir.get_report
         (
            p_page_id   => p_page_id
          , p_region_id => l_region_id
         );

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end get_ir_report;


/**
  * Converts blob to clob
  *
  * Notes:
  *  - Copied from OOS Utils https://github.com/OraOpenSource/oos-utils/blob/master/source/packages/oos_util_lob.pkb
  *
  */
 function blob2clob(
   p_blob in blob,
   p_blob_csid in integer default dbms_lob.default_csid)
   return clob
 as
   l_clob clob;
   l_dest_offset integer := 1;
   l_src_offset integer := 1;
   l_lang_context integer := dbms_lob.default_lang_ctx;
   l_warning integer;
 begin
   if p_blob is null then
     return null;
   end if;

   dbms_lob.createtemporary(
     lob_loc => l_clob,
     cache => false);

   dbms_lob.converttoclob(
     dest_lob => l_clob,
     src_blob => p_blob,
     amount => dbms_lob.lobmaxsize,
     dest_offset => l_dest_offset,
     src_offset => l_src_offset,
     blob_csid => p_blob_csid,
     lang_context => l_lang_context,
     warning => l_warning);

   return l_clob;
 end blob2clob;



--==============================================================================
-- Function: clob_to_varchar2_table
-- Purpose: takes a clob and returns it as a table of varchar2s with size 4000
--
-- Inputs:  p_clob - the clob to be passed in
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:  Some of this code taken from https://stackoverflow.com/questions/11647041/reading-clob-line-by-line-with-pl-sql
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function clob_to_varchar2_table (p_clob in out nocopy clob)
  return gc_clob_arr_type
is
  l_scope varchar2(255) := gc_scope_prefix || 'clob_to_varchar2_table';
  l_varchar2s gc_clob_arr_type;
  l_varchar2 varchar2(4000);
  l_offset number := 1;
  l_amount number := 3000;
  len    number;
  i number := 1;
begin

  ks_log.log('START', l_scope);

  l_varchar2s := gc_clob_arr_type();

  if p_clob is null
  then
    return l_varchar2s;
  end if;

  if ( dbms_lob.isopen(p_clob) != 1 ) then
    dbms_lob.open(p_clob,0);
  end if;

  len := dbms_lob.getlength(p_clob);

  while(l_offset < len)
  loop
    -- ks_log.log('inside main loop "while(l_offset < len)"', l_scope);
    dbms_lob.read(p_clob, l_amount, l_offset, l_varchar2);
    l_offset := l_offset + l_amount;
    l_varchar2s.extend;
    -- ks_log.log('len: ' || len || ', l_offset: ' || l_offset || ', l_varchar2: ' || l_varchar2, 'l_scope');
    l_varchar2s(i) := l_varchar2;
    i := i + 1;
  end loop;

  if ( dbms_lob.isopen(p_clob) = 1 ) then
    dbms_lob.close(p_clob);
  end if;


  return l_varchar2s;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  clob_to_varchar2_table;


--==============================================================================
-- Function: tokenize_string
-- Purpose: helper function for html_whitelist_tokenize
--
-- Inputs:  p_string - the to have its tokens replaced
--          p_tokens - a string containing the tokens
-- Output:
-- Scope: Publicly accessible
-- Errors: logged and raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/27/2017
--==============================================================================
function replace_tokens (p_string in varchar2,
                         p_tokens in varchar2,
                         p_token_exceptions in varchar2)
 return varchar2
is
  l_scope varchar2(255) := gc_scope_prefix || 'tokenize_string';

  l_output         varchar2(32767);
  l_tokens_table   apex_application_global.vc_arr2;
  l_tokens         varchar2(4000);
  found_match      boolean := true;
  l_index          number := -1;
  l_regex          varchar2(4000);  
  l_infinite_check number := 0;
begin
  -- ks_log.log('BEGIN', l_scope);
  -- ks_log.log(p_tokens, l_scope);

  if trim(p_tokens) is null
  then
    return p_string;
  end if;


  --Cleanse p_tokens so that it only contains alphanumeric characters.
  --Get rid of all non-alphanumerics
  l_tokens := regexp_replace(p_tokens, '[^A-Za-z0-9]', ' ');
  --Remove from tokens the token exceptions
  l_tokens := regexp_replace(l_tokens, p_token_exceptions, '', 1, 0, 'i');
  --Get rid of all multiple spaces so that everything is only one space apart
  l_tokens := regexp_replace(l_tokens, '\s{2,}', ' ');
  
  l_tokens := trim(l_tokens);
  --Replace spaces with |
  l_tokens := regexp_replace(l_tokens, '\s', '|');

  -- ks_log.log(l_tokens, l_scope);

  --I wanted to use something like the oneliner below, but pl/sql doesn't support lookaheads (yet)
  --l_output := regexp_replace(p_string, '(\W)('|| l_tokens || ')(?=\W)', '\1XXXX', 1, 0, 'i');
  

  l_regex := '(^|\W)(' || l_tokens || ')(\W|$)';
  --ks_log.log('l_regex:' || l_regex, l_scope);


  l_output := p_string;
  --ks_log.log(l_output, l_scope);

  while(l_index != 0)
  loop
    
    l_index  := regexp_instr(l_output, l_regex, 1, 1, 0, 'i');

    if(l_index != 0)
    then
      --ks_log.log('Found match at index ' || l_index, l_scope);
      l_output := regexp_replace(l_output, l_regex, '\1\3', l_index, 1, 'i');

    end if;

    l_infinite_check := l_infinite_check + 1;
    if l_infinite_check > 9999
    then
      --Something's gone wrong
      raise_application_error(-20001, 'Error Tokenizing Data');
    end if;

  end loop;

  ks_log.log('> ' || l_output, l_scope);

  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end replace_tokens;






end ks_util;
/
-- @../plsql/ks_session_api.plb
create or replace package body ks_session_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 * @constant gc_html_whitelist_tags a list of strings to NOT escape from. Same as the apex version but includes span and em
 * @constant gc_token_exceptions is a "|" separated list that gets passed into ks_util. It contains the tokens which we want to ommit from escaping.
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

gc_html_whitelist_tags constant varchar2(500) := '<h1>,</h1>,<h2>,</h2>,<h3>,</h3>,<h4>,</h4>,<p>,<span>,</span>,</p>,<b>,</b>,<strong>,</strong>,<i>,</i>,<ul>,</ul>,<ol>,</ol>,<li>,</li>,<br />,<hr/>,<em>,</em>';
gc_token_exceptions constant varchar2(4000) := 'oracle|apex|epm|and|its|it|of';
gc_parameter_tokens_name constant ks_parameters.name_key%type := 'ANONYMIZE_EXTRA_TOKENS';


------------------------------------------------------------------------------
/**
 * Description
 *  Output of the form:
 *    apex_json.open_object;
 *    apex_json.write('presenter', p_presenter);
 *    apex_json.write('trackList', '<ul><li>Track 1</li></ul>');
 *    apex_json.close_object;
 *
 * @example
 *
 * @issue
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param p_event_id
 * @param p_presenter
 * @return
 */
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter in ks_sessions.presenter%TYPE)
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'presenter_tracks_json';
  -- l_params logger.tab_param;

  list_cur sys_refcursor;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter', p_presenter);
  -- logger.log('BEGIN', l_scope, null, l_params);

  open list_cur for
    select p_presenter "presenter"
         , '<ul><li>' ||listagg(n || ' in ' || p || ' (' || status || ')', '</li><li>') within group (order by display_seq) || '</li></ul>' "trackList"
    from (
      select t.display_seq, nvl(t.alias, t.name) p, count(*) n
           , listagg(nvl(st.name, '?'), ',') within group (order by st.display_seq) status
        from ks_event_tracks t
           , ks_sessions s
           , ks_session_status st
       where t.id = s.event_track_id
         and s.event_id = to_number(p_event_id)
         and s.presenter = p_presenter
         and s.status_code = st.code (+)
       group by t.display_seq, nvl(t.alias, t.name)
    );

  apex_json.write(list_cur);

  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    apex_json.open_array;
    apex_json.open_object;
    apex_json.write('presenter', p_presenter);
    apex_json.write('trackList', 'Unable to fetch list:<br>' || sqlerrm || '<br>');
    apex_json.close_object;
    apex_json.close_array;
end presenter_tracks_json;






/**
 * Switch votes and voting role of an user for a selected event / track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 26, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_username username of the user.
 * @param p_voting_role selected voting role for the user.
 */
procedure switch_votes (
  p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username    in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
)
is

begin

  -- Move all votes to new vote_type
  update ks_session_votes
     set vote_type = p_voting_role
   where id in (
      select sv.id
        from ks_session_votes sv
           , ks_sessions s
       where sv.username = p_username
         and s.event_id = p_event_id
         and s.event_track_id = p_track_id
         and sv.session_id = s.id);

  update ks_user_event_track_roles
     set voting_role_code = p_voting_role
   where username = p_username
     and event_track_id = p_track_id;

end switch_votes;







--==============================================================================
-- Function: html_whitelist_clob
-- Purpose: returns a varchar2 where every chunk of 4000 characters has been html_whitelisted and tokenized
--
-- Inputs:  p_string - the clob or varchar2 to be escaped/tokenized
--          p_session_id - the session id. We use this to get the name of the presenter/company/co-presenter
--          p_anonymize - whether to hide the info
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N',
                                  p_escape_html in varchar2 default 'Y')
  return varchar2
is
  l_scope ks_log.scope := gc_scope_prefix || 'html_whitelist_tokenize';

  l_output varchar2(32767);

  l_presenter    ks_sessions.presenter%type;
  l_co_presenter ks_sessions.co_presenter%type;
  l_company      ks_sessions.company%type;
begin
  ks_log.log('START', l_scope);

  --The id is usually null when the user's session got reset
  --We don't want to create an ugly error on top of the page already showing errors
  --So silently exit.
  if p_session_id is null then
    return '';
  end if;

  if p_escape_html = 'Y' then
    l_output := apex_escape.html_whitelist(p_string, gc_html_whitelist_tags);
  else
    l_output := p_string;
  end if;
  l_output := regexp_replace(l_output, '_x000D_', '', 1, 0, 'i');

  if p_anonymize = 'Y' then
    select s.presenter, s.company, s.co_presenter
      into l_presenter, l_company, l_co_presenter
      from ks_sessions s
     where s.id = p_session_id;

     l_output := ks_util.replace_tokens(l_output 
                                      , l_presenter || ' ' || l_company || ' ' || l_co_presenter ||' ' || ks_util.get_param(gc_parameter_tokens_name)
                                      , gc_token_exceptions);


  end if;



  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  html_whitelist_tokenize;


end ks_session_api;
/

-- @../install/ks_tags_post_install.sql
--------------------------------------------------------
-- Replace previosul trigger
create or replace trigger ks_sessions_iu_trg 
before insert or update
on ks_sessions
referencing old as old new as new
for each row
begin
  if updating then
    :new.updated_on := sysdate;
    :new.updated_by := coalesce(
                          sys_context('APEX$SESSION','app_user')
                        , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                        , sys_context('userenv','session_user')
                       );
  end if;

  if   inserting
    or (updating and :new.event_track_id = :old.event_track_id)
  then 
    ks_tags_api.tag_sync(
        p_new_tags      => :new.tags
      , p_old_tags      => :old.tags
      , p_content_type  => 'SESSION' || ':' || :new.event_track_id
      , p_content_id    => :new.session_num );
      
  else --We are updating AND our event_track_id changed
    ks_tags_api.tag_sync(
        p_new_tags      => null
      , p_old_tags      => :old.tags
      , p_content_type  => 'SESSION' || ':' || :old.event_track_id
      , p_content_id    => :new.session_num );

    ks_tags_api.tag_sync(
        p_new_tags      => :new.tags
      , p_old_tags      => null
      , p_content_type  => 'SESSION' || ':' || :new.event_track_id
      , p_content_id    => :new.session_num );

  end if;

end;
/

create or replace trigger ks_sessions_bd_trg
    before delete on ks_sessions
    for each row
begin
  ks_tags_api.tag_sync(
      p_new_tags      => null
    , p_old_tags      => :old.tags
    , p_content_type  => 'SESSION' || ':' || :old.event_track_id
    , p_content_id    => :old.session_num );
end;
/
-- ========================================


