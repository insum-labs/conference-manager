-- =============================================================================
-- ==========================  Full _release.sql file
-- =============================================================================
PRO Installing 4.0.0 (Kscope20)

--  sqlblanklines - Allows for SQL statements to have blank lines
set sqlblanklines on
--  define - Sets the character used to prefix substitution variables
set define '^'


PRO _________________________________________________
PRO . TABLES and DDL

-- #2
-- @../install/ks_event_communities.sql
PRO .. ks_event_communities 

-- drop table ks_event_communities cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_communities (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , event_id        number        not null
  , name            varchar2(60)  not null
  , created_by      varchar2(60) default
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_event_communities_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
)
enable primary key using index
/

comment on table ks_event_communities is 'List of Communities';

comment on column ks_event_communities.id is 'Primary Key ID';
comment on column ks_event_communities.created_by is 'User that created this record';
comment on column ks_event_communities.created_on is 'Date the record was first created';
comment on column ks_event_communities.updated_by is 'User that last modified this record';
comment on column ks_event_communities.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_communities_u_trg
before update
on ks_event_communities
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/
-- @../install/ks_event_community_tracks.sql
PRO .. ks_event_community_tracks 

-- drop table ks_event_community_tracks cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_community_tracks (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , community_id    number        not null
  , track_id        number        not null
  , created_by      varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_community_tracks_fk foreign key ( community_id ) references ks_event_communities ( id ) not deferrable
  , constraint ks_event_community_tracks_fk foreign key ( track_id ) references ks_event_tracks ( id ) not deferrable
)
enable primary key using index
/

create unique index ks_event_community_tracks_u01 on ks_event_community_tracks(community_id, track_id);

comment on table ks_event_community_tracks is 'List of tracks in a community';

comment on column ks_event_community_tracks.id is 'Primary Key ID';
comment on column ks_event_community_tracks.created_by is 'User that created this record';
comment on column ks_event_community_tracks.created_on is 'Date the record was first created';
comment on column ks_event_community_tracks.updated_by is 'User that last modified this record';
comment on column ks_event_community_tracks.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_community_track_u_trg
before update
on ks_event_community_tracks
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/

-- #42
alter table ks_sessions add ranking number;
comment on column ks_sessions.ranking is 'Used to specify the rank for a group of sessions.';


-- #36
create index ks_users_i01
  on ks_users(external_sys_ref)
/

-- @../install/ks_event_comp_users.sql
PRO .. ks_event_comp_users 

-- drop table ks_event_comp_users cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_comp_users (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , event_id        number        not null
  , user_id         number        not null
  , reason          varchar2(250)
  , created_by      varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_event_comp_user_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
  , constraint ks_event_comp_users_fk foreign key ( user_id ) references ks_users ( id ) not deferrable
)
enable primary key using index
/

comment on table ks_event_comp_users is 'Users with attendance comps for the event';

comment on column ks_event_comp_users.id is 'Primary Key ID';
comment on column ks_event_comp_users.event_id is 'Event for which the user is comped';
comment on column ks_event_comp_users.user_id is 'User begin comped';
comment on column ks_event_comp_users.reason is 'Reason or information for comped';
comment on column ks_event_comp_users.created_by is 'User that created this record';
comment on column ks_event_comp_users.created_on is 'Date the record was first created';
comment on column ks_event_comp_users.updated_by is 'User that last modified this record';
comment on column ks_event_comp_users.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_comp_users_u_trg
before update
on ks_event_comp_users
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/


-- 
PRO .. Allow multi-byte chars for tags
-- alter table ks_tags modify tag varchar2(255);
-- alter table ks_tag_sums modify tag varchar2(255);
-- alter table ks_tag_type_sums modify tag varchar2(255);


-- #44
PRO .. Session Length
alter table ks_full_session_load add session_length varchar2(500);
alter table ks_sessions add session_length varchar2(500);



PRO _________________________________________________
PRO . VIEW

-- @../views/ks_sessions_v.sql

PRO ks_sessions_v
create or replace view ks_sessions_v
as
with totals as (
  select d.session_id
       , sum(d.vote) votes_total
       , avg(d.vote) votes_average
   from ks_session_votes d
  group by d.session_id
)
select  s.id
      , s.event_id
      , s.event_track_id
      , s.session_num
      , s.sub_category
      , s.session_type
      , s.title
      , s.presenter
      , s.company
      , s.co_presenter
      , s.status_code
      , s.notes
      , s.tags      
      , t.votes_total
      , t.votes_average
      , s.presenter_email
      , s.session_summary
      , s.session_abstract
      , s.target_audience
      , s.presented_before_ind
      , s.presented_before_where
      , s.technology_product
      , s.ace_level
      , s.video_link
      , trim (
        case
        when instr (s.video_link, 'http') > 0 
        then
          substr (
             s.video_link
            ,instr (s.video_link, 'http')
            ,case 
              when instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1) < instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1)
                then instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1)
              when instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1) > instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1)
                then instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1) - 1
                else length (s.video_link)
            end
          )
        else null
        end
      ) as first_video_link
      , s.contains_demo_ind
      , s.webinar_willing_ind
      , s.external_sys_ref
      , s.presenter_user_id
      , s.co_presenter_user_id
      , s.presenter_biography
      , s.co_presenter_company
      , s.submission_date
      , s.room_size_code
      , s.presented_anything_ind
      , s.presented_anything_where
      , s.ranking
      , s.created_by
      , s.created_on
      , s.updated_by
      , s.updated_on
  from ks_sessions s
     , totals t
 where s.id = t.session_id (+)
/
-- @../views/ks_users_v.sql
PRO ks_users_v
create or replace view ks_users_v
as
select u.id
     , u.username
     , u.password
     , u.first_name
     , u.last_name
     , u.first_name || nvl2(u.last_name, ' ' || u.last_name, '') full_name
     , u.first_name || nvl2(u.last_name, ' ' || u.last_name, '')  || nvl2(u.first_name || u.last_name, ' (','') || u.username || nvl2(u.first_name || u.last_name, ')','') full_name_extended
     , u.email
     , u.active_ind
     , u.admin_ind
     , u.external_sys_ref
     , u.expired_passwd_flag
     , u.login_attempts
     , u.last_login_date
     , u.created_by
     , u.created_on
     , u.updated_by
     , u.updated_on
  from ks_users u
/

-- #2
-- @../views/ks_events_communities_v.sql
PRO ks_events_communities_v
create or replace force view ks_events_communities_v
as
select e.id event_id
     , c.id event_community_id
     , c.name community_name
     , e.name event_name
     , e.begin_date begin_date
     , e.active_ind event_active_ind
     , (
         select listagg( t.name, ', ') within group (order by t.display_seq)
           from ks_event_community_tracks ct join ks_event_tracks t on (ct.track_id = t.id and t.event_id = e.id)
          where ct.community_id =  c.id
       ) track_list
from ks_events e
join ks_event_communities c on ( c.event_id = e.id)
/
-- @../views/ks_events_communities_tracks_v.sql
PRO ks_events_communities_tracks_v
create or replace force editionable view ks_events_communities_tracks_v
as
  select e.id event_id
       , c.id event_community_id
       , c.name community_name
       , e.name event_name
       , e.begin_date begin_date
       , e.active_ind event_active_ind
       , ct.id community_track_id
       , ct.track_id
       , et.display_seq track_display_seq
       , et.name track_name
       , et.alias track_alias
       , et.active_ind track_active_ind
       , et.max_sessions
       , et.max_comps
  from ks_events e
  join ks_event_communities c on ( c.event_id = e.id)
  join ks_event_community_tracks ct on (c.id = ct.community_id)
  join ks_event_tracks et on (ct.track_id = et.id)
/




PRO _________________________________________________
PRO . PACKAGES

-- #35
-- @../plsql/ks_notification_api.pls
create or replace package ks_notification_api
is

-- TYPES
type t_WordList is table of varchar2(32000) index by varchar(30);


-- CONSTANTS
g_blank_sub_strings t_WordList; -- Leave blank
------------------------------------------------------------------------------
procedure fetch_user_substitions (
  p_id in ks_users.id%type
 ,p_substrings in out nocopy t_WordList
);

procedure send_email (
   p_to in varchar2 default null
  ,p_from in varchar2
  ,p_cc in varchar2 default null
  ,p_bcc in varchar2 default null
  ,p_subject in varchar2
  ,p_body in clob
  ,p_body_html in clob default null
  ,p_template_name in varchar2 default null
  ,p_substrings in t_WordList default g_blank_sub_strings
);

procedure notify_track_session_load (
    p_notify_owner in varchar2
  , p_notify_voter in varchar2
);

procedure notify_reset_pwd_request (
    p_id in ks_users.id%type
   ,p_password in ks_users.password%type
   ,p_app_id in ks_parameters.value%type
);

procedure notify_reset_pwd_done (
    p_id in ks_users.id%type
);

procedure notify_session_move (
    p_id in ks_sessions.id%type
   ,p_event_track_id in ks_sessions.event_track_id%type
   ,p_old_event_track_id in ks_sessions.event_track_id%type
   ,p_notify_owners_ind in varchar2
   ,p_notify_voters_ind in varchar2
);

end ks_notification_api;
/
-- @../plsql/ks_notification_api.plb
set define off
create or replace package body ks_notification_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';
-- gc_template_load_notif constant ks_parameters.name_key%type := 'LOAD_NOTIFICATION_TEMPLATE';


------------------------------------------------------------------------------
/**
 * Get ready all the parameters to notify by email.
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param
 */
function replace_substr_template (
   p_template_name in varchar2
  ,p_substrings in t_WordList default g_blank_sub_strings
)
return clob
is
  l_scope ks_log.scope := gc_scope_prefix || 'replace_substr_template';

  l_msg clob;
  l_key varchar(30);
  l_substring varchar2(32000);
begin
  ks_log.log('BEGIN', l_scope);

  select  t.template_text
  into    l_msg
  from    ks_email_templates t
  where   t.name = p_template_name;

  l_key := p_substrings.first;

  while (l_key is not null)
  loop
    l_msg := replace (l_msg, '#' || upper (l_key) || '#', p_substrings(l_key) );
    l_key := p_substrings.next(l_key);
  end loop;

  ks_log.log('l_msg:' || l_msg, l_scope);
  ks_log.log('END', l_scope);
  return l_msg;
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end replace_substr_template;




/**
 * Populate all the substrings available for a given user so they can be used in
 * a template
 *
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 10, 2018
 * @param p_id `ks_users.id`
 * @param p_substrings `t_WordList`
 */
procedure fetch_user_substitions (
  p_id in ks_users.id%type
 ,p_substrings in out nocopy t_WordList
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'fetch_user_substitions';
begin
  ks_log.log('BEGIN', l_scope);

  select  u.id
         ,u.username
         ,u.first_name
         ,u.last_name
         ,u.full_name
         ,u.email
         ,u.active_ind
         ,u.admin_ind
         ,u.external_sys_ref
         ,u.expired_passwd_flag
         ,u.login_attempts
         ,u.last_login_date
  into    p_substrings ('USER_ID')
         ,p_substrings ('USERNAME')
         ,p_substrings ('USER_FIRST_NAME')
         ,p_substrings ('USER_LAST_NAME')
         ,p_substrings ('USER_FULL_NAME')
         ,p_substrings ('USER_EMAIL')
         ,p_substrings ('USER_ACTIVE_IND')
         ,p_substrings ('USER_ADMIN_IND')
         ,p_substrings ('USER_EXTERNAL_SYS_REF')
         ,p_substrings ('USER_EXPIRED_PASSWD_FLAG')
         ,p_substrings ('USER_LOGIN_ATTEMPTS')
         ,p_substrings ('USER_LAST_LOGIN_DATE')
  from    ks_users_v u
  where   u.id = p_id;

  ks_log.log('END', l_scope);

end fetch_user_substitions;

/**
 * Fetch session details/data
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @return ks_sessions%rowtype
 */
function fetch_session_details(p_id in ks_sessions.id%type)
return ks_sessions%rowtype
is

  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_session_details';
  l_session_info ks_sessions%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param p_id : ' ||p_id, l_scope);

  select * into l_session_info
    from ks_sessions
   where id = p_id;

  ks_log.log('END', l_scope);
  return l_session_info;

end fetch_session_details;

/**
 * Fetch track details/data
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @return ks_event_tracks%rowtype
 */
function fetch_track_details(p_id in ks_event_tracks.id%type)
return ks_event_tracks%rowtype
is

  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_track_details';
  l_track_details ks_event_tracks%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param p_id : ' ||p_id, l_scope);

  select * into l_track_details
    from ks_event_tracks
   where id = p_id;

  ks_log.log('END', l_scope);
  return l_track_details;

end fetch_track_details;
/**
 * Fetch common substitution strings that can be used on a template.
 *   * VOTING_APP_LINK
 *   * ADMIN_APP_LINK
 *
 *
 * @example
 *
 * @issue
 *
 * @author Jorge Rimblas
 * @created November 19, 2018
 * @param x_result_status
 * @return
 */
procedure fetch_common_links(p_substrings in out nocopy t_WordList)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_common_links';
begin
  ks_log.log('BEGIN', l_scope);

  p_substrings('VOTING_APP_LINK') := ks_util.get_param('SERVER_URL') || ks_util.get_param('VOTING_APP_ID');
  p_substrings('ADMIN_APP_LINK') := ks_util.get_param('SERVER_URL') || ks_util.get_param('ADMIN_APP_ID');

  ks_log.log('END', l_scope);
end fetch_common_links;





/**
 * Get ready all the parameters to notify by email.
 * If the procedure receives a template name (in `p_template_name`) then the `p_body`
 * and `p_body_html` parameters are ignored and only the template is used.
 * If present, the `p_substrings` "word list" values will be used to merge with the template.
 * Leave `p_template_name` empty to use the `p_body` and `p_body_html` parameters.
 * If all three destination `p_to`, `p_cc` and `p_bcc` are null, the procedure
 * exits without error.
 *
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param p_template_name optional template name as seen on `ks_email_templates`
 */
procedure send_email (
   p_to in varchar2 default null
  ,p_from in varchar2
  ,p_cc in varchar2 default null
  ,p_bcc in varchar2 default null
  ,p_subject in varchar2
  ,p_body in clob
  ,p_body_html in clob default null
  ,p_template_name in varchar2 default null
  ,p_substrings in t_WordList default g_blank_sub_strings
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'send_email';

  l_body clob;
  l_body_html clob;
begin
  ks_log.log('BEGIN', l_scope);

  if trim (p_to) is null
      and trim (p_cc) is null
      and trim (p_bcc) is null then
    return;
  end if;

  if p_template_name is not null then
    l_body := replace_substr_template (
      p_template_name => p_template_name
     ,p_substrings => p_substrings
    );

    l_body_html := replace (l_body, chr(10), '<br>');
  else
    l_body := p_body;
    l_body_html := p_body_html;
  end if;

  ks_email_api.send (
     p_to => p_to
    ,p_cc => p_cc
    ,p_bcc => p_bcc
    ,p_from => p_from
    ,p_replyto => null
    ,p_subj => p_subject
    ,p_body => l_body
    ,p_body_html => l_body_html
  );

  ks_log.log('END', l_scope);
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end send_email;




/**
 *
 * Notify users of newly loaded sessions. The loaded sessions are found in `ks_session_load_coll_v`
 * Only the users for the tracks marked during the Load Session Wizard (`ks_session_load_coll_v.notify_ind`) will be notified.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_notify_owner Notify "Track Owners", ie Track Leads (OWNER) and Track Observers (VIEWER). Those where `selection_role_code is not null`
 * @param p_notify_voter Notify "Voters": those where `voting_role_code is not null`
 */
procedure notify_track_session_load (
    p_notify_owner in varchar2
  , p_notify_voter in varchar2
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_track_session_load';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('LOAD_NOTIFICATION_TEMPLATE');

  fetch_common_links(l_substrings);

  for rec in (
    with user_emails as (
      select  sl.track_name
             ,sl.session_count
             ,u.email
      from    ks_user_event_track_roles uetr
      join    ks_users u
      on      uetr.username = u.username
      join    ks_session_load_coll_v sl
      on      sl.track_id = uetr.event_track_id
      where   sl.notify_ind = 'Y'
      and     u.email is not null
      and     (
        ('OWNER' = p_notify_owner
          and uetr.selection_role_code is not null)
        or
        ('VOTER' = p_notify_voter
          and uetr.voting_role_code is not null)
      )
      group   by sl.track_name
             ,sl.session_count
             ,u.email
    )
    select    ue.track_name
             ,ue.session_count
             ,listagg (ue.email,',') within group (order by ue.email desc) as email
    from      user_emails ue
    group     by ue.track_name
             ,ue.session_count
  )
  loop
    ks_log.log (rec.track_name || '-' || rec.session_count || '-' || rec.email, l_scope);

    l_substrings('SESSION_COUNT') := rec.session_count;
    l_substrings('TRACK_NAME') := rec.track_name;

    l_subject := ' New sessions for: ' || rec.track_name;

    send_email (
       p_to => rec.email
      ,p_from => l_from
      ,p_cc => null
      ,p_bcc => null
      ,p_subject => l_subject
      ,p_body => null
      ,p_body_html => null
      ,p_template_name =>  l_template_name
      ,p_substrings => l_substrings
    );
  end loop;

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_track_session_load;



/**
 *
 * Send a user an email/notification with their new temporary password after a
 * "Reset Password" (by an Admin) or a "Forgot Password" action (by a user)
 *
 * The text of the email is defined by the template mentioned in the
 * `RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE` system parameter
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_username
 * @param p_password
 * @param p_app_id
 */
procedure notify_reset_pwd_request (
    p_id in ks_users.id%type
   ,p_password in ks_users.password%type
   ,p_app_id in ks_parameters.value%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_reset_pwd_request';

  c_subject_notification constant varchar2(30) := 'Reset Password Request';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE');

  fetch_user_substitions (
    p_id => p_id
   ,p_substrings => l_substrings
  );
  fetch_common_links(l_substrings);

  l_substrings('TEMP_PASSWORD') := p_password;

  l_subject := c_subject_notification;

  send_email (
     p_to => l_substrings('USER_EMAIL')
    ,p_from => l_from
    ,p_cc => null
    ,p_bcc => null
    ,p_subject => l_subject
    ,p_body => null
    ,p_body_html => null
    ,p_template_name =>  l_template_name
    ,p_substrings => l_substrings
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_reset_pwd_request;



/**
 *
 * Notify a user after their password has been successfully changed (Reset Password)
 * The text of the email is defined by the template mentioned in the
 * `RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE` system parameter
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/13/2019
 * @param p_id ks_users.id
 */
procedure notify_reset_pwd_done (
    p_id in ks_users.id%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_reset_pwd_done';

  c_subject_notification constant varchar2(30) := 'Reset Password Done';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE');
  l_subject := c_subject_notification;

  fetch_user_substitions (
    p_id => p_id
   ,p_substrings => l_substrings
  );
  fetch_common_links(l_substrings);

  send_email (
     p_to => l_substrings('USER_EMAIL')
    ,p_from => l_from
    ,p_cc => null
    ,p_bcc => null
    ,p_subject => l_subject
    ,p_body => null
    ,p_body_html => null
    ,p_template_name =>  l_template_name
    ,p_substrings => l_substrings
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_reset_pwd_done;






/**
 * Notify track owners and/or voters when a session is moved between tracks.
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @param p_event_track_id
 * @param p_old_event_track_id
 * @param p_notify_owners_ind when 'Y', the notification will be send to track owners
 * @param p_notify_voters_ind when 'Y', the notification will be send to all voters
 */
procedure notify_session_move (
    p_id in ks_sessions.id%type
   ,p_event_track_id in ks_sessions.event_track_id%type
   ,p_old_event_track_id in ks_sessions.event_track_id%type
   ,p_notify_owners_ind in varchar2
   ,p_notify_voters_ind in varchar2
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_session_move';
  c_subject_notification constant varchar2(30) := 'Session Moved Between Tracks';

  cursor email_list_c
  is
    with user_emails as (
    select distinct u.email
      from ks_user_event_track_roles uetr
      join ks_users u
        on uetr.username = u.username
     where u.email is not null
       and (
            ( p_notify_owners_ind = 'Y'
              and uetr.selection_role_code in ('OWNER'))
            or
            ( p_notify_voters_ind = 'Y'
               and uetr.voting_role_code is not null))
       and uetr.event_track_id in (p_event_track_id, p_old_event_track_id)
      )
    select listagg ( ue.email,',') within group (order by ue.email desc) as email_list
      from user_emails ue;


  l_to varchar2(4000);
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;

  l_substrings t_WordList;
  l_session ks_sessions%rowtype;
  l_event_track ks_event_tracks%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param session id : ' || p_id, l_scope);
  ks_log.log('param current event track id : ' || p_event_track_id, l_scope);
  ks_log.log('param old event track id : ' || p_old_event_track_id, l_scope);
  ks_log.log('param p_notify_owners_ind : ' || p_notify_owners_ind, l_scope);
  ks_log.log('param p_notify_voters_ind : ' || p_notify_voters_ind, l_scope);

  open email_list_c;
  fetch email_list_c into l_to;
  close email_list_c;
  ks_log.log('email list : ' || l_to, l_scope);

  if l_to is not null then
    l_session := fetch_session_details (p_id);
    l_substrings('SESSION_TITLE') := l_session.title;
    l_substrings('SUB_CATEGORY') := nvl(l_session.sub_category, '-');
    l_substrings('SESSION_TYPE') := nvl(l_session.session_type, '-');
    l_substrings('SPEAKER') := l_session.presenter;

    l_event_track := fetch_track_details (p_event_track_id);
    l_substrings('TO_TRACK') := l_event_track.name;

    l_event_track := fetch_track_details (p_old_event_track_id);
    l_substrings('FROM_TRACK') := l_event_track.name;

    l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
    l_subject := c_subject_notification;
    l_template_name := ks_util.get_param('SESSION_MOVED_BETWEEN_TRACKS_TEMPLATE');

    send_email (
      p_to => l_to
     ,p_from => l_from
     ,p_cc => null
     ,p_bcc => null
     ,p_subject => l_subject
     ,p_body => null
     ,p_body_html => null
     ,p_template_name =>  l_template_name
     ,p_substrings => l_substrings
   );
  end if;

  ks_log.log('END', l_scope);
  exception
    when others then
      ks_log.log('Unhandled Exception ', l_scope);
      raise;
end notify_session_move;

end ks_notification_api;
/

-- #36
-- @../plsql/ks_session_api.pls
create or replace package ks_session_api
is

--------------------------------------------------------------------------------
--*
--* 
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter_user_id in ks_sessions.presenter_user_id%TYPE);
  
procedure switch_votes (
	p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username 	  in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
);


function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N',
                                  p_escape_html in varchar2 default 'Y')
  return varchar2;


procedure session_id_navigation (
   p_id in ks_sessions.id%type
  ,p_region_static_id in varchar2
  ,p_page_id in number
  ,p_previous_id out ks_sessions.event_track_id%type
  ,p_next_id out ks_sessions.event_track_id%type
  ,p_total_rows out number
  ,p_current_row out number
);


function is_session_owner (
  p_session_id in ks_sessions.id%type
 ,p_username   in varchar2
)
return varchar2;


function parse_video_link (
  p_video_link in ks_sessions.video_link%type
)
return varchar2;

function get_presenter_comp (
    p_event_id in ks_sessions.event_id%type 
  , p_event_track_id in ks_sessions.event_track_id%type  
  , p_presenter_user_id in ks_sessions.presenter_user_id%type 
) return number;

end ks_session_api;
/
-- @../plsql/ks_session_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
create or replace package body ks_session_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 * @constant gc_html_whitelist_tags a list of strings to NOT escape from. Same as the apex version but includes span and em
 * @constant gc_token_exceptions is a "|" separated list that gets passed into ks_util. It contains the tokens which we want to ommit from escaping.
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

gc_html_whitelist_tags constant varchar2(500) := '<h1>,</h1>,<h2>,</h2>,<h3>,</h3>,<h4>,</h4>,<p>,<span>,</span>,</p>,<b>,</b>,<strong>,</strong>,<i>,</i>,<ul>,</ul>,<ol>,</ol>,<li>,</li>,<br />,<hr/>,<em>,</em>';
gc_token_exceptions constant varchar2(4000) := 'oracle|apex|epm|and|its|it|of';
gc_parameter_tokens_name constant ks_parameters.name_key%type := 'ANONYMIZE_EXTRA_TOKENS';



/**
 * Private function, checks if the speaker/presenter is comped, i.e. is added to the list of comped users for the event
 *
 * @example
 *
 * @issue #36
 *
 * @author Ramona Birsan
 * @created October 8, 2019
 * @param p_presenter_user_id
 * @return 1 if speaker/presenter is comped
 */
function is_speaker_comped (
    p_event_id in ks_sessions.event_id%type
  , p_presenter_user_id in ks_sessions.presenter_user_id%type
) return number
is
  pragma UDF;
  l_scope  ks_log.scope := gc_scope_prefix || 'is_speaker_comped';
  -- l_params logger.tab_param; 
  l_is_comped number(1) := 0;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END
 
  select 1 into l_is_comped
    from ks_event_comp_users cu 
    join ks_users u on (u.id = cu.user_id)
   where cu.event_id = p_event_id
     and u.external_sys_ref = p_presenter_user_id;
     
  return l_is_comped;
  
  exception 
    when no_data_found then
      return 0;
    when others then
      ks_log.log('Unhandled Exception ', l_scope);
      raise;
end is_speaker_comped;






------------------------------------------------------------------------------
/**
 *  Output of the form:
 *    apex_json.open_object;
 *    apex_json.write('p_presenter_user_id', p_presenter_user_id);
 *    apex_json.write('trackList', '<ul><li>Track 1</li></ul>');
 *    apex_json.close_object;
 *
 * @example
 *
 * @issue #36 - use presenter_user_id to fetch the list of tracks
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param p_event_id
 * @param p_presenter_user_id
 * @return
 */
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter_user_id in ks_sessions.presenter_user_id%TYPE)
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'presenter_tracks_json';
  -- l_params logger.tab_param;

  list_cur sys_refcursor;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  -- logger.log('BEGIN', l_scope, null, l_params);

  open list_cur for
    select p_presenter_user_id "presenter_user_id"
          ,'<ul><li>' ||listagg(n || ' in ' || p || ' (' || status || ')', '</li><li>') within group (order by display_seq) || '</li></ul>' "trackList"
    from (
      select t.display_seq, nvl(t.alias, t.name) p, count(*) n
           , listagg(nvl(st.name, '?'), ',') within group (order by st.display_seq) status
        from ks_event_tracks t
           , ks_sessions s
           , ks_session_status st
       where t.id = s.event_track_id
         and s.event_id = to_number(p_event_id)
         and s.presenter_user_id = p_presenter_user_id
         and s.status_code = st.code (+)
       group by t.display_seq, nvl(t.alias, t.name)
    );

  apex_json.write(list_cur);

  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    apex_json.open_array;
    apex_json.open_object;
    apex_json.write('p_presenter_user_id', p_presenter_user_id);
    apex_json.write('trackList', 'Unable to fetch list:<br>' || sqlerrm || '<br>');
    apex_json.close_object;
    apex_json.close_array;
end presenter_tracks_json;






/**
 * Switch votes and voting role of an user for a selected event / track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 26, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_username username of the user.
 * @param p_voting_role selected voting role for the user.
 */
procedure switch_votes (
  p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username    in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
)
is

begin

  -- Move all votes to new vote_type
  update ks_session_votes
     set vote_type = p_voting_role
   where id in (
      select sv.id
        from ks_session_votes sv
           , ks_sessions s
       where sv.username = p_username
         and s.event_id = p_event_id
         and s.event_track_id = p_track_id
         and sv.session_id = s.id);

  update ks_user_event_track_roles
     set voting_role_code = p_voting_role
   where username = p_username
     and event_track_id = p_track_id;

end switch_votes;







--==============================================================================
-- Function: html_whitelist_clob
-- Purpose: returns a varchar2 where every chunk of 4000 characters has been html_whitelisted and tokenized
--
-- Inputs:  p_string - the clob or varchar2 to be escaped/tokenized
--          p_session_id - the session id. We use this to get the name of the presenter/company/co-presenter
--          p_anonymize - whether to hide the info
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N',
                                  p_escape_html in varchar2 default 'Y')
  return varchar2
is
  l_scope ks_log.scope := gc_scope_prefix || 'html_whitelist_tokenize';

  l_output varchar2(32767);

  l_presenter    ks_sessions.presenter%type;
  l_co_presenter ks_sessions.co_presenter%type;
  l_company      ks_sessions.company%type;
begin
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END

  --The id is usually null when the user's session got reset
  --We don't want to create an ugly error on top of the page already showing errors
  --So silently exit.
  if p_session_id is null then
    return '';
  end if;

  if p_escape_html = 'Y' then
    l_output := apex_escape.html_whitelist(p_string, gc_html_whitelist_tags);
  else
    l_output := p_string;
  end if;
  l_output := regexp_replace(l_output, '_x000D_', '', 1, 0, 'i');

  if p_anonymize = 'Y' then
    select s.presenter, s.company, s.co_presenter
      into l_presenter, l_company, l_co_presenter
      from ks_sessions s
     where s.id = p_session_id;

     l_output := ks_util.replace_tokens(l_output 
                                      , l_presenter || ' ' || l_company || ' ' || l_co_presenter ||' ' || ks_util.get_param(gc_parameter_tokens_name)
                                      , gc_token_exceptions);


  end if;



  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  html_whitelist_tokenize;



/**
 * Get the following data to allow navigation of the sessions:
 *    - Previous Session ID
 *    - Next Session ID
 *    - Current Row
 *    - Total Row
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 1, 2018
 * @param p_id
 * @param p_region_static_id
 * @param p_page_id
 * @return
 * @param p_previous_id
 * @param p_next_id
 * @param p_total_rows
 * @param p_current_row
 */
procedure session_id_navigation (
   p_id in ks_sessions.id%type
  ,p_region_static_id in varchar2
  ,p_page_id in number
  ,p_previous_id out ks_sessions.event_track_id%type
  ,p_next_id out ks_sessions.event_track_id%type
  ,p_total_rows out number
  ,p_current_row out number
)
is
  l_report apex_ir.t_report;
  l_sql clob;
  l_next_id number;
  l_previous_id number;
  l_order_by varchar2 (32000);
  l_cur number;
  l_res number;
  l_total_rows number;
  l_row_num number;
  l_alias varchar2(1);
  l_scope ks_log.scope := gc_scope_prefix || 'session_id_navigation';

begin
  ks_log.log('START', l_scope);

  l_report := ks_util.get_ir_report (
      p_page_id => p_page_id
    , p_static_id => p_region_static_id
  );
          
  l_sql := l_report.sql_query;  
  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('l_sql:' || l_sql, l_scope);
  $END

  $IF wwv_flow_api.c_current >= 20180404 $THEN
    -- in 18.1 the alias changed from r to i
    l_alias := 'i';
  $ELSE
    l_alias := 'r';
  $END

  --l_report.sql_query selects the columns indicated on the option "menu Action > Select Columns" from the SQL Query indicated on the App Builder's IR Configuration.
  --The following line replaces the list of selected columns on l_report.sql_query by all the columns.
  --Ex: SESSION_NUM is not displayed on the IR, so it is not selected on l_report.sql_query.
  --Selecting all the columns with r.*, allows to order by any column indicated on the option "menu Action > Data > Sort" even if it is not included on "menu Action > Select Columns".
  --Also, the total number of rows is calculated at this level.
  l_sql := 'select count (id) over () as total_rows'
       || ',' || l_alias || '.*'
       || substr (l_sql, instr (l_sql, ' from '));

  l_order_by := ks_util.get_ir_order_by (p_ir_query => l_sql);
  $IF wwv_flow_api.c_current >= 20180404 $THEN
  -- in APEX 18.1 the order by construct changed and got an extra wrap ")i"
  if instr(l_order_by, ')i') > 0 then
    l_order_by := substr(l_order_by, 1, instr(l_order_by, ')i') -1);
  end if;
  $END

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('order by:' || l_order_by, l_scope);
  $END

  if l_order_by is null then
    l_order_by := 'order by session_num';
  end if;

  l_sql := 'select next
      ,previous
      ,total_rows
      ,row_num
    from (' ||
        '   select    id
                    , lead (id) over ( ' || l_order_by || ') next ' ||
        '           , lag (id) over ( ' || l_order_by || ') previous ' ||
        '           , total_rows ' ||
        '           , row_number () over ( ' || l_order_by || ') as row_num ' ||
        '   from (' || l_sql || 
        ' ))  where id=:ID';

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('New l_sql:' || l_sql, l_scope);
  $END

  l_cur := dbms_sql.open_cursor;

  dbms_sql.parse (l_cur, l_sql, dbms_sql.native);

  for i in 1..l_report.binds.count
  loop
    dbms_sql.bind_variable (l_cur, l_report.binds(i).name, l_report.binds(i).value);
    $IF $$VERBOSE_OUTPUT $THEN
      ks_log.log (l_report.binds(i).name || ':' || l_report.binds(i).value, l_scope);
    $END
  end loop;

  dbms_sql.bind_variable (l_cur, 'ID', p_id);
  dbms_sql.define_column (l_cur, 1, p_next_id);
  dbms_sql.define_column (l_cur, 2, p_previous_id);
  dbms_sql.define_column (l_cur, 3, p_total_rows);
  dbms_sql.define_column (l_cur, 4, p_current_row);

  l_res := dbms_sql.execute(l_cur);

  if dbms_sql.fetch_rows (l_cur) > 0 then
    dbms_sql.column_value (l_cur, 1, p_next_id);
    dbms_sql.column_value (l_cur, 2, p_previous_id);
    dbms_sql.column_value (l_cur, 3, p_total_rows);
    dbms_sql.column_value (l_cur, 4, p_current_row);
  end if;

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('p_next_id:' || p_next_id, l_scope);
    ks_log.log('p_previous_id:' || p_previous_id, l_scope);
    ks_log.log('p_total_rows:' || p_total_rows, l_scope);
    ks_log.log('p_current_row:' || p_current_row, l_scope);
  $END

  dbms_sql.close_cursor (l_cur);
  ks_log.log('END', l_scope);
exception
  when others then
    if dbms_sql.is_open (l_cur) then
      dbms_sql.close_cursor (l_cur);
    end if;

    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  session_id_navigation;




/**
 * For a given track session and user, indicate if the given user is the presenter 
 * or copresenter of the session.
 * The comparison is done against the ks_users.external_sys_ref which identifies users
 * in the external system.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 5, 2018
 * @param p_id
 * @return 'Y','N'
 */
function is_session_owner (
  p_session_id in ks_sessions.id%type
 ,p_username   in varchar2
)
return varchar2
is 
  l_scope ks_log.scope := gc_scope_prefix || 'is_session_owner';
  
  l_return varchar2(1) := 'N';

  l_external_sys_ref ks_users.external_sys_ref%type;
  l_presenter_user_id ks_sessions.presenter_user_id%type;
  l_co_presenter_user_id ks_sessions.co_presenter_user_id%type;
begin
  ks_log.log('START', l_scope);

  select s.presenter_user_id
       , s.co_presenter_user_id
    into l_presenter_user_id
       , l_co_presenter_user_id
    from ks_sessions s
   where s.id = p_session_id;

  select u.external_sys_ref
    into l_external_sys_ref
    from ks_users u
   where u.username = p_username;

  if l_external_sys_ref in (l_presenter_user_id, l_co_presenter_user_id) then
    l_return := 'Y';
  end if;

  ks_log.log('END', l_scope);
  return l_return;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end is_session_owner;




/**
 * Parse the "video link" text returning one line per link and formatting the link as an html anchor tag when applied.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 15, 2018
 * @param p_video_link
 * @return parsed text containing the link as a html anchor tag.
 */
function parse_video_link (
  p_video_link in ks_sessions.video_link%type
)
return varchar2
is 
  l_scope ks_log.scope := gc_scope_prefix || 'parse_video_link';
  
  c_link_format constant varchar2(1000) := '<a id="VIDEO_URL" href="#LINK#" target="_blank" alt="Video" title="Video">#LINK#</a>';
  
  l_links apex_t_varchar2;
  l_key varchar2(1000);
  l_link varchar2(32000);
  l_return varchar2(32000);
  l_is_not_first_line boolean := FALSE;
begin
  ks_log.log ('START', l_scope);

  l_links := apex_string.split(p_video_link, '<br />');
  l_key := l_links.first;
  
  while (l_key is not null)
  loop
    l_link := l_links (l_key);

    if substr (trim (l_link), 1, 4) = 'http' then 
      l_link := replace (c_link_format, '#LINK#', l_link);
    end if;

    if l_is_not_first_line then 
      l_return := l_return || '<br>' || l_link;
    else 
      l_return := l_link;
      l_is_not_first_line := TRUE;
    end if;

    l_key := l_links.next (l_key);
  end loop;

  ks_log.log ('END', l_scope);
  return l_return;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end parse_video_link;






/**
 * The function returns presenter's comp per track - this is identical for all tracks 
 * for which the user has submitted sessions.
 * Assumes that it will be called from within a SQL query, hence no track validation.
 * And the UDF pragma
 * 
 * @example - Displays presenter's comp for each associated track
    select  s.event_track_id
          , s.presenter_user_id
          , ks_session_api.get_presenter_comp(s.event_id, s.event_track_id , s.presenter_user_id) as presenter_comp
       from ks_sessions s
      where s.event_id = :p_event_id
        and s.presenter_user_id = :p_presenter_user_id
   group by s.event_id, s.event_track_id, s.presenter_user_id
   order by s.event_track_id
 *
 * @issue #36
 *
 * @author Ramona Birsan
 * @created October 7, 2019
 * @param p_event_id   
 * @param p_event_track_id
 * @param p_presenter_user_id
 * @return number
 */
function get_presenter_comp (
    p_event_id in ks_sessions.event_id%type 
  , p_event_track_id in ks_sessions.event_track_id%type    
  , p_presenter_user_id in ks_sessions.presenter_user_id%type 
) return number
is 
  pragma UDF;

  l_scope  ks_log.scope := gc_scope_prefix || 'get_presenter_comp';
  -- l_params logger.tab_param;
  l_presenter_comp number(3,2) := 0;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_event_track_id', p_event_track_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END
  
  if is_speaker_comped (p_event_id, p_presenter_user_id) = 1 then 
    l_presenter_comp := 0;
  else
    -- "distinct event_track_id" is used because we calculate the total number of 
    -- tracks which have at least one session accepted
    with speaker_comp_track_ratio as (
      select  r.presenter_user_id
            , round(1/sum (r.track_comp),2) as speaker_comp_ratio
        from (
             select s.presenter_user_id
                  , count(distinct s.event_track_id) as track_comp
               from ks_sessions s
              where s.status_code = 'ACCEPTED' 
                and s.event_id = p_event_id 
              group by s.event_track_id, s.presenter_user_id 
         ) r
       group by r.presenter_user_id
      having r.presenter_user_id = p_presenter_user_id
    )
    select count (*) * tr.speaker_comp_ratio 
      into l_presenter_comp
      from speaker_comp_track_ratio tr
     where exists ( select 1
                      from ks_sessions ss
                     where ss.status_code = 'ACCEPTED'
                       and ss.event_id = p_event_id
                       and ss.event_track_id = p_event_track_id
                       and ss.presenter_user_id = p_presenter_user_id)
     group by tr.speaker_comp_ratio;
      
  end if;
  
  return l_presenter_comp;

  exception
    when no_data_found then
      return l_presenter_comp;
    when others then
      ks_log.log_error('Unhandled Exception ', l_scope);
      raise;
end get_presenter_comp;



end ks_session_api;
/

-- @../plsql/ks_tags_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
PROMPT ks_tags_api body
create or replace package body ks_tags_api
is
        
--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

---
--- Tag Synchronisation Procedure
---
procedure tag_sync (
    p_new_tags          in varchar2,
    p_old_tags          in varchar2,
    p_content_type      in varchar2,
    p_content_id        in number )
as
    l_scope  ks_log.scope := gc_scope_prefix || 'tag_sync';
  -- l_params logger.tab_param;

    type tags is table of varchar2(255) index by varchar2(255);
    l_new_tags_a    tags;
    l_old_tags_a    tags;
    l_new_tags      apex_application_global.vc_arr2;
    l_old_tags      apex_application_global.vc_arr2;
    l_merge_tags    apex_application_global.vc_arr2;
    l_dummy_tag     varchar2(255);
    i               integer;

begin
  -- we call tag_sync form a trigger, so lets not call logger unless we need to.
  -- logger.append_param(l_params, 'p_option_name', p_option_name);
    ks_log.log('START', l_scope);
    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('p_content_type: ' || p_content_type, l_scope);
    ks_log.log('  p_content_id: ' || p_content_id, l_scope);
    ks_log.log('p_new_tags: ' || p_new_tags, l_scope);
    ks_log.log('p_old_tags: ' || p_old_tags, l_scope);
    $END

    l_old_tags := apex_util.string_to_table(p_old_tags,':');
    l_new_tags := apex_util.string_to_table(p_new_tags,':');
    if l_old_tags.count > 0 then --do inserts and deletes
        --build the associative arrays
        for i in 1..l_old_tags.count loop
            l_old_tags_a(l_old_tags(i)) := l_old_tags(i);
        end loop;
        for i in 1..l_new_tags.count loop
            l_new_tags_a(l_new_tags(i)) := l_new_tags(i);
        end loop;
        --do the inserts
        for i in 1..l_new_tags.count loop
            begin
                l_dummy_tag := l_old_tags_a(l_new_tags(i));
            exception when no_data_found then
                insert into ks_tags (tag, content_id, content_type )
                    values (l_new_tags(i), p_content_id, p_content_type );
                l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
            end;
        end loop;
        --do the deletes
        for i in 1..l_old_tags.count loop
            begin
                l_dummy_tag := l_new_tags_a(l_old_tags(i));
            exception when no_data_found then
                delete from ks_tags where content_id = p_content_id and tag = l_old_tags(i);
                l_merge_tags(l_merge_tags.count + 1) := l_old_tags(i);
            end;
        end loop;
    else --just do inserts
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('insert: ' || l_new_tags.count, l_scope);
        $END
        for i in 1..l_new_tags.count loop
            insert into ks_tags (tag, content_id, content_type )
                values (l_new_tags(i), p_content_id, p_content_type );
            l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
        end loop;
    end if;

    for i in 1..l_merge_tags.count 
    loop
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('merging(' || i || '): ' || l_merge_tags(i), l_scope);
        ks_log.log('merging ks_tag_type_sums', l_scope);
        $END
        merge into ks_tag_type_sums s
        using (select count(*) tag_count
                 from ks_tags
                where tag = l_merge_tags(i) 
                  and content_type = p_content_type ) t
           on (s.tag = l_merge_tags(i) and s.content_type = p_content_type )
         when not matched then
           insert (tag, content_type, tag_count)
           values (l_merge_tags(i), p_content_type, t.tag_count)
         when matched then
           update set s.tag_count = t.tag_count;


        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('merging ks_tag_sums', l_scope);
        $END
        merge into ks_tag_sums s
        using (select sum(tag_count) tag_count
                 from ks_tag_type_sums
                where tag = l_merge_tags(i) ) t
           on (s.tag = l_merge_tags(i) )
         when not matched then
           insert (tag, tag_count)
           values (l_merge_tags(i), t.tag_count)
         when matched then
           update set s.tag_count = t.tag_count;
    end loop;

    ks_log.log('END', l_scope);

end tag_sync;

/*******************************************************************
 * Maintain the collection elements when using search filters
 *   p_coll: collection_name
 *    p_sub: Optional sub level/area for the tags.
 *     p_id: ID being managed
 * p_status: YES/NO is the element checked (YES) or un-checked (NO)
 *******************************************************************/
procedure maintain_filter_coll(
       p_coll   in varchar2
     , p_sub    in varchar2 := null
     , p_id     in varchar2
     , p_status in varchar2 := 'NO')
is
  l_scope  ks_log.scope := gc_scope_prefix || 'maintain_filter_coll';

  l_seq_id number;
begin

  ks_log.log('START', l_scope);

  /*
  The collections being used:
    SESSIONTAGFILTER: For Session (abstract) filters
  */

  if p_coll in ('SESSIONTAGFILTER') then
    -- is this the top level selection
    if p_id = 'top' then

      -- Because it's the top level, empty the collection
      if apex_collection.collection_exists(p_coll) then
        apex_collection.truncate_collection(p_coll);
      else
        apex_collection.create_collection(p_coll);
      end if;

      -- the collection is already empty, but if the status
      -- is YES then we need to populate ALL of the elmemnts
      if p_status = 'YES' then
        for i in (
          select tag id from ks_tag_type_sums where content_type='SESSION' || nvl2(p_sub, ':' || p_sub, '') and p_coll = 'SESSIONTAGFILTER'
          )
        loop
          apex_collection.add_member(p_coll, p_c001 => i.id);
        end loop;
      end if;

    else
      -- We're dealing with a single element

      -- Create the collection if it doesn't exist.
      if not apex_collection.collection_exists(p_coll) then
          apex_collection.create_collection(p_coll);
      end if;

      -- The element was checked so add it
      if p_status = 'YES' then
          apex_collection.add_member(p_coll, p_c001 => p_id);
      else

        -- the element was unchecked so remove it.
        begin
        select seq_id
          into l_seq_id
          from apex_collections
         where collection_name = p_coll
           and c001 = p_id;

          apex_collection.delete_member(p_coll, l_seq_id);
        exception
        when NO_DATA_FOUND then
          null;
        end;
      end if;

    end if;
  end if;

  ks_log.log('END', l_scope);

end maintain_filter_coll;


end ks_tags_api;
/



-- @../views/ks_events_comps_v.sql
PRO ks_events_comps_v
create or replace force view ks_events_comps_v
as
select  s.event_id
      , s.event_track_id
      , s.presenter_user_id
      , ks_session_api.get_presenter_comp(s.event_id, s.event_track_id , s.presenter_user_id) as presenter_comp
   from ks_sessions s
  where s.status_code = 'ACCEPTED'
group by s.event_id, s.event_track_id, s.presenter_user_id
/

PRO _________________________________________________
PRO . DML

PRO .. Make presenter_user_id mandatory
-- @../conversion/populate_presenter_user_id.sql


PRO ... create table tmp_presenters
create table tmp_presenters
as
select presenter, max(presenter_user_id) presenter_user_id
from ks_sessions
where presenter in (
    select presenter
    from ks_sessions
    where presenter_user_id is not null
)
  and presenter_user_id is not null
group by presenter
/

create or replace function get_presenter_user_id(p_presenter in ks_sessions.presenter%TYPE)
  return ks_sessions.presenter_user_id%TYPE
is
  l_presenter_user_id ks_sessions.presenter_user_id%TYPE;
  l_presenter_hash varchar2(128);
begin
  select presenter_user_id
    into l_presenter_user_id
    from tmp_presenters
   where presenter = p_presenter;

  -- ks_log.log('Got l_presenter_user_id:' || l_presenter_user_id, 'get_presenter_user_id');
  return l_presenter_user_id;

 exception
 when NO_DATA_FOUND then
   -- generate an ID:
   --   * create and MD5 of the presenter name
   --   * Convert it to a number (because we get a RAW back)
   --   * Convert the number back to a String and grab the first 20 only (the size limit of presenter_user_id)
   return substr(
      to_char(
          to_number(
            dbms_obfuscation_toolkit.md5(input => utl_raw.cast_to_raw(p_presenter))
            , 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')
      ),1,20);
end get_presenter_user_id;
/



declare
  cursor presenters_cur
  is
    select * from ks_sessions 
    where presenter_user_id is null
      for update of presenter_user_id;

  l_session_rec presenters_cur%rowtype;

begin

  open presenters_cur;
  loop
    fetch presenters_cur into l_session_rec;
    exit when presenters_cur%NOTFOUND;

    update ks_sessions
       set presenter_user_id = get_presenter_user_id(presenter)
     where current of presenters_cur;

  end loop;
  close presenters_cur;

end;
/


PRO ... Cleanup: Drop tmp_presenters, get_presenter_user_id
drop table tmp_presenters;

drop function get_presenter_user_id;



alter table ks_sessions modify presenter_user_id not null;



-- #2
insert into constraint_lookup (constraint_name,message) values ('KS_EVENT_COMMUNITY_TRACKS_U01','That track is already part of the community.');
insert into constraint_lookup (constraint_name,message) values ('KS_COMMUNITY_TRACKS_FK','The community cannot be removed when it has tracks.');
insert into constraint_lookup (constraint_name,message) values ('KS_EVENT_COMMUNITY_TRACKS_FK', 'The track cannot be removed if it is associated with a community.');
-- #35
insert into ks_parameters (category, name_key, value, description) values ('Notifications','SESSION_MOVED_BETWEEN_TRACKS_TEMPLATE','SESSION_MOVED_BETWEEN_TRACKS','Name of email template for when a session is moved between tracks');

delete from ks_email_templates where name = 'SESSION_MOVED_BETWEEN_TRACKS';
insert into ks_email_templates (name, template_text)
 values ('SESSION_MOVED_BETWEEN_TRACKS'
  , q'{The session <i>"#SESSION_TITLE#"</i> from #SPEAKER# has been moved from <i>#FROM_TRACK#</i> to <b>#TO_TRACK#</b>

Sub Category : <i>#SUB_CATEGORY#</i>
Session Type : <i>#SESSION_TYPE#</i>

All existing votes from <i>#FROM_TRACK#</i> track have been removed.
Tags most likely should be revised.
}');

-- ## 44
-- @../conversion/seed_ks_load_mapping.sql
PRO Removing previous mapping
delete from KS_LOAD_MAPPING;
REM INSERTING into KS_LOAD_MAPPING
SET DEFINE OFF;
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',10,'SESSION_NUM','Session Number');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',20,'TITLE','Session Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',30,null,'Session Title Link');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',40,'EVENT_TRACK_ID','Track');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',50,'SUB_CATEGORY','Sub-Categorization');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',60,'SESSION_TYPE','Session Type');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',70,null,'Role:Submitter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',80,null,'Session Status');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',90,null,'All roles');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',100,null,'All roles (with line break)');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',110,'ACE_LEVEL','Are you part of the ACE program?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',120,null,'Cross-Listed Tracks');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',130,'PRESENTED_ANYTHING_IND','Have you ever presented before a live audience?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',140,'PRESENTED_BEFORE_IND','Have you presented this session before?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',150,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',160,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',170,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',180,'PRESENTED_BEFORE_WHERE','If yes, at what events?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',190,'PRESENTED_ANYTHING_WHERE','If yes, at what events?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',200,'SUBMISSION_DATE','Initial Submission');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',210,null,'Last Update');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',220,'VIDEO_LINK','Link to your optional abstract submission video');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',230,null,'Review Comments');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',240,null,'Role:Co-Presenter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',250,'CO_PRESENTER_COMPANY','Role:Co-Presenter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',260,null,'Role:Co-Presenter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',270,'CO_PRESENTER','Role:Co-Presenter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',280,null,'Role:Co-Presenter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',290,null,'Role:Co-Presenter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',300,'CO_PRESENTER_USER_ID','Role:Co-Presenter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',310,'PRESENTER_BIOGRAPHY','Role:Primary Presenter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',320,'COMPANY','Role:Primary Presenter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',330,'PRESENTER_EMAIL','Role:Primary Presenter Email');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',340,null,'Role:Primary Presenter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',350,'PRESENTER','Role:Primary Presenter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',360,null,'Role:Primary Presenter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',370,null,'Role:Primary Presenter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',380,'PRESENTER_USER_ID','Role:Primary Presenter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',390,null,'Role:Submitter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',400,null,'Role:Submitter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',410,null,'Role:Submitter Email');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',420,null,'Role:Submitter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',430,null,'Role:Submitter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',440,null,'Role:Submitter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',450,null,'Role:Submitter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',460,'SESSION_ABSTRACT','Session Description');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',470,'EXTERNAL_SYS_REF','Session Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',480,'SESSION_SUMMARY','Short Description');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',490,null,'Status Change');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',500,'TAGS','Tags');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',510,'TECHNOLOGY_PRODUCT','Technologies or Products Used');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',520,'SESSION_LENGTH','The length of my presentation can be');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',530,null,'Vote Average');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',540,null,'Vote Count');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',550,'CONTAINS_DEMO_IND','Will this presentation include a demo?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',560,'WEBINAR_WILLING_IND','Would you be willing to present this as a webinar?');


-- DO NOT TOUCH/UPDATE BELOW THIS LINE


PRO Recompiling objects
exec dbms_utility.compile_schema(schema => user, compile_all => false);
