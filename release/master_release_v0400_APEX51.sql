-- =============================================================================
-- ==========================  Full _release.sql file
-- =============================================================================
PRO Installing 4.0.0 (Kscope20)

--  sqlblanklines - Allows for SQL statements to have blank lines
set sqlblanklines on
--  define - Sets the character used to prefix substitution variables
set define '^'


PRO _________________________________________________
PRO . TABLES and DDL

-- #2
-- @../install/ks_event_communities.sql
PRO .. ks_event_communities 

-- drop table ks_event_communities cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_communities (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , event_id        number        not null
  , name            varchar2(60)  not null
  , created_by      varchar2(60) default
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_event_communities_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
)
enable primary key using index
/

comment on table ks_event_communities is 'List of Communities';

comment on column ks_event_communities.id is 'Primary Key ID';
comment on column ks_event_communities.created_by is 'User that created this record';
comment on column ks_event_communities.created_on is 'Date the record was first created';
comment on column ks_event_communities.updated_by is 'User that last modified this record';
comment on column ks_event_communities.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_communities_u_trg
before update
on ks_event_communities
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/
-- @../install/ks_event_community_tracks.sql
PRO .. ks_event_community_tracks 

-- drop table ks_event_community_tracks cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_community_tracks (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , community_id    number        not null
  , track_id        number        not null
  , created_by      varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_community_tracks_fk foreign key ( community_id ) references ks_event_communities ( id ) not deferrable
  , constraint ks_event_community_tracks_fk foreign key ( track_id ) references ks_event_tracks ( id ) not deferrable
)
enable primary key using index
/

create unique index ks_event_community_tracks_u01 on ks_event_community_tracks(community_id, track_id);

comment on table ks_event_community_tracks is 'List of tracks in a community';

comment on column ks_event_community_tracks.id is 'Primary Key ID';
comment on column ks_event_community_tracks.created_by is 'User that created this record';
comment on column ks_event_community_tracks.created_on is 'Date the record was first created';
comment on column ks_event_community_tracks.updated_by is 'User that last modified this record';
comment on column ks_event_community_tracks.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_community_track_u_trg
before update
on ks_event_community_tracks
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/

-- #42
alter table ks_sessions add ranking number;
comment on column ks_sessions.ranking is 'Used to specify the rank for a group of sessions.';


-- #36
create index ks_users_i01
  on ks_users(external_sys_ref)
/

-- @../install/ks_event_comp_users.sql
PRO .. ks_event_comp_users 

-- drop table ks_event_comp_users cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_comp_users (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , event_id        number        not null
  , user_id         number        not null
  , reason          varchar2(250)
  , created_by      varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_event_comp_user_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
  , constraint ks_event_comp_users_fk foreign key ( user_id ) references ks_users ( id ) not deferrable
)
enable primary key using index
/

comment on table ks_event_comp_users is 'Users with attendance comps for the event';

comment on column ks_event_comp_users.id is 'Primary Key ID';
comment on column ks_event_comp_users.event_id is 'Event for which the user is comped';
comment on column ks_event_comp_users.user_id is 'User begin comped';
comment on column ks_event_comp_users.reason is 'Reason or information for comped';
comment on column ks_event_comp_users.created_by is 'User that created this record';
comment on column ks_event_comp_users.created_on is 'Date the record was first created';
comment on column ks_event_comp_users.updated_by is 'User that last modified this record';
comment on column ks_event_comp_users.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_comp_users_u_trg
before update
on ks_event_comp_users
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/


-- 
PRO .. Allow multi-byte chars for tags
-- alter table ks_tags modify tag varchar2(255);
-- alter table ks_tag_sums modify tag varchar2(255);
-- alter table ks_tag_type_sums modify tag varchar2(255);


-- #44
PRO .. Session Length
alter table ks_full_session_load add session_length varchar2(500);
alter table ks_sessions add session_length varchar2(500);



PRO _________________________________________________
PRO . VIEW

-- @../views/ks_sessions_v.sql

PRO ks_sessions_v
create or replace view ks_sessions_v
as
with totals as (
  select d.session_id
       , sum(d.vote) votes_total
       , avg(d.vote) votes_average
   from ks_session_votes d
  group by d.session_id
)
select  s.id
      , s.event_id
      , s.event_track_id
      , s.session_num
      , s.sub_category
      , s.session_type
      , s.title
      , s.presenter
      , s.company
      , s.co_presenter
      , s.status_code
      , s.notes
      , s.tags      
      , t.votes_total
      , t.votes_average
      , s.presenter_email
      , s.session_summary
      , s.session_abstract
      , s.target_audience
      , s.presented_before_ind
      , s.presented_before_where
      , s.technology_product
      , s.ace_level
      , s.video_link
      , trim (
        case
        when instr (s.video_link, 'http') > 0 
        then
          substr (
             s.video_link
            ,instr (s.video_link, 'http')
            ,case 
              when instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1) < instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1)
                then instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1)
              when instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1) > instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1)
                then instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1) - 1
                else length (s.video_link)
            end
          )
        else null
        end
      ) as first_video_link
      , s.contains_demo_ind
      , s.webinar_willing_ind
      , s.external_sys_ref
      , s.presenter_user_id
      , s.co_presenter_user_id
      , s.presenter_biography
      , s.co_presenter_company
      , s.submission_date
      , s.room_size_code
      , s.presented_anything_ind
      , s.presented_anything_where
      , s.ranking
      , s.created_by
      , s.created_on
      , s.updated_by
      , s.updated_on
  from ks_sessions s
     , totals t
 where s.id = t.session_id (+)
/
-- @../views/ks_users_v.sql
PRO ks_users_v
create or replace view ks_users_v
as
select u.id
     , u.username
     , u.password
     , u.first_name
     , u.last_name
     , u.first_name || nvl2(u.last_name, ' ' || u.last_name, '') full_name
     , u.first_name || nvl2(u.last_name, ' ' || u.last_name, '')  || nvl2(u.first_name || u.last_name, ' (','') || u.username || nvl2(u.first_name || u.last_name, ')','') full_name_extended
     , u.email
     , u.active_ind
     , u.admin_ind
     , u.external_sys_ref
     , u.expired_passwd_flag
     , u.login_attempts
     , u.last_login_date
     , u.created_by
     , u.created_on
     , u.updated_by
     , u.updated_on
  from ks_users u
/

-- #2
-- @../views/ks_events_communities_v.sql
PRO ks_events_communities_v
create or replace force view ks_events_communities_v
as
select e.id event_id
     , c.id event_community_id
     , c.name community_name
     , e.name event_name
     , e.begin_date begin_date
     , e.active_ind event_active_ind
     , (
         select listagg( t.name, ', ') within group (order by t.display_seq)
           from ks_event_community_tracks ct join ks_event_tracks t on (ct.track_id = t.id and t.event_id = e.id)
          where ct.community_id =  c.id
       ) track_list
from ks_events e
join ks_event_communities c on ( c.event_id = e.id)
/
-- @../views/ks_events_communities_tracks_v.sql
PRO ks_events_communities_tracks_v
create or replace force editionable view ks_events_communities_tracks_v
as
  select e.id event_id
       , c.id event_community_id
       , c.name community_name
       , e.name event_name
       , e.begin_date begin_date
       , e.active_ind event_active_ind
       , ct.id community_track_id
       , ct.track_id
       , et.display_seq track_display_seq
       , et.name track_name
       , et.alias track_alias
       , et.active_ind track_active_ind
       , et.max_sessions
       , et.max_comps
  from ks_events e
  join ks_event_communities c on ( c.event_id = e.id)
  join ks_event_community_tracks ct on (c.id = ct.community_id)
  join ks_event_tracks et on (ct.track_id = et.id)
/




PRO _________________________________________________
PRO . PACKAGES

-- #35
-- @../plsql/ks_notification_api.pls
create or replace package ks_notification_api
is

-- TYPES
type t_WordList is table of varchar2(32000) index by varchar(30);


-- CONSTANTS
g_blank_sub_strings t_WordList; -- Leave blank
------------------------------------------------------------------------------
procedure fetch_user_substitions (
  p_id in ks_users.id%type
 ,p_substrings in out nocopy t_WordList
);

procedure send_email (
   p_to in varchar2 default null
  ,p_from in varchar2
  ,p_cc in varchar2 default null
  ,p_bcc in varchar2 default null
  ,p_subject in varchar2
  ,p_body in clob
  ,p_body_html in clob default null
  ,p_template_name in varchar2 default null
  ,p_substrings in t_WordList default g_blank_sub_strings
);

procedure notify_track_session_load (
    p_notify_owner in varchar2
  , p_notify_voter in varchar2
);

procedure notify_reset_pwd_request (
    p_id in ks_users.id%type
   ,p_password in ks_users.password%type
   ,p_app_id in ks_parameters.value%type
);

procedure notify_reset_pwd_done (
    p_id in ks_users.id%type
);

procedure notify_session_move (
    p_id in ks_sessions.id%type
   ,p_event_track_id in ks_sessions.event_track_id%type
   ,p_old_event_track_id in ks_sessions.event_track_id%type
   ,p_notify_owners_ind in varchar2
   ,p_notify_voters_ind in varchar2
);

end ks_notification_api;
/
-- @../plsql/ks_notification_api.plb
set define off
create or replace package body ks_notification_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';
-- gc_template_load_notif constant ks_parameters.name_key%type := 'LOAD_NOTIFICATION_TEMPLATE';


------------------------------------------------------------------------------
/**
 * Get ready all the parameters to notify by email.
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param
 */
function replace_substr_template (
   p_template_name in varchar2
  ,p_substrings in t_WordList default g_blank_sub_strings
)
return clob
is
  l_scope ks_log.scope := gc_scope_prefix || 'replace_substr_template';

  l_msg clob;
  l_key varchar(30);
  l_substring varchar2(32000);
begin
  ks_log.log('BEGIN', l_scope);

  select  t.template_text
  into    l_msg
  from    ks_email_templates t
  where   t.name = p_template_name;

  l_key := p_substrings.first;

  while (l_key is not null)
  loop
    l_msg := replace (l_msg, '#' || upper (l_key) || '#', p_substrings(l_key) );
    l_key := p_substrings.next(l_key);
  end loop;

  ks_log.log('l_msg:' || l_msg, l_scope);
  ks_log.log('END', l_scope);
  return l_msg;
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end replace_substr_template;




/**
 * Populate all the substrings available for a given user so they can be used in
 * a template
 *
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 10, 2018
 * @param p_id `ks_users.id`
 * @param p_substrings `t_WordList`
 */
procedure fetch_user_substitions (
  p_id in ks_users.id%type
 ,p_substrings in out nocopy t_WordList
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'fetch_user_substitions';
begin
  ks_log.log('BEGIN', l_scope);

  select  u.id
         ,u.username
         ,u.first_name
         ,u.last_name
         ,u.full_name
         ,u.email
         ,u.active_ind
         ,u.admin_ind
         ,u.external_sys_ref
         ,u.expired_passwd_flag
         ,u.login_attempts
         ,u.last_login_date
  into    p_substrings ('USER_ID')
         ,p_substrings ('USERNAME')
         ,p_substrings ('USER_FIRST_NAME')
         ,p_substrings ('USER_LAST_NAME')
         ,p_substrings ('USER_FULL_NAME')
         ,p_substrings ('USER_EMAIL')
         ,p_substrings ('USER_ACTIVE_IND')
         ,p_substrings ('USER_ADMIN_IND')
         ,p_substrings ('USER_EXTERNAL_SYS_REF')
         ,p_substrings ('USER_EXPIRED_PASSWD_FLAG')
         ,p_substrings ('USER_LOGIN_ATTEMPTS')
         ,p_substrings ('USER_LAST_LOGIN_DATE')
  from    ks_users_v u
  where   u.id = p_id;

  ks_log.log('END', l_scope);

end fetch_user_substitions;

/**
 * Fetch session details/data
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @return ks_sessions%rowtype
 */
function fetch_session_details(p_id in ks_sessions.id%type)
return ks_sessions%rowtype
is

  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_session_details';
  l_session_info ks_sessions%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param p_id : ' ||p_id, l_scope);

  select * into l_session_info
    from ks_sessions
   where id = p_id;

  ks_log.log('END', l_scope);
  return l_session_info;

end fetch_session_details;

/**
 * Fetch track details/data
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @return ks_event_tracks%rowtype
 */
function fetch_track_details(p_id in ks_event_tracks.id%type)
return ks_event_tracks%rowtype
is

  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_track_details';
  l_track_details ks_event_tracks%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param p_id : ' ||p_id, l_scope);

  select * into l_track_details
    from ks_event_tracks
   where id = p_id;

  ks_log.log('END', l_scope);
  return l_track_details;

end fetch_track_details;
/**
 * Fetch common substitution strings that can be used on a template.
 *   * VOTING_APP_LINK
 *   * ADMIN_APP_LINK
 *
 *
 * @example
 *
 * @issue
 *
 * @author Jorge Rimblas
 * @created November 19, 2018
 * @param x_result_status
 * @return
 */
procedure fetch_common_links(p_substrings in out nocopy t_WordList)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_common_links';
begin
  ks_log.log('BEGIN', l_scope);

  p_substrings('VOTING_APP_LINK') := ks_util.get_param('SERVER_URL') || ks_util.get_param('VOTING_APP_ID');
  p_substrings('ADMIN_APP_LINK') := ks_util.get_param('SERVER_URL') || ks_util.get_param('ADMIN_APP_ID');

  ks_log.log('END', l_scope);
end fetch_common_links;





/**
 * Get ready all the parameters to notify by email.
 * If the procedure receives a template name (in `p_template_name`) then the `p_body`
 * and `p_body_html` parameters are ignored and only the template is used.
 * If present, the `p_substrings` "word list" values will be used to merge with the template.
 * Leave `p_template_name` empty to use the `p_body` and `p_body_html` parameters.
 * If all three destination `p_to`, `p_cc` and `p_bcc` are null, the procedure
 * exits without error.
 *
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param p_template_name optional template name as seen on `ks_email_templates`
 */
procedure send_email (
   p_to in varchar2 default null
  ,p_from in varchar2
  ,p_cc in varchar2 default null
  ,p_bcc in varchar2 default null
  ,p_subject in varchar2
  ,p_body in clob
  ,p_body_html in clob default null
  ,p_template_name in varchar2 default null
  ,p_substrings in t_WordList default g_blank_sub_strings
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'send_email';

  l_body clob;
  l_body_html clob;
begin
  ks_log.log('BEGIN', l_scope);

  if trim (p_to) is null
      and trim (p_cc) is null
      and trim (p_bcc) is null then
    return;
  end if;

  if p_template_name is not null then
    l_body := replace_substr_template (
      p_template_name => p_template_name
     ,p_substrings => p_substrings
    );

    l_body_html := replace (l_body, chr(10), '<br>');
  else
    l_body := p_body;
    l_body_html := p_body_html;
  end if;

  ks_email_api.send (
     p_to => p_to
    ,p_cc => p_cc
    ,p_bcc => p_bcc
    ,p_from => p_from
    ,p_replyto => null
    ,p_subj => p_subject
    ,p_body => l_body
    ,p_body_html => l_body_html
  );

  ks_log.log('END', l_scope);
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end send_email;




/**
 *
 * Notify users of newly loaded sessions. The loaded sessions are found in `ks_session_load_coll_v`
 * Only the users for the tracks marked during the Load Session Wizard (`ks_session_load_coll_v.notify_ind`) will be notified.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_notify_owner Notify "Track Owners", ie Track Leads (OWNER) and Track Observers (VIEWER). Those where `selection_role_code is not null`
 * @param p_notify_voter Notify "Voters": those where `voting_role_code is not null`
 */
procedure notify_track_session_load (
    p_notify_owner in varchar2
  , p_notify_voter in varchar2
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_track_session_load';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('LOAD_NOTIFICATION_TEMPLATE');

  fetch_common_links(l_substrings);

  for rec in (
    with user_emails as (
      select  sl.track_name
             ,sl.session_count
             ,u.email
      from    ks_user_event_track_roles uetr
      join    ks_users u
      on      uetr.username = u.username
      join    ks_session_load_coll_v sl
      on      sl.track_id = uetr.event_track_id
      where   sl.notify_ind = 'Y'
      and     u.email is not null
      and     (
        ('OWNER' = p_notify_owner
          and uetr.selection_role_code is not null)
        or
        ('VOTER' = p_notify_voter
          and uetr.voting_role_code is not null)
      )
      group   by sl.track_name
             ,sl.session_count
             ,u.email
    )
    select    ue.track_name
             ,ue.session_count
             ,listagg (ue.email,',') within group (order by ue.email desc) as email
    from      user_emails ue
    group     by ue.track_name
             ,ue.session_count
  )
  loop
    ks_log.log (rec.track_name || '-' || rec.session_count || '-' || rec.email, l_scope);

    l_substrings('SESSION_COUNT') := rec.session_count;
    l_substrings('TRACK_NAME') := rec.track_name;

    l_subject := ' New sessions for: ' || rec.track_name;

    send_email (
       p_to => rec.email
      ,p_from => l_from
      ,p_cc => null
      ,p_bcc => null
      ,p_subject => l_subject
      ,p_body => null
      ,p_body_html => null
      ,p_template_name =>  l_template_name
      ,p_substrings => l_substrings
    );
  end loop;

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_track_session_load;



/**
 *
 * Send a user an email/notification with their new temporary password after a
 * "Reset Password" (by an Admin) or a "Forgot Password" action (by a user)
 *
 * The text of the email is defined by the template mentioned in the
 * `RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE` system parameter
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_username
 * @param p_password
 * @param p_app_id
 */
procedure notify_reset_pwd_request (
    p_id in ks_users.id%type
   ,p_password in ks_users.password%type
   ,p_app_id in ks_parameters.value%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_reset_pwd_request';

  c_subject_notification constant varchar2(30) := 'Reset Password Request';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE');

  fetch_user_substitions (
    p_id => p_id
   ,p_substrings => l_substrings
  );
  fetch_common_links(l_substrings);

  l_substrings('TEMP_PASSWORD') := p_password;

  l_subject := c_subject_notification;

  send_email (
     p_to => l_substrings('USER_EMAIL')
    ,p_from => l_from
    ,p_cc => null
    ,p_bcc => null
    ,p_subject => l_subject
    ,p_body => null
    ,p_body_html => null
    ,p_template_name =>  l_template_name
    ,p_substrings => l_substrings
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_reset_pwd_request;



/**
 *
 * Notify a user after their password has been successfully changed (Reset Password)
 * The text of the email is defined by the template mentioned in the
 * `RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE` system parameter
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/13/2019
 * @param p_id ks_users.id
 */
procedure notify_reset_pwd_done (
    p_id in ks_users.id%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_reset_pwd_done';

  c_subject_notification constant varchar2(30) := 'Reset Password Done';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE');
  l_subject := c_subject_notification;

  fetch_user_substitions (
    p_id => p_id
   ,p_substrings => l_substrings
  );
  fetch_common_links(l_substrings);

  send_email (
     p_to => l_substrings('USER_EMAIL')
    ,p_from => l_from
    ,p_cc => null
    ,p_bcc => null
    ,p_subject => l_subject
    ,p_body => null
    ,p_body_html => null
    ,p_template_name =>  l_template_name
    ,p_substrings => l_substrings
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_reset_pwd_done;






/**
 * Notify track owners and/or voters when a session is moved between tracks.
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @param p_event_track_id
 * @param p_old_event_track_id
 * @param p_notify_owners_ind when 'Y', the notification will be send to track owners
 * @param p_notify_voters_ind when 'Y', the notification will be send to all voters
 */
procedure notify_session_move (
    p_id in ks_sessions.id%type
   ,p_event_track_id in ks_sessions.event_track_id%type
   ,p_old_event_track_id in ks_sessions.event_track_id%type
   ,p_notify_owners_ind in varchar2
   ,p_notify_voters_ind in varchar2
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_session_move';
  c_subject_notification constant varchar2(30) := 'Session Moved Between Tracks';

  cursor email_list_c
  is
    with user_emails as (
    select distinct u.email
      from ks_user_event_track_roles uetr
      join ks_users u
        on uetr.username = u.username
     where u.email is not null
       and (
            ( p_notify_owners_ind = 'Y'
              and uetr.selection_role_code in ('OWNER'))
            or
            ( p_notify_voters_ind = 'Y'
               and uetr.voting_role_code is not null))
       and uetr.event_track_id in (p_event_track_id, p_old_event_track_id)
      )
    select listagg ( ue.email,',') within group (order by ue.email desc) as email_list
      from user_emails ue;


  l_to varchar2(4000);
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;

  l_substrings t_WordList;
  l_session ks_sessions%rowtype;
  l_event_track ks_event_tracks%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param session id : ' || p_id, l_scope);
  ks_log.log('param current event track id : ' || p_event_track_id, l_scope);
  ks_log.log('param old event track id : ' || p_old_event_track_id, l_scope);
  ks_log.log('param p_notify_owners_ind : ' || p_notify_owners_ind, l_scope);
  ks_log.log('param p_notify_voters_ind : ' || p_notify_voters_ind, l_scope);

  open email_list_c;
  fetch email_list_c into l_to;
  close email_list_c;
  ks_log.log('email list : ' || l_to, l_scope);

  if l_to is not null then
    l_session := fetch_session_details (p_id);
    l_substrings('SESSION_TITLE') := l_session.title;
    l_substrings('SUB_CATEGORY') := nvl(l_session.sub_category, '-');
    l_substrings('SESSION_TYPE') := nvl(l_session.session_type, '-');
    l_substrings('SPEAKER') := l_session.presenter;

    l_event_track := fetch_track_details (p_event_track_id);
    l_substrings('TO_TRACK') := l_event_track.name;

    l_event_track := fetch_track_details (p_old_event_track_id);
    l_substrings('FROM_TRACK') := l_event_track.name;

    l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
    l_subject := c_subject_notification;
    l_template_name := ks_util.get_param('SESSION_MOVED_BETWEEN_TRACKS_TEMPLATE');

    send_email (
      p_to => l_to
     ,p_from => l_from
     ,p_cc => null
     ,p_bcc => null
     ,p_subject => l_subject
     ,p_body => null
     ,p_body_html => null
     ,p_template_name =>  l_template_name
     ,p_substrings => l_substrings
   );
  end if;

  ks_log.log('END', l_scope);
  exception
    when others then
      ks_log.log('Unhandled Exception ', l_scope);
      raise;
end notify_session_move;

end ks_notification_api;
/

-- #36
-- @../plsql/ks_session_api.pls
create or replace package ks_session_api
is

--------------------------------------------------------------------------------
--*
--* 
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter_user_id in ks_sessions.presenter_user_id%TYPE);
  
procedure switch_votes (
	p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username 	  in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
);


function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N',
                                  p_escape_html in varchar2 default 'Y')
  return varchar2;


procedure session_id_navigation (
   p_id in ks_sessions.id%type
  ,p_region_static_id in varchar2
  ,p_page_id in number
  ,p_previous_id out ks_sessions.event_track_id%type
  ,p_next_id out ks_sessions.event_track_id%type
  ,p_total_rows out number
  ,p_current_row out number
);


function is_session_owner (
  p_session_id in ks_sessions.id%type
 ,p_username   in varchar2
)
return varchar2;


function parse_video_link (
  p_video_link in ks_sessions.video_link%type
)
return varchar2;

function get_presenter_comp (
    p_event_id in ks_sessions.event_id%type 
  , p_event_track_id in ks_sessions.event_track_id%type  
  , p_presenter_user_id in ks_sessions.presenter_user_id%type 
) return number;

end ks_session_api;
/
-- @../plsql/ks_session_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
create or replace package body ks_session_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 * @constant gc_html_whitelist_tags a list of strings to NOT escape from. Same as the apex version but includes span and em
 * @constant gc_token_exceptions is a "|" separated list that gets passed into ks_util. It contains the tokens which we want to ommit from escaping.
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

gc_html_whitelist_tags constant varchar2(500) := '<h1>,</h1>,<h2>,</h2>,<h3>,</h3>,<h4>,</h4>,<p>,<span>,</span>,</p>,<b>,</b>,<strong>,</strong>,<i>,</i>,<ul>,</ul>,<ol>,</ol>,<li>,</li>,<br />,<hr/>,<em>,</em>';
gc_token_exceptions constant varchar2(4000) := 'oracle|apex|epm|and|its|it|of';
gc_parameter_tokens_name constant ks_parameters.name_key%type := 'ANONYMIZE_EXTRA_TOKENS';



/**
 * Private function, checks if the speaker/presenter is comped, i.e. is added to the list of comped users for the event
 *
 * @example
 *
 * @issue #36
 *
 * @author Ramona Birsan
 * @created October 8, 2019
 * @param p_presenter_user_id
 * @return 1 if speaker/presenter is comped
 */
function is_speaker_comped (
    p_event_id in ks_sessions.event_id%type
  , p_presenter_user_id in ks_sessions.presenter_user_id%type
) return number
is
  pragma UDF;
  l_scope  ks_log.scope := gc_scope_prefix || 'is_speaker_comped';
  -- l_params logger.tab_param; 
  l_is_comped number(1) := 0;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END
 
  select 1 into l_is_comped
    from ks_event_comp_users cu 
    join ks_users u on (u.id = cu.user_id)
   where cu.event_id = p_event_id
     and u.external_sys_ref = p_presenter_user_id;
     
  return l_is_comped;
  
  exception 
    when no_data_found then
      return 0;
    when others then
      ks_log.log('Unhandled Exception ', l_scope);
      raise;
end is_speaker_comped;






------------------------------------------------------------------------------
/**
 *  Output of the form:
 *    apex_json.open_object;
 *    apex_json.write('p_presenter_user_id', p_presenter_user_id);
 *    apex_json.write('trackList', '<ul><li>Track 1</li></ul>');
 *    apex_json.close_object;
 *
 * @example
 *
 * @issue #36 - use presenter_user_id to fetch the list of tracks
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param p_event_id
 * @param p_presenter_user_id
 * @return
 */
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter_user_id in ks_sessions.presenter_user_id%TYPE)
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'presenter_tracks_json';
  -- l_params logger.tab_param;

  list_cur sys_refcursor;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  -- logger.log('BEGIN', l_scope, null, l_params);

  open list_cur for
    select p_presenter_user_id "presenter_user_id"
          ,'<ul><li>' ||listagg(n || ' in ' || p || ' (' || status || ')', '</li><li>') within group (order by display_seq) || '</li></ul>' "trackList"
    from (
      select t.display_seq, nvl(t.alias, t.name) p, count(*) n
           , listagg(nvl(st.name, '?'), ',') within group (order by st.display_seq) status
        from ks_event_tracks t
           , ks_sessions s
           , ks_session_status st
       where t.id = s.event_track_id
         and s.event_id = to_number(p_event_id)
         and s.presenter_user_id = p_presenter_user_id
         and s.status_code = st.code (+)
       group by t.display_seq, nvl(t.alias, t.name)
    );

  apex_json.write(list_cur);

  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    apex_json.open_array;
    apex_json.open_object;
    apex_json.write('p_presenter_user_id', p_presenter_user_id);
    apex_json.write('trackList', 'Unable to fetch list:<br>' || sqlerrm || '<br>');
    apex_json.close_object;
    apex_json.close_array;
end presenter_tracks_json;






/**
 * Switch votes and voting role of an user for a selected event / track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 26, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_username username of the user.
 * @param p_voting_role selected voting role for the user.
 */
procedure switch_votes (
  p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username    in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
)
is

begin

  -- Move all votes to new vote_type
  update ks_session_votes
     set vote_type = p_voting_role
   where id in (
      select sv.id
        from ks_session_votes sv
           , ks_sessions s
       where sv.username = p_username
         and s.event_id = p_event_id
         and s.event_track_id = p_track_id
         and sv.session_id = s.id);

  update ks_user_event_track_roles
     set voting_role_code = p_voting_role
   where username = p_username
     and event_track_id = p_track_id;

end switch_votes;







--==============================================================================
-- Function: html_whitelist_clob
-- Purpose: returns a varchar2 where every chunk of 4000 characters has been html_whitelisted and tokenized
--
-- Inputs:  p_string - the clob or varchar2 to be escaped/tokenized
--          p_session_id - the session id. We use this to get the name of the presenter/company/co-presenter
--          p_anonymize - whether to hide the info
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function html_whitelist_tokenize (p_string in varchar2,
                                  p_session_id in number,
                                  p_anonymize in varchar2 default 'N',
                                  p_escape_html in varchar2 default 'Y')
  return varchar2
is
  l_scope ks_log.scope := gc_scope_prefix || 'html_whitelist_tokenize';

  l_output varchar2(32767);

  l_presenter    ks_sessions.presenter%type;
  l_co_presenter ks_sessions.co_presenter%type;
  l_company      ks_sessions.company%type;
begin
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END

  --The id is usually null when the user's session got reset
  --We don't want to create an ugly error on top of the page already showing errors
  --So silently exit.
  if p_session_id is null then
    return '';
  end if;

  if p_escape_html = 'Y' then
    l_output := apex_escape.html_whitelist(p_string, gc_html_whitelist_tags);
  else
    l_output := p_string;
  end if;
  l_output := regexp_replace(l_output, '_x000D_', '', 1, 0, 'i');

  if p_anonymize = 'Y' then
    select s.presenter, s.company, s.co_presenter
      into l_presenter, l_company, l_co_presenter
      from ks_sessions s
     where s.id = p_session_id;

     l_output := ks_util.replace_tokens(l_output 
                                      , l_presenter || ' ' || l_company || ' ' || l_co_presenter ||' ' || ks_util.get_param(gc_parameter_tokens_name)
                                      , gc_token_exceptions);


  end if;



  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  html_whitelist_tokenize;



/**
 * Get the following data to allow navigation of the sessions:
 *    - Previous Session ID
 *    - Next Session ID
 *    - Current Row
 *    - Total Row
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 1, 2018
 * @param p_id
 * @param p_region_static_id
 * @param p_page_id
 * @return
 * @param p_previous_id
 * @param p_next_id
 * @param p_total_rows
 * @param p_current_row
 */
procedure session_id_navigation (
   p_id in ks_sessions.id%type
  ,p_region_static_id in varchar2
  ,p_page_id in number
  ,p_previous_id out ks_sessions.event_track_id%type
  ,p_next_id out ks_sessions.event_track_id%type
  ,p_total_rows out number
  ,p_current_row out number
)
is
  l_report apex_ir.t_report;
  l_sql clob;
  l_next_id number;
  l_previous_id number;
  l_order_by varchar2 (32000);
  l_cur number;
  l_res number;
  l_total_rows number;
  l_row_num number;
  l_alias varchar2(1);
  l_scope ks_log.scope := gc_scope_prefix || 'session_id_navigation';

begin
  ks_log.log('START', l_scope);

  l_report := ks_util.get_ir_report (
      p_page_id => p_page_id
    , p_static_id => p_region_static_id
  );
          
  l_sql := l_report.sql_query;  
  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('l_sql:' || l_sql, l_scope);
  $END

  $IF wwv_flow_api.c_current >= 20180404 $THEN
    -- in 18.1 the alias changed from r to i
    l_alias := 'i';
  $ELSE
    l_alias := 'r';
  $END

  --l_report.sql_query selects the columns indicated on the option "menu Action > Select Columns" from the SQL Query indicated on the App Builder's IR Configuration.
  --The following line replaces the list of selected columns on l_report.sql_query by all the columns.
  --Ex: SESSION_NUM is not displayed on the IR, so it is not selected on l_report.sql_query.
  --Selecting all the columns with r.*, allows to order by any column indicated on the option "menu Action > Data > Sort" even if it is not included on "menu Action > Select Columns".
  --Also, the total number of rows is calculated at this level.
  l_sql := 'select count (id) over () as total_rows'
       || ',' || l_alias || '.*'
       || substr (l_sql, instr (l_sql, ' from '));

  l_order_by := ks_util.get_ir_order_by (p_ir_query => l_sql);
  $IF wwv_flow_api.c_current >= 20180404 $THEN
  -- in APEX 18.1 the order by construct changed and got an extra wrap ")i"
  if instr(l_order_by, ')i') > 0 then
    l_order_by := substr(l_order_by, 1, instr(l_order_by, ')i') -1);
  end if;
  $END

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('order by:' || l_order_by, l_scope);
  $END

  if l_order_by is null then
    l_order_by := 'order by session_num';
  end if;

  l_sql := 'select next
      ,previous
      ,total_rows
      ,row_num
    from (' ||
        '   select    id
                    , lead (id) over ( ' || l_order_by || ') next ' ||
        '           , lag (id) over ( ' || l_order_by || ') previous ' ||
        '           , total_rows ' ||
        '           , row_number () over ( ' || l_order_by || ') as row_num ' ||
        '   from (' || l_sql || 
        ' ))  where id=:ID';

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('New l_sql:' || l_sql, l_scope);
  $END

  l_cur := dbms_sql.open_cursor;

  dbms_sql.parse (l_cur, l_sql, dbms_sql.native);

  for i in 1..l_report.binds.count
  loop
    dbms_sql.bind_variable (l_cur, l_report.binds(i).name, l_report.binds(i).value);
    $IF $$VERBOSE_OUTPUT $THEN
      ks_log.log (l_report.binds(i).name || ':' || l_report.binds(i).value, l_scope);
    $END
  end loop;

  dbms_sql.bind_variable (l_cur, 'ID', p_id);
  dbms_sql.define_column (l_cur, 1, p_next_id);
  dbms_sql.define_column (l_cur, 2, p_previous_id);
  dbms_sql.define_column (l_cur, 3, p_total_rows);
  dbms_sql.define_column (l_cur, 4, p_current_row);

  l_res := dbms_sql.execute(l_cur);

  if dbms_sql.fetch_rows (l_cur) > 0 then
    dbms_sql.column_value (l_cur, 1, p_next_id);
    dbms_sql.column_value (l_cur, 2, p_previous_id);
    dbms_sql.column_value (l_cur, 3, p_total_rows);
    dbms_sql.column_value (l_cur, 4, p_current_row);
  end if;

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('p_next_id:' || p_next_id, l_scope);
    ks_log.log('p_previous_id:' || p_previous_id, l_scope);
    ks_log.log('p_total_rows:' || p_total_rows, l_scope);
    ks_log.log('p_current_row:' || p_current_row, l_scope);
  $END

  dbms_sql.close_cursor (l_cur);
  ks_log.log('END', l_scope);
exception
  when others then
    if dbms_sql.is_open (l_cur) then
      dbms_sql.close_cursor (l_cur);
    end if;

    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  session_id_navigation;




/**
 * For a given track session and user, indicate if the given user is the presenter 
 * or copresenter of the session.
 * The comparison is done against the ks_users.external_sys_ref which identifies users
 * in the external system.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 5, 2018
 * @param p_id
 * @return 'Y','N'
 */
function is_session_owner (
  p_session_id in ks_sessions.id%type
 ,p_username   in varchar2
)
return varchar2
is 
  l_scope ks_log.scope := gc_scope_prefix || 'is_session_owner';
  
  l_return varchar2(1) := 'N';

  l_external_sys_ref ks_users.external_sys_ref%type;
  l_presenter_user_id ks_sessions.presenter_user_id%type;
  l_co_presenter_user_id ks_sessions.co_presenter_user_id%type;
begin
  ks_log.log('START', l_scope);

  select s.presenter_user_id
       , s.co_presenter_user_id
    into l_presenter_user_id
       , l_co_presenter_user_id
    from ks_sessions s
   where s.id = p_session_id;

  select u.external_sys_ref
    into l_external_sys_ref
    from ks_users u
   where u.username = p_username;

  if l_external_sys_ref in (l_presenter_user_id, l_co_presenter_user_id) then
    l_return := 'Y';
  end if;

  ks_log.log('END', l_scope);
  return l_return;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end is_session_owner;




/**
 * Parse the "video link" text returning one line per link and formatting the link as an html anchor tag when applied.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 15, 2018
 * @param p_video_link
 * @return parsed text containing the link as a html anchor tag.
 */
function parse_video_link (
  p_video_link in ks_sessions.video_link%type
)
return varchar2
is 
  l_scope ks_log.scope := gc_scope_prefix || 'parse_video_link';
  
  c_link_format constant varchar2(1000) := '<a id="VIDEO_URL" href="#LINK#" target="_blank" alt="Video" title="Video">#LINK#</a>';
  
  l_links apex_t_varchar2;
  l_key varchar2(1000);
  l_link varchar2(32000);
  l_return varchar2(32000);
  l_is_not_first_line boolean := FALSE;
begin
  ks_log.log ('START', l_scope);

  l_links := apex_string.split(p_video_link, '<br />');
  l_key := l_links.first;
  
  while (l_key is not null)
  loop
    l_link := l_links (l_key);

    if substr (trim (l_link), 1, 4) = 'http' then 
      l_link := replace (c_link_format, '#LINK#', l_link);
    end if;

    if l_is_not_first_line then 
      l_return := l_return || '<br>' || l_link;
    else 
      l_return := l_link;
      l_is_not_first_line := TRUE;
    end if;

    l_key := l_links.next (l_key);
  end loop;

  ks_log.log ('END', l_scope);
  return l_return;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end parse_video_link;






/**
 * The function returns presenter's comp per track - this is identical for all tracks 
 * for which the user has submitted sessions.
 * Assumes that it will be called from within a SQL query, hence no track validation.
 * And the UDF pragma
 * 
 * @example - Displays presenter's comp for each associated track
    select  s.event_track_id
          , s.presenter_user_id
          , ks_session_api.get_presenter_comp(s.event_id, s.event_track_id , s.presenter_user_id) as presenter_comp
       from ks_sessions s
      where s.event_id = :p_event_id
        and s.presenter_user_id = :p_presenter_user_id
   group by s.event_id, s.event_track_id, s.presenter_user_id
   order by s.event_track_id
 *
 * @issue #36
 *
 * @author Ramona Birsan
 * @created October 7, 2019
 * @param p_event_id   
 * @param p_event_track_id
 * @param p_presenter_user_id
 * @return number
 */
function get_presenter_comp (
    p_event_id in ks_sessions.event_id%type 
  , p_event_track_id in ks_sessions.event_track_id%type    
  , p_presenter_user_id in ks_sessions.presenter_user_id%type 
) return number
is 
  pragma UDF;

  l_scope  ks_log.scope := gc_scope_prefix || 'get_presenter_comp';
  -- l_params logger.tab_param;
  l_presenter_comp number(3,2) := 0;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_event_track_id', p_event_track_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END
  
  if is_speaker_comped (p_event_id, p_presenter_user_id) = 1 then 
    l_presenter_comp := 0;
  else
    -- "distinct event_track_id" is used because we calculate the total number of 
    -- tracks which have at least one session accepted
    with speaker_comp_track_ratio as (
      select  r.presenter_user_id
            , round(1/sum (r.track_comp),2) as speaker_comp_ratio
        from (
             select s.presenter_user_id
                  , count(distinct s.event_track_id) as track_comp
               from ks_sessions s
              where s.status_code = 'ACCEPTED' 
                and s.event_id = p_event_id 
              group by s.event_track_id, s.presenter_user_id 
         ) r
       group by r.presenter_user_id
      having r.presenter_user_id = p_presenter_user_id
    )
    select count (*) * tr.speaker_comp_ratio 
      into l_presenter_comp
      from speaker_comp_track_ratio tr
     where exists ( select 1
                      from ks_sessions ss
                     where ss.status_code = 'ACCEPTED'
                       and ss.event_id = p_event_id
                       and ss.event_track_id = p_event_track_id
                       and ss.presenter_user_id = p_presenter_user_id)
     group by tr.speaker_comp_ratio;
      
  end if;
  
  return l_presenter_comp;

  exception
    when no_data_found then
      return l_presenter_comp;
    when others then
      ks_log.log_error('Unhandled Exception ', l_scope);
      raise;
end get_presenter_comp;



end ks_session_api;
/

-- #44
-- @../plsql/ks_session_load_api.pls
create or replace package ks_session_load_api
is

--------------------------------------------------------------------------------
--*
--*
--*
--------------------------------------------------------------------------------

-- CONSTANTS

--------------------------------------------------------------------------------


procedure load_xlsx_data (
    p_xlsx      in blob
  , p_username  in varchar2 default v('APP_USER')
);

function validate_data(
    p_into_event_id in ks_event_tracks.event_id%TYPE
) return boolean;

procedure load_sessions (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
  , x_load_count in out number
);

procedure purge_event(
    p_event_id			in ks_sessions.event_id%TYPE
  , p_track_id			in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind	in varchar2
  , p_force_ind			in varchar2
);

procedure create_loaded_session_coll (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
);

procedure toggle_track_notification(p_seq_id in number);


end ks_session_load_api;
/
-- @../plsql/ks_session_load_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
create or replace package body ks_session_load_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix: Standard logger package name
 * @constant gc_all_clob_columns: comma separeted list of columns that are clobs
 * @constant c_loaded_session_coll: Name of the collection created during the load session wizard
 * @column_names_t: is the table type for columns taken from the export file.
 * @c_max_errors_to_display: the maximum number of errors to display to the user.
 * @index_map_t: maps column numbers from the export file to column names in ks_full_session_load
*/
gc_scope_prefix      constant varchar2(31) := lower($$PLSQL_UNIT) || '.';
gc_all_clob_columns  constant varchar2(4000) := 'SESSION_DESCRIPTION';
c_session_load_table constant varchar2(30) := 'KS_FULL_SESSION_LOAD';
c_loaded_session_coll constant varchar2 (30) := 'LOADED_SESSIONS';

c_max_errors_to_display constant number := 6;

type column_names_t is varray(4000) of varchar2(4000);

-- type index_map_t is table of varchar2(30) index by varchar2(10);
type index_map_t is table of varchar2(30) index by pls_integer;



--==============================================================================
-- Function: add_error_check_continue
-- Purpose: Wrapper function for apex_error. It logs the error and if we've reached the threshold c_max_errors_to_display we return false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function add_error_check_continue (p_message in varchar2,
                                   p_display_location in varchar2)
  return boolean
is
  l_scope ks_log.scope := 'add_error_check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);

  apex_error.add_error(
            p_message => p_message
          , p_display_location => p_display_location
        );

  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end add_error_check_continue;




--==============================================================================
-- Function: check_continue
-- Purpose: Checks if we've reached the threshold c_max_errors_to_display. If so, then it returns false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function check_continue
  return boolean
is
  l_scope ks_log.scope := 'check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);


  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end check_continue;




--==============================================================================
-- Function: validate_uniqueness
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_uniqueness
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_uniqueness';

  l_count number;
  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select session_num
      from ks_full_session_load
     where app_user = l_username
     group by session_num
    having count(*) > 1
  )
  loop
    if not add_error_check_continue(p_message => 'The session_number "' || row.session_num || '", is not unique. Correct to continue.'
                             ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;

  --Do the same thing for external_sys_ref
  for row in (
    select external_sys_ref
      from ks_full_session_load
     where app_user = l_username
     group by external_sys_ref
     having count(*) > 1
  )
  loop
    if not add_error_check_continue(
        p_message => 'The session id (external system reference) "' || row.external_sys_ref || '", is not unique. Correct to continue.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;

  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_uniqueness;



--==============================================================================
-- Function: validate_not_null
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_not_null
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_not_null';

  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select title
      from ks_full_session_load
     where app_user = l_username
       and ( session_num is null
          or external_sys_ref is null
        )
  )
  loop
    if not add_error_check_continue(
        p_message => 'Session "' || substr(row.title,1,20) || '" is missing a session_num or external_sys_ref.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  for row in (
    select session_num || ':' || title name
      from ks_full_session_load
     where app_user = l_username
       and event_track_id is null
  )
  loop
    if not add_error_check_continue(
        p_message => 'Session "' || substr(row.name,1,20) || '" is missing a track.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_not_null;



--==============================================================================
-- Function: validate_new_session
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_new_session(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_new_session';

  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select sl.session_num
      from ks_full_session_load sl
         , ks_sessions s
     where sl.app_user = l_username
       and s.session_num = sl.session_num
       and s.event_id = p_into_event_id
  )
  loop
    if not add_error_check_continue(
        p_message => 'A session with session number "' || row.session_num || '" already exists for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  for row in (
    select sl.external_sys_ref
      from ks_full_session_load sl
         , ks_sessions s
     where sl.app_user = l_username
       and s.external_sys_ref = sl.external_sys_ref
       and s.event_id = p_into_event_id
  )
  loop
    if not add_error_check_continue(
        p_message => 'A session with session id (external_sys_ref) "' || row.external_sys_ref || '" already exists for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_new_session;




--==============================================================================
-- Function: validate_correct_tracks
-- Purpose:
--
-- Inputs: p_into_event_id - the id of the event
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_correct_tracks(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_correct_tracks';

  l_username varchar2(60);

begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  --First check the track
  -- Sorry, ks_full_session_load.event_track_id is not an ID at all but a name!
  for row in (
    select distinct sl.event_track_id
      from ks_full_session_load sl
     where sl.app_user = l_username
       and sl.event_track_id not in (
        select name
          from ks_event_tracks
         where event_id = p_into_event_id
     )
  )
  loop
    if not add_error_check_continue(
        p_message => 'The track "'|| row.event_track_id ||'" does not exist for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      ks_log.log('Missing track, Abort!', l_scope);
      return false;
    end if;
  end loop;

  ks_log.log('END', l_scope);
  
  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_correct_tracks;





--==============================================================================
-- Function: validate_data
-- Purpose: Runs validations checks on the data. This occurs after ks_full_session_load is loaded and it's columns are validated,
--             but before we have submitted it's data to the corresponding tables.
--
-- Inputs: p_into_event_id, the id the of the event
-- Output: whether the data is avalid or not
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function validate_data(p_into_event_id ks_event_tracks.event_id%TYPE)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_data';

begin
  ks_log.log('START', l_scope);

  if not validate_uniqueness
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_not_null
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_new_session(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_correct_tracks(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_data;





--==============================================================================
-- Function: validate_column_names
-- Purpose: This makes sure that the first row of the .xlsx file contains row names FOR EACH column in ks_session_load (minus event_id, track_id, and app_user)
--
-- Inputs: p_column_names - varray of column names
-- Output: returns true if valid, false if invalid
-- Scope: Not  Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/09/2017
--==============================================================================
function validate_column_names (p_column_names in column_names_t)
return boolean
is
  l_scope ks_log.scope := 'validate_column_names';
  --l_params logger.tab_param;
  type column_names_dict_t is table of varchar2(20) index by varchar2(4000);
  l_column_names_dict column_names_dict_t;

  i number := 0;
  idx varchar2(4000);
begin
  --logger.append_param(l_params, 'p_column_names', p_column_names);
  ks_log.log('START', l_scope);


  for row in (
    select trim(upper(lm.header_name)) header
      from ks_load_mapping lm
     where table_name = c_session_load_table
  )
  loop
    l_column_names_dict(row.header) := 'not_matched';
  end loop;

  for i in 1..p_column_names.count
  loop
      if not l_column_names_dict.exists(trim(upper(p_column_names(i))))
      then
        if not add_error_check_continue(p_message => 'The column "' || p_column_names(i) || '" does not match any column names specified in the instructions.'
                                     ,  p_display_location => apex_error.c_inline_in_notification
                            )
        then
          return false;
        end if;
      else
        l_column_names_dict(trim(upper(p_column_names(i)))) := 'matched';
      end if;
  end loop;

  ks_log.log('before l_column_names_dict loop', l_scope);

  idx := l_column_names_dict.first;
  while idx is not null
  loop
    if l_column_names_dict(idx) = 'not_matched'
    then
      ks_log.log('Not matched l_column_names_dict(' || idx || '):', l_scope);
      if not add_error_check_continue(p_message => 'The column "' || initcap(idx) || '", was not found in the file. Please ensure this column exists in the file.'
                       ,  p_display_location => apex_error.c_inline_in_notification
                            )
       then
        return false;
       end if;
    end if;
    idx := l_column_names_dict.next(idx);
  end loop;

  ks_log.log('after l_column_names_dict loop. Errors:' || apex_error.get_error_count, l_scope);

  if apex_error.get_error_count > 0 then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_names;




--==============================================================================
-- Function: validate_column_order
-- Purpose: validates that the columns provided in the export file are in the correct order
--
-- Inputs:  p_column_names - an array of colum names
-- Output: returns true if valid, false if invalid
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes: THIS FUNCTION IS NOT USED - the function works, but turned out to not be useful.
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
function validate_column_order (p_column_names in column_names_t)
  return boolean
is
  l_scope ks_log.scope := 'validate_column_order';
  --l_params logger.tab_param;
  l_idx number := 1;
  l_columns_in_their_order varchar2(4000);
begin
  --logger.append_param(l_params, 'p_column_names', p_column_names);
  ks_log.log('START', l_scope);

  for row in (select trim(upper(lm.header_name)) header_name,
                     display_seq
              from ks_load_mapping lm
             where 1=1
            and table_name = c_session_load_table
            and lm.to_column_name is not null
            order by lm.display_seq
            )
  loop
    if p_column_names(row.display_seq) != row.header_name
    then
      select listagg(lm.header_name, ', ') within group (order by lm.display_seq) value
        into l_columns_in_their_order
        from ks_load_mapping lm
        where 1=1
          and table_name = c_session_load_table;


        apex_error.add_error(
                  p_message => 'The columns in the export file are in an incorrect order. The proper order is: ' ||
                                  l_columns_in_their_order || '. At least this column is out of order: ' || p_column_names(l_idx)
                , p_display_location => apex_error.c_inline_in_notification
              );
      --This is a big error (lots of text), so exit here regardless of number of errors.
      return false;
    end if;

  end loop;

  return true;
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_order;



--==============================================================================
-- Procedure: init_index_map
-- Purpose: After the column names have been validated from the file,
--            we need to map which columns headers in the export go to which columns in ks_full_session_load
-- ASUMPTION(S): Column names are valid, and there aren't any missing
-- Inputs:  l_column_names - column names from the import file
--          l_cells - the final table we will create our view from.
-- Output:
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
procedure init_index_map ( p_index_map in out nocopy index_map_t)
is
  l_scope ks_log.scope := gc_scope_prefix || 'init_index_map';
  --l_params logger.tab_param;

  l_index pls_integer;
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);

  for row in (
    select m.to_column_name
         , m.display_seq
      from ks_load_mapping m
     where m.table_name = c_session_load_table
     order by m.display_seq
  )
  loop
    p_index_map(p_index_map.count + 1) := nvl(row.to_column_name, '- not mapped -');
    ks_log.log('mapped: ' || p_index_map.count || ' to '  || row.to_column_name, l_scope);
  end loop;

  ks_log.log('map size: ' || p_index_map.count, l_scope);

  $IF $$VERBOSE_OUTPUT $THEN
  l_index := p_index_map.first;
  while l_index is not null
  loop
    ks_log.log('p_index_map(' || l_index ||'): ' || p_index_map(l_index), l_scope);    
    l_index := p_index_map.next(l_index);
  end loop;
  $END

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end init_index_map;


/**
 * Load data from xlsx into appropriate collection for parsing. All data is
 * loaded to into the session APP_USER
 *
 * @example
 * 
 * @issue
 *
 * @author Ben Shumway (Insum Solutions)
 * @created Oct/09/2017
 * @param p_xlsx blob with all data
 */
procedure load_xlsx_data (
    p_xlsx      in blob
  , p_username  in varchar2 default v('APP_USER')
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'load_xlsx_data';

  l_column_names column_names_t;

  l_cells as_read_xlsx_clob.tp_all_cells;
  l_curr_row number;

  l_rows_row number;

  type session_load_row_t is table of ks_full_session_load%rowtype;
  l_rows session_load_row_t;

  l_curr_col varchar2(30);

  --column index for spreadsheet_content
  l_col_ind number;

  l_index_map index_map_t;
  l_index pls_integer;

  --used to get the first 4000 bytes of any string data
  l_substr varchar2(4000);
  --used to get the length of the string data
  l_substr_len number;

  l_string_val clob;
  l_number_val number;
  l_date_val date;

  l_reached_final_line boolean := false;

  --An array of tags
  l_tags apex_application_global.vc_arr2;

  --An array of session_length
  l_session_length apex_application_global.vc_arr2;
    

begin
   --logger.append_param(l_params, 'p_username', p_username);
   --logger.append_param(l_params, 'p_into_event_id', p_into_event_id);
   --logger.append_param(l_params, 'p_into_track_id', p_into_track_id);
   ks_log.log('BEGIN', l_scope);

   l_column_names := column_names_t();
   l_rows := session_load_row_t();

   select *
    bulk collect into l_cells
    from table(AS_READ_XLSX_CLOB.read(p_xlsx => p_xlsx))
   order by row_nr, col_nr;

   for i in 1 ..  l_cells.count
   loop
      l_curr_row := l_cells(i).row_nr;
      $IF $$VERBOSE_OUTPUT $THEN
      ks_log.log('BEGIN cell: ' ||  l_cells(i).row_nr || ',' || l_cells(i).col_nr, l_scope);
      $END

      --NOTE: Assumption, the bulk collect gets all cells in order by row then column
      if l_curr_row = 2 and l_cells(i).col_nr = 1
      then
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('Length of l_column_names: ' || l_column_names.count, l_scope);
        $END
        if not ks_session_load_api.validate_column_names(l_column_names) then
          return;
        end if;

        --modify l_cells so that the column names are correct
        init_index_map(l_index_map);

      elsif l_curr_row = 1 then
        l_column_names.extend;
        --Get the column name (allows the .xlsx header to be defined "fuzzilly"
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('Adding name: "' || l_cells(i).string_val || '"" to (' || i || ')', l_scope);
        $END
        l_column_names(i) := trim(upper(cast(l_cells(i).string_val as varchar2)));
     end if;

     $IF $$VERBOSE_OUTPUT $THEN
     ks_log.log('i: ' || i, l_scope);
     $END

     if l_curr_row > 1 then

        if l_rows.count < l_curr_row -1 then
          if l_reached_final_line then
            l_rows.delete(l_rows.count);
            exit;
          else
            l_reached_final_line := true; --Considered true until proven otherwise
          end if;
          l_rows.extend;
        end if;

        -- l_string_val := coalesce(l_cells(i).string_val, to_char(l_cells(i).number_val), to_char(l_cells(i).date_val));

        l_string_val := trim(l_cells(i).string_val);
        l_number_val := l_cells(i).number_val;
        l_date_val := l_cells(i).date_val;

        l_rows_row := l_curr_row -1;

        if   l_string_val is not null
          or l_number_val is not null
          or l_date_val is not null
        then
          l_reached_final_line := false;
        end if;
        
        if l_number_val is not null
        then
          $IF $$VERBOSE_OUTPUT $THEN
          ks_log.log('found number column, converting to vc', l_scope);
          $END
          l_string_val := to_char(l_number_val);
        end if;

        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('current:' || l_string_val, l_scope);
        $END


        --The commented out code shows when the as_read_xlsx_clob package skips cells
        /*ks_log.log('Checking existence of: ' || to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end) || ', l_cells(i).col_nr: ' || l_cells(i).col_nr 
                                                                       || ', string_val: ' || l_cells(i).string_val );
        l_index := to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end);*/
        l_index := l_cells(i).col_nr;
        if l_index_map.exists(l_index) then

          l_curr_col := l_index_map(l_index);
          $IF $$VERBOSE_OUTPUT $THEN
          ks_log.log('l_curr_col: ' || l_curr_col, l_scope);
          $END
          
          if l_curr_col = 'EXTERNAL_SYS_REF'
          then            
            l_rows(l_rows_row).external_sys_ref := l_string_val;
          elsif l_curr_col = 'SESSION_NUM'
          then
            l_rows(l_rows_row).session_num :=  l_string_val;
          elsif l_curr_col = 'EVENT_TRACK_ID'
          then
            l_rows(l_rows_row).event_track_id := l_string_val;
          elsif l_curr_col = 'SUB_CATEGORY'
          then
            l_rows(l_rows_row).sub_category := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_TYPE'
          then
            l_rows(l_rows_row).session_type := substr(l_string_val,1,500);
          elsif l_curr_col = 'TITLE'
          then
            l_rows(l_rows_row).title := substr(l_string_val,1,500);
          elsif l_curr_col = 'ACE_LEVEL'
          then
            l_rows(l_rows_row).ace_level := substr(l_string_val,1,30);
          elsif l_curr_col = 'COMPANY'
          then
            l_rows(l_rows_row).company := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_ABSTRACT'
          then
            l_rows(l_rows_row).session_abstract := l_string_val;
          elsif l_curr_col = 'SESSION_SUMMARY'
          then
            l_rows(l_rows_row).session_summary := substr(l_string_val,1,4000);
          elsif l_curr_col = 'TARGET_AUDIENCE'
          then
            l_rows(l_rows_row).target_audience := substr(l_string_val,1,60);
          elsif l_curr_col = 'TECHNOLOGY_PRODUCT'
          then
            l_rows(l_rows_row).technology_product := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTED_BEFORE_IND'
          then
            l_rows(l_rows_row).presented_before_ind := l_string_val;
          elsif l_curr_col = 'PRESENTED_BEFORE_WHERE'
          then
            l_rows(l_rows_row).presented_before_where := substr(l_string_val,1,4000);
          elsif l_curr_col = 'PRESENTED_ANYTHING_IND'
          then
            l_rows(l_rows_row).presented_anything_ind := l_string_val;
          elsif l_curr_col = 'PRESENTED_ANYTHING_WHERE'
          then
            l_rows(l_rows_row).presented_anything_where := substr(l_string_val,1,4000);            
          elsif l_curr_col = 'VIDEO_LINK'
          then
            l_rows(l_rows_row).video_link := substr(l_string_val,1,4000);
          elsif l_curr_col = 'CO_PRESENTER'
          then
            l_rows(l_rows_row).co_presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_COMPANY'
          then
            l_rows(l_rows_row).co_presenter_company := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTER_BIOGRAPHY'
          then
            l_rows(l_rows_row).presenter_biography := l_string_val;
          elsif l_curr_col = 'PRESENTER'
          then
            l_rows(l_rows_row).presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'TAGS'
          then
            l_tags := apex_util.string_to_table(l_string_val,',');
            for i in 1..l_tags.count
            loop
              l_tags(i) := trim(l_tags(i));
            end loop;
            l_rows(l_rows_row).tags := substr(apex_util.table_to_string(l_tags,':'),1,1000);
          elsif l_curr_col = 'SESSION_LENGTH'
          then
            l_session_length := apex_util.string_to_table(l_string_val,',');
            for i in 1..l_session_length.count
            loop
              l_session_length(i) := trim(l_session_length(i));
            end loop;
            l_rows(l_rows_row).session_length := substr(apex_util.table_to_string(l_session_length,':'),1,500);
          elsif l_curr_col = 'CONTAINS_DEMO_IND'
          then
            l_rows(l_rows_row).contains_demo_ind := l_string_val;
          elsif l_curr_col = 'WEBINAR_WILLING_IND'
          then
            l_rows(l_rows_row).webinar_willing_ind := l_string_val;
          elsif l_curr_col = 'PRESENTER_EMAIL'
          then
            l_rows(l_rows_row).presenter_email := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).co_presenter_user_id := case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).presenter_user_id :=  case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'SUBMISSION_DATE'
          then
            -- l_rows(l_rows_row).submission_date := to_date(l_string_val, 'DD/MM/RR HH24:MI');
            l_rows(l_rows_row).submission_date := l_date_val;
          end if;

        end if;
      end if;
    end loop;


    ks_log.log('Removing previous load data (if present)', l_scope);
    delete 
      from ks_full_session_load s
     where app_user = p_username;


    ks_log.log('Inserting into ks_full_session_load', l_scope);
    forall i in l_rows.first .. l_rows.last
      insert into ks_full_session_load (
          app_user
        , external_sys_ref
        , session_num
        , event_track_id
        , sub_category
        , session_type
        , title
        , ace_level
        , presented_before_ind
        , presented_before_where
        , presented_anything_ind
        , presented_anything_where
        , video_link
        , co_presenter
        , co_presenter_company
        , presenter_biography
        , company
        , presenter
        , session_abstract
        , session_summary
        , tags
        , session_length
        , target_audience
        , technology_product
        , contains_demo_ind
        , webinar_willing_ind
        , presenter_email
        , co_presenter_user_id
        , presenter_user_id
        , submission_date
      )
      values (
          p_username
        , l_rows(i).external_sys_ref
        , l_rows(i).session_num
        , l_rows(i).event_track_id
        , l_rows(i).sub_category
        , l_rows(i).session_type
        , l_rows(i).title
        , l_rows(i).ace_level
        , l_rows(i).presented_before_ind
        , l_rows(i).presented_before_where
        , l_rows(i).presented_anything_ind
        , l_rows(i).presented_anything_where
        , l_rows(i).video_link
        , l_rows(i).co_presenter
        , l_rows(i).co_presenter_company
        , l_rows(i).presenter_biography
        , l_rows(i).company
        , l_rows(i).presenter
        , l_rows(i).session_abstract
        , l_rows(i).session_summary
        , l_rows(i).tags || nvl2(l_rows(i).session_length, nvl2(l_rows(i).tags, ':', ''), '') || l_rows(i).session_length
        , l_rows(i).session_length
        , l_rows(i).target_audience
        , l_rows(i).technology_product
        , l_rows(i).contains_demo_ind
        , l_rows(i).webinar_willing_ind
        , l_rows(i).presenter_email
        , l_rows(i).co_presenter_user_id
        , l_rows(i).presenter_user_id
        , l_rows(i).submission_date
      );

  ks_log.log('END', l_scope);
  
  exception when others
  then
    ks_log.log('ERROR', l_scope);
    raise;

end load_xlsx_data;



/**
 *
 *
 * @example
 *  ks_session_load_api.load_sessions(
 *      p_event_id   => :P5040_EVENT_ID
 *    , x_load_count => :P5041_ROW_COUNT
 *  );
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created January 6, 2018
 * @param p_event_id
 * @param p_username (optional)
 * @param x_load_count - final load count
 * @return
 */
procedure load_sessions (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
  , x_load_count in out number
)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'load_sessions';
begin
  ks_log.log('BEGIN', l_scope);

  insert into ks_sessions(
      event_id
    , event_track_id
    , external_sys_ref
    , session_num
    , sub_category
    , session_type
    , title
    , presenter
    , company
    , co_presenter
    , co_presenter_company
    , tags
    , presenter_email
    , session_abstract
    , session_summary
    , target_audience
    , presented_before_ind
    , presented_before_where
    , presented_anything_ind
    , presented_anything_where
    , technology_product
    , ace_level
    , video_link        
    , contains_demo_ind
    , webinar_willing_ind
    , presenter_biography
    , co_presenter_user_id
    , presenter_user_id
    , submission_date
   )            
  select p_event_id
       , e.id
       , s.external_sys_ref
       , s.session_num
       , s.sub_category
       , s.session_type
       , s.title
       , s.presenter
       , s.company
       , s.co_presenter
       , s.co_presenter_company
       , s.tags
       , s.presenter_email
       , s.session_abstract
       , s.session_summary
       , s.target_audience
       , decode(trim(lower(s.presented_before_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presented_before_where
       , decode(trim(lower(s.presented_anything_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presented_anything_where
       , s.technology_product        
       , s.ace_level
       , s.video_link        
       , decode(trim(lower(s.contains_demo_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , decode(trim(lower(s.webinar_willing_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presenter_biography
       , co_presenter_user_id
       , presenter_user_id
       , coalesce(submission_date, sysdate)
    from ks_full_session_load s
         left outer join ks_event_tracks e on s.event_track_id = e.name and e.event_id = p_event_id
   where s.app_user = p_username
   order by s.session_num;
      
  x_load_count := SQL%ROWCOUNT;

  ks_log.log('END', l_scope);

  exception
    when OTHERS then
      ks_log.log_error('Unhandled Exception', l_scope);
      raise;
end load_sessions;






/**
 * Process to purge votes, sessions and tags from and event and/or track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 25, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_votes_only_ind to specify that only votes should be deleted.
 * @param p_force_ind to force the execution of the process even when votes
 *                    are present.
 */
procedure purge_event(
  p_event_id          in ks_sessions.event_id%TYPE
  , p_track_id        in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind  in varchar2
  , p_force_ind       in varchar2
)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'purge_event';

  no_action exception;

  l_votes_count number := 0;

begin
  ks_log.log('BEGIN', l_scope);

  -- This count is for pretection.
  -- We don't want to delete when there are votes present.
  select count(1)
    into l_votes_count
    from ks_session_votes v
       , ks_sessions s
   where v.session_id = s.id
     and s.event_id = p_event_id
     and (p_track_id is null or s.event_track_id = p_track_id)
     and p_votes_only_ind = 'N';


  if l_votes_count > 0 then
    -- if this parameter equals No 'N' then the process raises an error indicating no action will be done.
    raise no_action;
  end if;


  -- Delete the votes when the user selects "Votes Only" or "Force Purge"
  delete 
    from ks_session_votes v
   where v.session_id in (
      select ss.id
        from ks_sessions ss
       where ss.event_id = p_event_id
         and (p_track_id is null or ss.event_track_id = p_track_id)
   )
     and (p_votes_only_ind = 'Y' or p_force_ind = 'Y');


  -- Only delete sessions when the there are no votes and user selected Votes Only
  -- OR 
  -- Delete when user selected "Force Purge"
  delete
    from ks_sessions
   where event_id = p_event_id
     and (p_track_id is null or event_track_id = p_track_id)
     and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
         or p_force_ind = 'Y'
       );


  -- Remove unused tags after the "delete ks_sessions"
  --   When the there are no votes and user selected Votes Only
  --   OR 
  --   Delete when user selected "Force Purge"
  delete
    from ks_tag_type_sums ts
   where exists (
    select 1
     from ks_tag_type_sums s
        , ks_event_tracks t
    where s.content_type = 'SESSION' || ':' || t.id
      and s.tag_count = 0
      and s.rowid = ts.rowid
      and t.event_id = p_event_id
      and (p_track_id is null or t.id = p_track_id)
   )
    and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
        or p_force_ind = 'Y'
      );

  ks_log.log('END', l_scope);

  exception
    when no_action then
      raise_application_error (-20000,'Votes are present. Purge action aborted.');
    
end purge_event;




/**
 * Create collection session loaded having
 *    - The name of the track 
 *    - The number of loaded sessions by track
 *    - The checked flag (set Y by default)
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/07/2019
 * @param 
 */
procedure create_loaded_session_coll (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'create_loaded_session_coll';
  l_sql varchar2 (32000);
  l_param_names apex_application_global.vc_arr2;
  l_param_values apex_application_global.vc_arr2;
begin
  ks_log.log('START', l_scope);
  
  l_sql := q'[select e.id track_id
          ,count(*) session_count
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,s.event_track_id track_name
          ,'Y' notify_ind
  from    ks_full_session_load s
  left    outer join ks_event_tracks e 
  on      s.event_track_id = e.name 
  and     e.event_id = :p_event_id
  where   s.app_user = :p_username
  group   by s.event_track_id
         ,e.id]';

  if apex_collection.collection_exists (p_collection_name => c_loaded_session_coll) then 
    apex_collection.delete_collection (p_collection_name  => c_loaded_session_coll);
  end if;

  l_param_names(l_param_names.count + 1) := 'p_event_id';
  l_param_values(l_param_values.count + 1) := p_event_id;
  
  l_param_names(l_param_names.count + 1) := 'p_username';
  l_param_values(l_param_values.count + 1) := p_username;

  apex_collection.create_collection_from_queryb2 (
    p_collection_name => c_loaded_session_coll
   ,p_query           => l_sql
   ,p_names           => l_param_names
   ,p_values          => l_param_values
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end create_loaded_session_coll;



/**
 * Toggle the notification status of a loaded track
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_seq_id position in the collection
 * @param p_notification_ind Y|N
 */
procedure toggle_track_notification(p_seq_id in number)
is
  l_scope ks_log.scope := gc_scope_prefix || 'toggle_track_notification';

  l_notification_ind varchar2(1);

begin
  ks_log.log('START', l_scope);
  ks_log.log('p_seq_id:' || p_seq_id, l_scope);
  
  -- Get the new value
  select decode(notify_ind, 'Y', 'N', 'Y')
    into l_notification_ind
    from ks_session_load_coll_v
   where seq_id = p_seq_id;

  ks_log.log('l_notification_ind:' || l_notification_ind, l_scope);

  apex_collection.update_member_attribute  (
      p_collection_name => c_loaded_session_coll
    , p_seq => p_seq_id
    , p_attr_number => 2
    , p_attr_value  => l_notification_ind
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception:' || sqlerrm, l_scope);
    raise;
end toggle_track_notification;



end ks_session_load_api;
/


-- @../plsql/ks_util.pls
create or replace package ks_util
as

type gc_clob_arr_type is table of clob;

--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2;

--------------------------------------------------------------------------------
procedure set_param(
    p_name_key  in ks_parameters.name_key%TYPE
  , p_value     in ks_parameters.value%TYPE
);


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2;


--------------------------------------------------------------------------------
function format_full_name
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2;


--------------------------------------------------------------------------------
function is_number
(
  p_value        in         varchar2
) return boolean;

--------------------------------------------------------------------------------
function string_to_coll (p_string in varchar2) return sys.ODCIVarchar2List;

--------------------------------------------------------------------------------
function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         )
  return varchar2;

--------------------------------------------------------------------------------
function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report;


---------------------------------------------------------------------------------
function blob2clob(
  p_blob in blob,
  p_blob_csid in integer default dbms_lob.default_csid)
  return clob;

function replace_tokens (p_string in varchar2,
                         p_tokens in varchar2,
                         p_token_exceptions in varchar2)
 return varchar2;

function clob_to_varchar2_table (p_clob in out nocopy clob)
  return gc_clob_arr_type;

function ir_has_filters(
    p_ir_t      in apex_ir.t_report) 
  return boolean;
end ks_util;
/
-- @../plsql/ks_util.plb
create or replace package body ks_util
as

--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';


--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2
is
  l_value ks_parameters.value%TYPE;
begin

  select value
    into l_value
    from ks_parameters
   where name_key = p_name_key;

  return l_value;

exception
  when NO_DATA_FOUND then
    return null;

end get_param;



--------------------------------------------------------------------------------
procedure set_param(
    p_name_key      in ks_parameters.name_key%TYPE
  , p_value         in ks_parameters.value%TYPE
)
is
begin

  update ks_parameters
     set value = p_value
   where name_key = p_name_key;

  if sql%rowcount = 0 then
    raise_application_error(
        -20001
      , 'Parameter ' || p_name_key || ' does not exist.'
    );
  end if;

end set_param;


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2
is
  -- l_scope   logger_logs.scope%type := gc_scope_prefix || 'get_email';
  -- l_params  logger.tab_param;

  l_email ks_users.email%TYPE;
begin
  -- logger.append_param(l_params, 'p_username', p_username);
  -- logger.log('START', l_scope, null, l_params);

  select email
    into l_email
    from ks_users
   where username = p_username;

  return l_email;

exception
  when NO_DATA_FOUND then
    -- logger.log_error('Probably an invalid user.');
    return null;

end get_email;




function format_full_name
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2
IS
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'format_full_name';
  -- l_params logger.tab_param;
begin
--  logger.append_param(l_params, 'p_text', p_text);

  RETURN rtrim(p_first_name || ' ' || p_last_name);

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end format_full_name;






function is_number
(
  p_value        in         varchar2
) return boolean
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'is_number';
  -- l_params            logger.tab_param;

  non_numeric      exception;
  pragma exception_init (non_numeric, -06502);

  l_number     number;
begin
   l_number := p_value;

   return true;

exception
  when non_numeric then
    return false;
end is_number;





function string_to_coll (p_string in VARCHAR2) return sys.ODCIVarchar2List
is
  l_table wwv_flow_global.vc_arr2;
  l_list  sys.ODCIVarchar2List := new sys.ODCIVarchar2List();
begin
  l_table := apex_util.string_to_table(p_string);
  l_list.extend(l_table.count());
  for i in 1..l_table.count()
  loop
    l_list(i) := l_table(i);
  end loop;
  return l_list;
end string_to_coll;




function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         )
  return varchar2
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_order_by';
  -- l_params            logger.tab_param;

  l_order_by          varchar2(32000);
  l_instr             number;
begin
  -- logger.log('START', l_scope, null, l_params);

  l_instr := instr (p_ir_query, 'order by', -1);

  if l_instr > 0
  then
     -- grab the final order by from the IR query and trim off any trailing ")"
     l_order_by := rtrim (substr (p_ir_query, l_instr), ')');

  else -- add default order by for use by analytics lead/gag functions
    l_order_by := 'order by ' || p_default_pk; -- Use a column that's always present
  end if;

  -- logger.log('order by:' || l_order_by, l_scope, null, l_params);
  return l_order_by;

exception
  when others then
    null;
end get_ir_order_by;





function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_report';
  -- l_params            logger.tab_param;

  l_region_id          number;
begin
  -- logger.append_param(l_params, 'p_page_id', p_page_id);
  -- logger.append_param(l_params, 'p_static_id', p_static_id);
  -- logger.log('START', l_scope, null, l_params);

  select region_id
    into l_region_id
    from apex_application_page_regions
   where static_id = p_static_id
     and page_id   = p_page_id
     and application_id = (select v('APP_ID') from dual);

  return apex_ir.get_report
         (
            p_page_id   => p_page_id
          , p_region_id => l_region_id
         );

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end get_ir_report;


/**
  * Converts blob to clob
  *
  * Notes:
  *  - Copied from OOS Utils https://github.com/OraOpenSource/oos-utils/blob/master/source/packages/oos_util_lob.pkb
  *
  */
 function blob2clob(
   p_blob in blob,
   p_blob_csid in integer default dbms_lob.default_csid)
   return clob
 as
   l_clob clob;
   l_dest_offset integer := 1;
   l_src_offset integer := 1;
   l_lang_context integer := dbms_lob.default_lang_ctx;
   l_warning integer;
 begin
   if p_blob is null then
     return null;
   end if;

   dbms_lob.createtemporary(
     lob_loc => l_clob,
     cache => false);

   dbms_lob.converttoclob(
     dest_lob => l_clob,
     src_blob => p_blob,
     amount => dbms_lob.lobmaxsize,
     dest_offset => l_dest_offset,
     src_offset => l_src_offset,
     blob_csid => p_blob_csid,
     lang_context => l_lang_context,
     warning => l_warning);

   return l_clob;
 end blob2clob;



--==============================================================================
-- Function: clob_to_varchar2_table
-- Purpose: takes a clob and returns it as a table of varchar2s with size 4000
--
-- Inputs:  p_clob - the clob to be passed in
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:  Some of this code taken from https://stackoverflow.com/questions/11647041/reading-clob-line-by-line-with-pl-sql
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function clob_to_varchar2_table (p_clob in out nocopy clob)
  return gc_clob_arr_type
is
  l_scope varchar2(255) := gc_scope_prefix || 'clob_to_varchar2_table';
  l_varchar2s gc_clob_arr_type;
  l_varchar2 varchar2(4000);
  l_offset number := 1;
  l_amount number := 3000;
  len    number;
  i number := 1;
begin

  ks_log.log('START', l_scope);

  l_varchar2s := gc_clob_arr_type();

  if p_clob is null
  then
    return l_varchar2s;
  end if;

  if ( dbms_lob.isopen(p_clob) != 1 ) then
    dbms_lob.open(p_clob,0);
  end if;

  len := dbms_lob.getlength(p_clob);

  while(l_offset < len)
  loop
    -- ks_log.log('inside main loop "while(l_offset < len)"', l_scope);
    dbms_lob.read(p_clob, l_amount, l_offset, l_varchar2);
    l_offset := l_offset + l_amount;
    l_varchar2s.extend;
    -- ks_log.log('len: ' || len || ', l_offset: ' || l_offset || ', l_varchar2: ' || l_varchar2, 'l_scope');
    l_varchar2s(i) := l_varchar2;
    i := i + 1;
  end loop;

  if ( dbms_lob.isopen(p_clob) = 1 ) then
    dbms_lob.close(p_clob);
  end if;


  return l_varchar2s;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  clob_to_varchar2_table;


--==============================================================================
-- Function: tokenize_string
-- Purpose: helper function for html_whitelist_tokenize
--
-- Inputs:  p_string - the to have its tokens replaced
--          p_tokens - a string containing the tokens
-- Output:
-- Scope: Publicly accessible
-- Errors: logged and raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/27/2017
--==============================================================================
function replace_tokens (p_string in varchar2,
                         p_tokens in varchar2,
                         p_token_exceptions in varchar2)
 return varchar2
is
  l_scope varchar2(255) := gc_scope_prefix || 'tokenize_string';

  l_output         varchar2(32767);
  l_tokens_table   apex_application_global.vc_arr2;
  l_tokens         varchar2(4000);
  found_match      boolean := true;
  l_index          number := -1;
  l_regex          varchar2(4000);
  l_infinite_check number := 0;
begin
  -- ks_log.log('BEGIN', l_scope);
  -- ks_log.log(p_tokens, l_scope);

  if trim(p_tokens) is null
  then
    return p_string;
  end if;


  --Cleanse p_tokens so that it only contains alphanumeric characters.
  --Get rid of all non-alphanumerics
  l_tokens := regexp_replace(p_tokens, '[^A-Za-z0-9]', ' ');
  --Remove from tokens the token exceptions
  l_tokens := regexp_replace(l_tokens, p_token_exceptions, '', 1, 0, 'i');
  --Get rid of all multiple spaces so that everything is only one space apart
  l_tokens := regexp_replace(l_tokens, '\s{2,}', ' ');

  l_tokens := trim(l_tokens);
  --Replace spaces with |
  l_tokens := regexp_replace(l_tokens, '\s', '|');

  -- ks_log.log(l_tokens, l_scope);

  --I wanted to use something like the oneliner below, but pl/sql doesn't support lookaheads (yet)
  --l_output := regexp_replace(p_string, '(\W)('|| l_tokens || ')(?=\W)', '\1XXXX', 1, 0, 'i');


  l_regex := '(^|\W)(' || l_tokens || ')(\W|$)';
  --ks_log.log('l_regex:' || l_regex, l_scope);


  l_output := p_string;
  --ks_log.log(l_output, l_scope);

  while(l_index != 0)
  loop

    l_index  := regexp_instr(l_output, l_regex, 1, 1, 0, 'i');

    if(l_index != 0)
    then
      --ks_log.log('Found match at index ' || l_index, l_scope);
      l_output := regexp_replace(l_output, l_regex, '\1💩\3', l_index, 1, 'i');

    end if;

    l_infinite_check := l_infinite_check + 1;
    if l_infinite_check > 9999
    then
      --Something's gone wrong
      raise_application_error(-20001, 'Error Tokenizing Data');
    end if;

  end loop;

  ks_log.log('> ' || l_output, l_scope);

  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end replace_tokens;
/**
 * Given IR type, determine if there are any filters applied
 * Filters are identified by the precense of the :APXWS_EXPR_n and
 * :APXWS_SEARCH_STRING_n binds
 *
 * @author Jorge Rimblas
 * @created October 11, 2019
 * @param p_ir_t An IR type apex_ir.t_report
 * @return boolean
 */
function ir_has_filters(
    p_ir_t      in apex_ir.t_report
)
  return boolean
is
  l_scope             logger_logs.scope%type := gc_scope_prefix || 'ir_has_filters';
  l_params            logger.tab_param;
  l_bind     apex_plugin_util.t_bind;
  l_index    pls_integer;
  l_found    boolean;
begin
--  logger.log('START', l_scope, null, l_params);

  l_index := p_ir_t.binds.first;
  l_found := false;
  while (l_index is not null and not l_found)
  loop
--    logger.log('p_ir_t.binds(l_index):' || p_ir_t.binds(l_index).name || ':' || p_ir_t.binds(l_index).value, l_scope, null, l_params);
    -- Search for binds named APXWS_EXPR_n
    if  p_ir_t.binds(l_index).name like 'APXWS_EXPR%'
     or p_ir_t.binds(l_index).name like 'APXWS_SEARCH_STRING%' then
      l_found := true;
    end if;
    l_index := p_ir_t.binds.next(l_index);
  end loop;
  return l_found;
exception
    when OTHERS then
--      logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end ir_has_filters;
end ks_util;
/


-- @../plsql/ks_tags_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
PROMPT ks_tags_api body
create or replace package body ks_tags_api
is
        
--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

---
--- Tag Synchronisation Procedure
---
procedure tag_sync (
    p_new_tags          in varchar2,
    p_old_tags          in varchar2,
    p_content_type      in varchar2,
    p_content_id        in number )
as
    l_scope  ks_log.scope := gc_scope_prefix || 'tag_sync';
  -- l_params logger.tab_param;

    type tags is table of varchar2(255) index by varchar2(255);
    l_new_tags_a    tags;
    l_old_tags_a    tags;
    l_new_tags      apex_application_global.vc_arr2;
    l_old_tags      apex_application_global.vc_arr2;
    l_merge_tags    apex_application_global.vc_arr2;
    l_dummy_tag     varchar2(255);
    i               integer;

begin
  -- we call tag_sync form a trigger, so lets not call logger unless we need to.
  -- logger.append_param(l_params, 'p_option_name', p_option_name);
    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('START', l_scope);
    ks_log.log('p_content_type: ' || p_content_type, l_scope);
    ks_log.log('  p_content_id: ' || p_content_id, l_scope);
    ks_log.log('p_new_tags: ' || p_new_tags, l_scope);
    ks_log.log('p_old_tags: ' || p_old_tags, l_scope);
    $END

    l_old_tags := apex_util.string_to_table(p_old_tags,':');
    l_new_tags := apex_util.string_to_table(p_new_tags,':');
    if l_old_tags.count > 0 then --do inserts and deletes
        --build the associative arrays
        for i in 1..l_old_tags.count loop
            l_old_tags_a(l_old_tags(i)) := l_old_tags(i);
        end loop;
        for i in 1..l_new_tags.count loop
            l_new_tags_a(l_new_tags(i)) := l_new_tags(i);
        end loop;
        --do the inserts
        for i in 1..l_new_tags.count loop
            begin
                l_dummy_tag := l_old_tags_a(l_new_tags(i));
            exception when no_data_found then
                insert into ks_tags (tag, content_id, content_type )
                    values (l_new_tags(i), p_content_id, p_content_type );
                l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
            end;
        end loop;
        --do the deletes
        for i in 1..l_old_tags.count loop
            begin
                l_dummy_tag := l_new_tags_a(l_old_tags(i));
            exception when no_data_found then
                delete from ks_tags where content_id = p_content_id and tag = l_old_tags(i);
                l_merge_tags(l_merge_tags.count + 1) := l_old_tags(i);
            end;
        end loop;
    else --just do inserts
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('insert: ' || l_new_tags.count, l_scope);
        $END
        for i in 1..l_new_tags.count loop
            insert into ks_tags (tag, content_id, content_type )
                values (l_new_tags(i), p_content_id, p_content_type );
            l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
        end loop;
    end if;

    for i in 1..l_merge_tags.count 
    loop
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('merging(' || i || '): ' || l_merge_tags(i), l_scope);
        ks_log.log('merging ks_tag_type_sums', l_scope);
        $END
        merge into ks_tag_type_sums s
        using (select count(*) tag_count
                 from ks_tags
                where tag = l_merge_tags(i) 
                  and content_type = p_content_type ) t
           on (s.tag = l_merge_tags(i) and s.content_type = p_content_type )
         when not matched then
           insert (tag, content_type, tag_count)
           values (l_merge_tags(i), p_content_type, t.tag_count)
         when matched then
           update set s.tag_count = t.tag_count;


        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('merging ks_tag_sums', l_scope);
        $END
        merge into ks_tag_sums s
        using (select sum(tag_count) tag_count
                 from ks_tag_type_sums
                where tag = l_merge_tags(i) ) t
           on (s.tag = l_merge_tags(i) )
         when not matched then
           insert (tag, tag_count)
           values (l_merge_tags(i), t.tag_count)
         when matched then
           update set s.tag_count = t.tag_count;
    end loop;

    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('END', l_scope);
    $END

end tag_sync;

/*******************************************************************
 * Maintain the collection elements when using search filters
 *   p_coll: collection_name
 *    p_sub: Optional sub level/area for the tags.
 *     p_id: ID being managed
 * p_status: YES/NO is the element checked (YES) or un-checked (NO)
 *******************************************************************/
procedure maintain_filter_coll(
       p_coll   in varchar2
     , p_sub    in varchar2 := null
     , p_id     in varchar2
     , p_status in varchar2 := 'NO')
is
  l_scope  ks_log.scope := gc_scope_prefix || 'maintain_filter_coll';

  l_seq_id number;
begin

  ks_log.log('START', l_scope);

  /*
  The collections being used:
    SESSIONTAGFILTER: For Session (abstract) filters
  */

  if p_coll in ('SESSIONTAGFILTER') then
    -- is this the top level selection
    if p_id = 'top' then

      -- Because it's the top level, empty the collection
      if apex_collection.collection_exists(p_coll) then
        apex_collection.truncate_collection(p_coll);
      else
        apex_collection.create_collection(p_coll);
      end if;

      -- the collection is already empty, but if the status
      -- is YES then we need to populate ALL of the elmemnts
      if p_status = 'YES' then
        for i in (
          select tag id from ks_tag_type_sums where content_type='SESSION' || nvl2(p_sub, ':' || p_sub, '') and p_coll = 'SESSIONTAGFILTER'
          )
        loop
          apex_collection.add_member(p_coll, p_c001 => i.id);
        end loop;
      end if;

    else
      -- We're dealing with a single element

      -- Create the collection if it doesn't exist.
      if not apex_collection.collection_exists(p_coll) then
          apex_collection.create_collection(p_coll);
      end if;

      -- The element was checked so add it
      if p_status = 'YES' then
          apex_collection.add_member(p_coll, p_c001 => p_id);
      else

        -- the element was unchecked so remove it.
        begin
        select seq_id
          into l_seq_id
          from apex_collections
         where collection_name = p_coll
           and c001 = p_id;

          apex_collection.delete_member(p_coll, l_seq_id);
        exception
        when NO_DATA_FOUND then
          null;
        end;
      end if;

    end if;
  end if;

  ks_log.log('END', l_scope);

end maintain_filter_coll;


end ks_tags_api;
/



-- @../views/ks_events_comps_v.sql
PRO ks_events_comps_v
create or replace force view ks_events_comps_v
as
select  s.event_id
      , s.event_track_id
      , s.presenter_user_id
      , ks_session_api.get_presenter_comp(s.event_id, s.event_track_id , s.presenter_user_id) as presenter_comp
   from ks_sessions s
  where s.status_code = 'ACCEPTED'
group by s.event_id, s.event_track_id, s.presenter_user_id
/

PRO _________________________________________________
PRO . DML

PRO .. Make presenter_user_id mandatory
-- @../conversion/populate_presenter_user_id.sql


PRO ... create table tmp_presenters
create table tmp_presenters
as
select presenter, max(presenter_user_id) presenter_user_id
from ks_sessions
where presenter in (
    select presenter
    from ks_sessions
    where presenter_user_id is not null
)
  and presenter_user_id is not null
group by presenter
/

create or replace function get_presenter_user_id(p_presenter in ks_sessions.presenter%TYPE)
  return ks_sessions.presenter_user_id%TYPE
is
  l_presenter_user_id ks_sessions.presenter_user_id%TYPE;
  l_presenter_hash varchar2(128);
begin
  select presenter_user_id
    into l_presenter_user_id
    from tmp_presenters
   where presenter = p_presenter;

  -- ks_log.log('Got l_presenter_user_id:' || l_presenter_user_id, 'get_presenter_user_id');
  return l_presenter_user_id;

 exception
 when NO_DATA_FOUND then
   -- generate an ID:
   --   * create and MD5 of the presenter name
   --   * Convert it to a number (because we get a RAW back)
   --   * Convert the number back to a String and grab the first 20 only (the size limit of presenter_user_id)
   return substr(
      to_char(
          to_number(
            dbms_obfuscation_toolkit.md5(input => utl_raw.cast_to_raw(p_presenter))
            , 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')
      ),1,20);
end get_presenter_user_id;
/



declare
  cursor presenters_cur
  is
    select * from ks_sessions 
    where presenter_user_id is null
      for update of presenter_user_id;

  l_session_rec presenters_cur%rowtype;

begin

  open presenters_cur;
  loop
    fetch presenters_cur into l_session_rec;
    exit when presenters_cur%NOTFOUND;

    update ks_sessions
       set presenter_user_id = get_presenter_user_id(presenter)
     where current of presenters_cur;

  end loop;
  close presenters_cur;

end;
/


PRO ... Cleanup: Drop tmp_presenters, get_presenter_user_id
drop table tmp_presenters;

drop function get_presenter_user_id;



alter table ks_sessions modify presenter_user_id not null;



-- #2
insert into constraint_lookup (constraint_name,message) values ('KS_EVENT_COMMUNITY_TRACKS_U01','That track is already part of the community.');
insert into constraint_lookup (constraint_name,message) values ('KS_COMMUNITY_TRACKS_FK','The community cannot be removed when it has tracks.');
insert into constraint_lookup (constraint_name,message) values ('KS_EVENT_COMMUNITY_TRACKS_FK', 'The track cannot be removed if it is associated with a community.');
-- #35
insert into ks_parameters (category, name_key, value, description) values ('Notifications','SESSION_MOVED_BETWEEN_TRACKS_TEMPLATE','SESSION_MOVED_BETWEEN_TRACKS','Name of email template for when a session is moved between tracks');

delete from ks_email_templates where name = 'SESSION_MOVED_BETWEEN_TRACKS';
insert into ks_email_templates (name, template_text)
 values ('SESSION_MOVED_BETWEEN_TRACKS'
  , q'{The session <i>"#SESSION_TITLE#"</i> from #SPEAKER# has been moved from <i>#FROM_TRACK#</i> to <b>#TO_TRACK#</b>

Sub Category : <i>#SUB_CATEGORY#</i>
Session Type : <i>#SESSION_TYPE#</i>

All existing votes from <i>#FROM_TRACK#</i> track have been removed.
Tags most likely should be revised.
}');

-- ## 44
-- @../conversion/seed_ks_load_mapping.sql
PRO Removing previous mapping
delete from KS_LOAD_MAPPING;
REM INSERTING into KS_LOAD_MAPPING
SET DEFINE OFF;
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',10,'SESSION_NUM','Session Number');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',20,'TITLE','Session Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',30,null,'Session Title Link');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',40,'EVENT_TRACK_ID','Track');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',50,'SUB_CATEGORY','Sub-Categorization');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',60,'SESSION_TYPE','Session Type');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',70,null,'Role:Submitter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',80,null,'Session Status');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',90,null,'All roles');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',100,null,'All roles (with line break)');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',110,'ACE_LEVEL','Are you part of the ACE program?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',120,null,'Cross-Listed Tracks');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',130,'PRESENTED_ANYTHING_IND','Have you ever presented before a live audience?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',140,'PRESENTED_BEFORE_IND','Have you presented this session before?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',150,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',160,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',170,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',180,'PRESENTED_BEFORE_WHERE','If yes, at what events?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',190,'PRESENTED_ANYTHING_WHERE','If yes, at what events?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',200,'SUBMISSION_DATE','Initial Submission');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',210,null,'Last Update');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',220,'VIDEO_LINK','Link to your optional abstract submission video');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',230,null,'Review Comments');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',240,null,'Role:Co-Presenter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',250,'CO_PRESENTER_COMPANY','Role:Co-Presenter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',260,null,'Role:Co-Presenter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',270,'CO_PRESENTER','Role:Co-Presenter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',280,null,'Role:Co-Presenter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',290,null,'Role:Co-Presenter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',300,'CO_PRESENTER_USER_ID','Role:Co-Presenter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',310,'PRESENTER_BIOGRAPHY','Role:Primary Presenter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',320,'COMPANY','Role:Primary Presenter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',330,'PRESENTER_EMAIL','Role:Primary Presenter Email');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',340,null,'Role:Primary Presenter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',350,'PRESENTER','Role:Primary Presenter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',360,null,'Role:Primary Presenter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',370,null,'Role:Primary Presenter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',380,'PRESENTER_USER_ID','Role:Primary Presenter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',390,null,'Role:Submitter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',400,null,'Role:Submitter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',410,null,'Role:Submitter Email');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',420,null,'Role:Submitter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',430,null,'Role:Submitter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',440,null,'Role:Submitter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',450,null,'Role:Submitter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',460,'SESSION_ABSTRACT','Session Description');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',470,'EXTERNAL_SYS_REF','Session Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',480,'SESSION_SUMMARY','Short Description');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',490,null,'Status Change');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',500,'TAGS','Tags');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',510,'TECHNOLOGY_PRODUCT','Technologies or Products Used');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',520,'SESSION_LENGTH','The length of my presentation can be');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',530,null,'Vote Average');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',540,null,'Vote Count');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',550,'CONTAINS_DEMO_IND','Will this presentation include a demo?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',560,'WEBINAR_WILLING_IND','Would you be willing to present this as a webinar?');


-- DO NOT TOUCH/UPDATE BELOW THIS LINE


PRO Recompiling objects
exec dbms_utility.compile_schema(schema => user, compile_all => false);
