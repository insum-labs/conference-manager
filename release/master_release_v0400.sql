-- =============================================================================
-- ==========================  Full _release.sql file
-- =============================================================================
PRO Installing 4.0.0 (Kscope20)

--  sqlblanklines - Allows for SQL statements to have blank lines
set sqlblanklines on
--  define - Sets the character used to prefix substitution variables
set define '^'


PRO _________________________________________________
PRO . TABLES and DDL

PRO .. ks_session_votes_mv
-- @../views/ks_session_votes_mv.sql
PRO ks_session_votes_mv
create materialized view log on ks_session_votes
  with primary key
  including new values
/
create materialized view ks_session_votes_mv
  build immediate
  enable query rewrite
as
select d.vote_type
     , d.session_id
     , sum(d.vote) votes_total
     , avg(d.vote) votes_average
     , count(*) votes_count
 from ks_session_votes d
group by d.vote_type
       , d.session_id
/
create unique index ks_session_votes_mv_u01 on ks_session_votes_mv(session_id, vote_type);


-- #2
-- @../install/ks_event_communities.sql
PRO .. ks_event_communities 

-- drop table ks_event_communities cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_communities (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , event_id        number        not null
  , name            varchar2(60)  not null
  , created_by      varchar2(60) default
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_event_communities_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
)
enable primary key using index
/

comment on table ks_event_communities is 'List of Communities';

comment on column ks_event_communities.id is 'Primary Key ID';
comment on column ks_event_communities.created_by is 'User that created this record';
comment on column ks_event_communities.created_on is 'Date the record was first created';
comment on column ks_event_communities.updated_by is 'User that last modified this record';
comment on column ks_event_communities.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_communities_u_trg
before update
on ks_event_communities
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/
-- @../install/ks_event_community_tracks.sql
PRO .. ks_event_community_tracks 

-- drop table ks_event_community_tracks cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_community_tracks (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , community_id    number        not null
  , track_id        number        not null
  , created_by      varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_community_tracks_fk foreign key ( community_id ) references ks_event_communities ( id ) not deferrable
  , constraint ks_event_community_tracks_fk foreign key ( track_id ) references ks_event_tracks ( id ) not deferrable
)
enable primary key using index
/

create unique index ks_event_community_tracks_u01 on ks_event_community_tracks(community_id, track_id);

comment on table ks_event_community_tracks is 'List of tracks in a community';

comment on column ks_event_community_tracks.id is 'Primary Key ID';
comment on column ks_event_community_tracks.created_by is 'User that created this record';
comment on column ks_event_community_tracks.created_on is 'Date the record was first created';
comment on column ks_event_community_tracks.updated_by is 'User that last modified this record';
comment on column ks_event_community_tracks.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_community_track_u_trg
before update
on ks_event_community_tracks
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/

-- #42
alter table ks_sessions add ranking number;
comment on column ks_sessions.ranking is 'Used to specify the rank for a group of sessions.';


-- #36
create index ks_users_i01
  on ks_users(external_sys_ref)
/

-- @../install/ks_event_comp_users.sql
PRO .. ks_event_comp_users 

-- drop table ks_event_comp_users cascade constraints purge;

-- Keep table names under 24 characters
--           1234567890123456789012345
create table ks_event_comp_users (
    id              number        generated by default on null as identity (start with 1) primary key not null
  , event_id        number        not null
  , user_id         number        not null
  , reason          varchar2(250)
  , created_by      varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on      date         default sysdate not null
  , updated_by      varchar2(60)
  , updated_on      date
  , constraint ks_event_comp_user_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
  , constraint ks_event_comp_users_fk foreign key ( user_id ) references ks_users ( id ) not deferrable
)
enable primary key using index
/

comment on table ks_event_comp_users is 'Users with attendance comps for the event';

comment on column ks_event_comp_users.id is 'Primary Key ID';
comment on column ks_event_comp_users.event_id is 'Event for which the user is comped';
comment on column ks_event_comp_users.user_id is 'User begin comped';
comment on column ks_event_comp_users.reason is 'Reason or information for comped';
comment on column ks_event_comp_users.created_by is 'User that created this record';
comment on column ks_event_comp_users.created_on is 'Date the record was first created';
comment on column ks_event_comp_users.updated_by is 'User that last modified this record';
comment on column ks_event_comp_users.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--                        123456789012345678901234567890
create or replace trigger ks_event_comp_users_u_trg
before update
on ks_event_comp_users
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/


--
PRO .. Allow multi-byte chars for tags
-- alter table ks_tags modify tag varchar2(255);
-- alter table ks_tag_sums modify tag varchar2(255);
-- alter table ks_tag_type_sums modify tag varchar2(255);


-- #44
PRO .. Session Length
alter table ks_full_session_load add session_length varchar2(500);
alter table ks_sessions add session_length varchar2(500);



PRO _________________________________________________
PRO . VIEW

-- @../views/ks_sessions_v.sql

PRO ks_sessions_v
create or replace view ks_sessions_v
as
with totals as (
  select d.session_id
       , sum(d.vote) votes_total
       , avg(d.vote) votes_average
   from ks_session_votes d
  group by d.session_id
)
select  s.id
      , s.event_id
      , s.event_track_id
      , s.session_num
      , s.sub_category
      , s.session_type
      , s.title
      , s.presenter
      , s.company
      , s.co_presenter
      , s.status_code
      , s.notes
      , s.tags
      , s.session_length
      , t.votes_total
      , t.votes_average
      , s.presenter_email
      , s.session_summary
      , s.session_abstract
      , s.target_audience
      , s.presented_before_ind
      , s.presented_before_where
      , s.technology_product
      , s.ace_level
      , s.video_link
      , trim (
        case
        when instr (s.video_link, 'http') > 0 
        then
          substr (
             s.video_link
            ,instr (s.video_link, 'http')
            ,case 
              when instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1) < instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1)
                then instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1)
              when instr (s.video_link, ' ', instr (s.video_link, 'http', 1) + 1) > instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1)
                then instr (s.video_link, '<', instr (s.video_link, 'http', 1) + 1) - 1
                else length (s.video_link)
            end
          )
        else null
        end
      ) as first_video_link
      , s.contains_demo_ind
      , s.webinar_willing_ind
      , s.external_sys_ref
      , s.presenter_user_id
      , s.co_presenter_user_id
      , s.presenter_biography
      , s.co_presenter_company
      , s.submission_date
      , s.room_size_code
      , s.presented_anything_ind
      , s.presented_anything_where
      , s.ranking
      , s.created_by
      , s.created_on
      , s.updated_by
      , s.updated_on
  from ks_sessions s
     , totals t
 where s.id = t.session_id (+)
/
-- @../views/ks_users_v.sql
PRO ks_users_v
create or replace view ks_users_v
as
select u.id
     , u.username
     , u.password
     , u.first_name
     , u.last_name
     , u.first_name || nvl2(u.last_name, ' ' || u.last_name, '') full_name
     , u.first_name || nvl2(u.last_name, ' ' || u.last_name, '')  || nvl2(u.first_name || u.last_name, ' (','') || u.username || nvl2(u.first_name || u.last_name, ')','') full_name_extended
     , u.email
     , u.active_ind
     , u.admin_ind
     , u.external_sys_ref
     , u.expired_passwd_flag
     , u.login_attempts
     , u.last_login_date
     , u.created_by
     , u.created_on
     , u.updated_by
     , u.updated_on
  from ks_users u
/

-- #2
-- @../views/ks_events_communities_v.sql
PRO ks_events_communities_v
create or replace force view ks_events_communities_v
as
select e.id event_id
     , c.id event_community_id
     , c.name community_name
     , e.name event_name
     , e.begin_date begin_date
     , e.active_ind event_active_ind
     , (
         select listagg( t.name, ', ') within group (order by t.display_seq)
           from ks_event_community_tracks ct join ks_event_tracks t on (ct.track_id = t.id and t.event_id = e.id)
          where ct.community_id =  c.id
       ) track_list
from ks_events e
join ks_event_communities c on ( c.event_id = e.id)
/
-- @../views/ks_events_communities_tracks_v.sql
PRO ks_events_communities_tracks_v
create or replace force editionable view ks_events_communities_tracks_v
as
  select e.id event_id
       , c.id event_community_id
       , c.name community_name
       , e.name event_name
       , e.begin_date begin_date
       , e.active_ind event_active_ind
       , ct.id community_track_id
       , ct.track_id
       , et.display_seq track_display_seq
       , et.name track_name
       , et.alias track_alias
       , et.active_ind track_active_ind
       , et.max_sessions
       , et.max_comps
  from ks_events e
  join ks_event_communities c on ( c.event_id = e.id)
  join ks_event_community_tracks ct on (c.id = ct.community_id)
  join ks_event_tracks et on (ct.track_id = et.id)
/




PRO _________________________________________________
PRO . PACKAGES

-- #35
-- @../plsql/ks_notification_api.pls
create or replace package ks_notification_api
is

-- TYPES
type t_WordList is table of varchar2(32000) index by varchar(30);


-- CONSTANTS
g_blank_sub_strings t_WordList; -- Leave blank
------------------------------------------------------------------------------
procedure fetch_user_substitions (
  p_id in ks_users.id%type
 ,p_substrings in out nocopy t_WordList
);

procedure send_email (
   p_to in varchar2 default null
  ,p_from in varchar2
  ,p_cc in varchar2 default null
  ,p_bcc in varchar2 default null
  ,p_subject in varchar2
  ,p_body in clob
  ,p_body_html in clob default null
  ,p_template_name in varchar2 default null
  ,p_substrings in t_WordList default g_blank_sub_strings
);

procedure notify_track_session_load (
    p_notify_owner in varchar2
  , p_notify_voter in varchar2
);

procedure notify_reset_pwd_request (
    p_id in ks_users.id%type
   ,p_password in ks_users.password%type
   ,p_app_id in ks_parameters.value%type
);

procedure notify_reset_pwd_done (
    p_id in ks_users.id%type
);

procedure notify_session_move (
    p_id in ks_sessions.id%type
   ,p_event_track_id in ks_sessions.event_track_id%type
   ,p_old_event_track_id in ks_sessions.event_track_id%type
   ,p_notify_owners_ind in varchar2
   ,p_notify_voters_ind in varchar2
);

end ks_notification_api;
/
-- @../plsql/ks_notification_api.plb
set define off
create or replace package body ks_notification_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';
-- gc_template_load_notif constant ks_parameters.name_key%type := 'LOAD_NOTIFICATION_TEMPLATE';


------------------------------------------------------------------------------
/**
 * Get ready all the parameters to notify by email.
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param
 */
function replace_substr_template (
   p_template_name in varchar2
  ,p_substrings in t_WordList default g_blank_sub_strings
)
return clob
is
  l_scope ks_log.scope := gc_scope_prefix || 'replace_substr_template';

  l_msg clob;
  l_key varchar(30);
  l_substring varchar2(32000);
begin
  ks_log.log('BEGIN', l_scope);

  select  t.template_text
  into    l_msg
  from    ks_email_templates t
  where   t.name = p_template_name;

  l_key := p_substrings.first;

  while (l_key is not null)
  loop
    l_msg := replace (l_msg, '#' || upper (l_key) || '#', p_substrings(l_key) );
    l_key := p_substrings.next(l_key);
  end loop;

  ks_log.log('l_msg:' || l_msg, l_scope);
  ks_log.log('END', l_scope);
  return l_msg;
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end replace_substr_template;




/**
 * Populate all the substrings available for a given user so they can be used in
 * a template
 *
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 10, 2018
 * @param p_id `ks_users.id`
 * @param p_substrings `t_WordList`
 */
procedure fetch_user_substitions (
  p_id in ks_users.id%type
 ,p_substrings in out nocopy t_WordList
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'fetch_user_substitions';
begin
  ks_log.log('BEGIN', l_scope);

  select  u.id
         ,u.username
         ,u.first_name
         ,u.last_name
         ,u.full_name
         ,u.email
         ,u.active_ind
         ,u.admin_ind
         ,u.external_sys_ref
         ,u.expired_passwd_flag
         ,u.login_attempts
         ,u.last_login_date
  into    p_substrings ('USER_ID')
         ,p_substrings ('USERNAME')
         ,p_substrings ('USER_FIRST_NAME')
         ,p_substrings ('USER_LAST_NAME')
         ,p_substrings ('USER_FULL_NAME')
         ,p_substrings ('USER_EMAIL')
         ,p_substrings ('USER_ACTIVE_IND')
         ,p_substrings ('USER_ADMIN_IND')
         ,p_substrings ('USER_EXTERNAL_SYS_REF')
         ,p_substrings ('USER_EXPIRED_PASSWD_FLAG')
         ,p_substrings ('USER_LOGIN_ATTEMPTS')
         ,p_substrings ('USER_LAST_LOGIN_DATE')
  from    ks_users_v u
  where   u.id = p_id;

  ks_log.log('END', l_scope);

end fetch_user_substitions;

/**
 * Fetch session details/data
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @return ks_sessions%rowtype
 */
function fetch_session_details(p_id in ks_sessions.id%type)
return ks_sessions%rowtype
is

  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_session_details';
  l_session_info ks_sessions%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param p_id : ' ||p_id, l_scope);

  select * into l_session_info
    from ks_sessions
   where id = p_id;

  ks_log.log('END', l_scope);
  return l_session_info;

end fetch_session_details;

/**
 * Fetch track details/data
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @return ks_event_tracks%rowtype
 */
function fetch_track_details(p_id in ks_event_tracks.id%type)
return ks_event_tracks%rowtype
is

  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_track_details';
  l_track_details ks_event_tracks%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param p_id : ' ||p_id, l_scope);

  select * into l_track_details
    from ks_event_tracks
   where id = p_id;

  ks_log.log('END', l_scope);
  return l_track_details;

end fetch_track_details;
/**
 * Fetch common substitution strings that can be used on a template.
 *   * VOTING_APP_LINK
 *   * ADMIN_APP_LINK
 *
 *
 * @example
 *
 * @issue
 *
 * @author Jorge Rimblas
 * @created November 19, 2018
 * @param x_result_status
 * @return
 */
procedure fetch_common_links(p_substrings in out nocopy t_WordList)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'fetch_common_links';
begin
  ks_log.log('BEGIN', l_scope);

  p_substrings('VOTING_APP_LINK') := ks_util.get_param('SERVER_URL') || ks_util.get_param('VOTING_APP_ID');
  p_substrings('ADMIN_APP_LINK') := ks_util.get_param('SERVER_URL') || ks_util.get_param('ADMIN_APP_ID');

  ks_log.log('END', l_scope);
end fetch_common_links;





/**
 * Get ready all the parameters to notify by email.
 * If the procedure receives a template name (in `p_template_name`) then the `p_body`
 * and `p_body_html` parameters are ignored and only the template is used.
 * If present, the `p_substrings` "word list" values will be used to merge with the template.
 * Leave `p_template_name` empty to use the `p_body` and `p_body_html` parameters.
 * If all three destination `p_to`, `p_cc` and `p_bcc` are null, the procedure
 * exits without error.
 *
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 6, 2018
 * @param p_template_name optional template name as seen on `ks_email_templates`
 */
procedure send_email (
   p_to in varchar2 default null
  ,p_from in varchar2
  ,p_cc in varchar2 default null
  ,p_bcc in varchar2 default null
  ,p_subject in varchar2
  ,p_body in clob
  ,p_body_html in clob default null
  ,p_template_name in varchar2 default null
  ,p_substrings in t_WordList default g_blank_sub_strings
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'send_email';

  l_body clob;
  l_body_html clob;
begin
  ks_log.log('BEGIN', l_scope);

  if trim (p_to) is null
      and trim (p_cc) is null
      and trim (p_bcc) is null then
    return;
  end if;

  if p_template_name is not null then
    l_body := replace_substr_template (
      p_template_name => p_template_name
     ,p_substrings => p_substrings
    );

    l_body_html := replace (l_body, chr(10), '<br>');
  else
    l_body := p_body;
    l_body_html := p_body_html;
  end if;

  ks_email_api.send (
     p_to => p_to
    ,p_cc => p_cc
    ,p_bcc => p_bcc
    ,p_from => p_from
    ,p_replyto => null
    ,p_subj => p_subject
    ,p_body => l_body
    ,p_body_html => l_body_html
  );

  ks_log.log('END', l_scope);
exception
  when OTHERS then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end send_email;




/**
 *
 * Notify users of newly loaded sessions. The loaded sessions are found in `ks_session_load_coll_v`
 * Only the users for the tracks marked during the Load Session Wizard (`ks_session_load_coll_v.notify_ind`) will be notified.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_notify_owner Notify "Track Owners", ie Track Leads (OWNER) and Track Observers (VIEWER). Those where `selection_role_code is not null`
 * @param p_notify_voter Notify "Voters": those where `voting_role_code is not null`
 */
procedure notify_track_session_load (
    p_notify_owner in varchar2
  , p_notify_voter in varchar2
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_track_session_load';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('LOAD_NOTIFICATION_TEMPLATE');

  fetch_common_links(l_substrings);

  for rec in (
    with user_emails as (
      select  sl.track_name
             ,sl.session_count
             ,u.email
      from    ks_user_event_track_roles uetr
      join    ks_users u
      on      uetr.username = u.username
      join    ks_session_load_coll_v sl
      on      sl.track_id = uetr.event_track_id
      where   sl.notify_ind = 'Y'
      and     u.email is not null
      and     (
        ('OWNER' = p_notify_owner
          and uetr.selection_role_code is not null)
        or
        ('VOTER' = p_notify_voter
          and uetr.voting_role_code is not null)
      )
      group   by sl.track_name
             ,sl.session_count
             ,u.email
    )
    select    ue.track_name
             ,ue.session_count
             ,listagg (ue.email,',') within group (order by ue.email desc) as email
    from      user_emails ue
    group     by ue.track_name
             ,ue.session_count
  )
  loop
    ks_log.log (rec.track_name || '-' || rec.session_count || '-' || rec.email, l_scope);

    l_substrings('SESSION_COUNT') := rec.session_count;
    l_substrings('TRACK_NAME') := rec.track_name;

    l_subject := ' New sessions for: ' || rec.track_name;

    send_email (
       p_to => rec.email
      ,p_from => l_from
      ,p_cc => null
      ,p_bcc => null
      ,p_subject => l_subject
      ,p_body => null
      ,p_body_html => null
      ,p_template_name =>  l_template_name
      ,p_substrings => l_substrings
    );
  end loop;

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_track_session_load;



/**
 *
 * Send a user an email/notification with their new temporary password after a
 * "Reset Password" (by an Admin) or a "Forgot Password" action (by a user)
 *
 * The text of the email is defined by the template mentioned in the
 * `RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE` system parameter
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_username
 * @param p_password
 * @param p_app_id
 */
procedure notify_reset_pwd_request (
    p_id in ks_users.id%type
   ,p_password in ks_users.password%type
   ,p_app_id in ks_parameters.value%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_reset_pwd_request';

  c_subject_notification constant varchar2(30) := 'Reset Password Request';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('RESET_PASSWORD_REQUEST_NOTIFICATION_TEMPLATE');

  fetch_user_substitions (
    p_id => p_id
   ,p_substrings => l_substrings
  );
  fetch_common_links(l_substrings);

  l_substrings('TEMP_PASSWORD') := p_password;

  l_subject := c_subject_notification;

  send_email (
     p_to => l_substrings('USER_EMAIL')
    ,p_from => l_from
    ,p_cc => null
    ,p_bcc => null
    ,p_subject => l_subject
    ,p_body => null
    ,p_body_html => null
    ,p_template_name =>  l_template_name
    ,p_substrings => l_substrings
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_reset_pwd_request;



/**
 *
 * Notify a user after their password has been successfully changed (Reset Password)
 * The text of the email is defined by the template mentioned in the
 * `RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE` system parameter
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/13/2019
 * @param p_id ks_users.id
 */
procedure notify_reset_pwd_done (
    p_id in ks_users.id%type
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_reset_pwd_done';

  c_subject_notification constant varchar2(30) := 'Reset Password Done';

  l_substrings t_WordList;
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;
begin
  ks_log.log('START', l_scope);

  l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
  l_template_name := ks_util.get_param('RESET_PASSWORD_DONE_NOTIFICATION_TEMPLATE');
  l_subject := c_subject_notification;

  fetch_user_substitions (
    p_id => p_id
   ,p_substrings => l_substrings
  );
  fetch_common_links(l_substrings);

  send_email (
     p_to => l_substrings('USER_EMAIL')
    ,p_from => l_from
    ,p_cc => null
    ,p_bcc => null
    ,p_subject => l_subject
    ,p_body => null
    ,p_body_html => null
    ,p_template_name =>  l_template_name
    ,p_substrings => l_substrings
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end notify_reset_pwd_done;






/**
 * Notify track owners and/or voters when a session is moved between tracks.
 *
 * @example
 *
 * @issue #35
 *
 * @author Ramona Birsan
 * @created September 30, 2019
 * @param p_id
 * @param p_event_track_id
 * @param p_old_event_track_id
 * @param p_notify_owners_ind when 'Y', the notification will be send to track owners
 * @param p_notify_voters_ind when 'Y', the notification will be send to all voters
 */
procedure notify_session_move (
    p_id in ks_sessions.id%type
   ,p_event_track_id in ks_sessions.event_track_id%type
   ,p_old_event_track_id in ks_sessions.event_track_id%type
   ,p_notify_owners_ind in varchar2
   ,p_notify_voters_ind in varchar2
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'notify_session_move';
  c_subject_notification constant varchar2(30) := 'Session Moved Between Tracks';

  cursor email_list_c
  is
    with user_emails as (
    select distinct u.email
      from ks_user_event_track_roles uetr
      join ks_users u
        on uetr.username = u.username
     where u.email is not null
       and (
            ( p_notify_owners_ind = 'Y'
              and uetr.selection_role_code in ('OWNER'))
            or
            ( p_notify_voters_ind = 'Y'
               and uetr.voting_role_code is not null))
       and uetr.event_track_id in (p_event_track_id, p_old_event_track_id)
      )
    select listagg ( ue.email,',') within group (order by ue.email desc) as email_list
      from user_emails ue;


  l_to varchar2(4000);
  l_from ks_parameters.value%type;
  l_subject ks_parameters.value%type;
  l_template_name ks_parameters.value%type;

  l_substrings t_WordList;
  l_session ks_sessions%rowtype;
  l_event_track ks_event_tracks%rowtype;
begin
  ks_log.log('START', l_scope);
  ks_log.log('param session id : ' || p_id, l_scope);
  ks_log.log('param current event track id : ' || p_event_track_id, l_scope);
  ks_log.log('param old event track id : ' || p_old_event_track_id, l_scope);
  ks_log.log('param p_notify_owners_ind : ' || p_notify_owners_ind, l_scope);
  ks_log.log('param p_notify_voters_ind : ' || p_notify_voters_ind, l_scope);

  open email_list_c;
  fetch email_list_c into l_to;
  close email_list_c;
  ks_log.log('email list : ' || l_to, l_scope);

  if l_to is not null then
    l_session := fetch_session_details (p_id);
    l_substrings('SESSION_TITLE') := l_session.title;
    l_substrings('SUB_CATEGORY') := nvl(l_session.sub_category, '-');
    l_substrings('SESSION_TYPE') := nvl(l_session.session_type, '-');
    l_substrings('SPEAKER') := l_session.presenter;

    l_event_track := fetch_track_details (p_event_track_id);
    l_substrings('TO_TRACK') := l_event_track.name;

    l_event_track := fetch_track_details (p_old_event_track_id);
    l_substrings('FROM_TRACK') := l_event_track.name;

    l_from := ks_util.get_param('EMAIL_FROM_ADDRESS');
    l_subject := c_subject_notification;
    l_template_name := ks_util.get_param('SESSION_MOVED_BETWEEN_TRACKS_TEMPLATE');

    send_email (
      p_to => l_to
     ,p_from => l_from
     ,p_cc => null
     ,p_bcc => null
     ,p_subject => l_subject
     ,p_body => null
     ,p_body_html => null
     ,p_template_name =>  l_template_name
     ,p_substrings => l_substrings
   );
  end if;

  ks_log.log('END', l_scope);
  exception
    when others then
      ks_log.log('Unhandled Exception ', l_scope);
      raise;
end notify_session_move;

end ks_notification_api;
/

-- #36
-- @../plsql/ks_session_api.pls
create or replace package ks_session_api
is

--------------------------------------------------------------------------------
--*
--* 
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter_user_id in ks_sessions.presenter_user_id%TYPE);
  
procedure switch_votes (
	  p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username 	  in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
);


function html_whitelist_tokenize (
    p_string      in clob
  , p_session_id  in number
  , p_anonymize   in varchar2 default 'N'
  , p_escape_html in varchar2 default 'Y'
  , p_sql_trim    in varchar2 default 'N'
)
return varchar2;


procedure session_id_navigation (
   p_id in ks_sessions.id%type
  ,p_region_static_id in varchar2
  ,p_page_id in number
  ,p_previous_id out ks_sessions.event_track_id%type
  ,p_next_id out ks_sessions.event_track_id%type
  ,p_total_rows out number
  ,p_current_row out number
);


function is_session_owner (
  p_session_id in ks_sessions.id%type
 ,p_username   in varchar2
)
return varchar2;


function parse_video_link (
  p_video_link in ks_sessions.video_link%type
)
return varchar2;

function get_presenter_comp (
    p_event_id in ks_sessions.event_id%type 
  , p_event_track_id in ks_sessions.event_track_id%type  
  , p_presenter_user_id in ks_sessions.presenter_user_id%type 
) return number;

end ks_session_api;
/
-- @../plsql/ks_session_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
create or replace package body ks_session_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 * @constant gc_html_whitelist_tags a list of strings to NOT escape from. Same as the apex version but includes span and em
 * @constant gc_token_exceptions is a "|" separated list that gets passed into ks_util. It contains the tokens which we want to ommit from escaping.
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

gc_html_whitelist_tags constant varchar2(500) := '<h1>,</h1>,<h2>,</h2>,<h3>,</h3>,<h4>,</h4>,<p>,<span>,</span>,</p>,<b>,</b>,<strong>,</strong>,<i>,</i>,<ul>,</ul>,<ol>,</ol>,<li>,</li>,<br />,<hr/>,<em>,</em>';
gc_token_exceptions constant varchar2(4000) := 'oracle|apex|epm|and|its|it|of';
gc_parameter_tokens_name constant ks_parameters.name_key%type := 'ANONYMIZE_EXTRA_TOKENS';



/**
 * Private function, checks if the speaker/presenter is comped, i.e. is added to the list of comped users for the event
 *
 * @example
 *
 * @issue #36
 *
 * @author Ramona Birsan
 * @created October 8, 2019
 * @param p_presenter_user_id
 * @return 1 if speaker/presenter is comped
 */
function is_speaker_comped (
    p_event_id in ks_sessions.event_id%type
  , p_presenter_user_id in ks_sessions.presenter_user_id%type
) return number
is
  pragma UDF;
  l_scope  ks_log.scope := gc_scope_prefix || 'is_speaker_comped';
  -- l_params logger.tab_param; 
  l_is_comped number(1) := 0;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END
 
  select 1 into l_is_comped
    from ks_event_comp_users cu 
    join ks_users u on (u.id = cu.user_id)
   where cu.event_id = p_event_id
     and u.external_sys_ref = p_presenter_user_id;
     
  return l_is_comped;
  
  exception 
    when no_data_found then
      return 0;
    when others then
      ks_log.log('Unhandled Exception ', l_scope);
      raise;
end is_speaker_comped;






------------------------------------------------------------------------------
/**
 *  Output of the form:
 *    apex_json.open_object;
 *    apex_json.write('p_presenter_user_id', p_presenter_user_id);
 *    apex_json.write('trackList', '<ul><li>Track 1</li></ul>');
 *    apex_json.close_object;
 *
 * @example
 *
 * @issue #36 - use presenter_user_id to fetch the list of tracks
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param p_event_id
 * @param p_presenter_user_id
 * @return
 */
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter_user_id in ks_sessions.presenter_user_id%TYPE)
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'presenter_tracks_json';
  -- l_params logger.tab_param;

  list_cur sys_refcursor;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  -- logger.log('BEGIN', l_scope, null, l_params);

  open list_cur for
    select p_presenter_user_id "presenter_user_id"
          ,'<ul><li>' ||listagg(n || ' in ' || p || ' (' || status || ')', '</li><li>') within group (order by display_seq) || '</li></ul>' "trackList"
    from (
      select t.display_seq, nvl(t.alias, t.name) p, count(*) n
           , listagg(nvl(st.name, '?'), ',') within group (order by st.display_seq) status
        from ks_event_tracks t
           , ks_sessions s
           , ks_session_status st
       where t.id = s.event_track_id
         and s.event_id = to_number(p_event_id)
         and s.presenter_user_id = p_presenter_user_id
         and s.status_code = st.code (+)
       group by t.display_seq, nvl(t.alias, t.name)
    );

  apex_json.write(list_cur);

  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    apex_json.open_array;
    apex_json.open_object;
    apex_json.write('p_presenter_user_id', p_presenter_user_id);
    apex_json.write('trackList', 'Unable to fetch list:<br>' || sqlerrm || '<br>');
    apex_json.close_object;
    apex_json.close_array;
end presenter_tracks_json;






/**
 * Switch votes and voting role of an user for a selected event / track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 26, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_username username of the user.
 * @param p_voting_role selected voting role for the user.
 */
procedure switch_votes (
  p_event_id    in ks_sessions.event_id%TYPE
  , p_track_id    in ks_sessions.event_track_id%TYPE
  , p_username    in ks_session_votes.username%TYPE
  , p_voting_role in ks_user_event_track_roles.voting_role_code%TYPE
)
is

begin

  -- Move all votes to new vote_type
  update ks_session_votes
     set vote_type = p_voting_role
   where id in (
      select sv.id
        from ks_session_votes sv
           , ks_sessions s
       where sv.username = p_username
         and s.event_id = p_event_id
         and s.event_track_id = p_track_id
         and sv.session_id = s.id);

  update ks_user_event_track_roles
     set voting_role_code = p_voting_role
   where username = p_username
     and event_track_id = p_track_id;

end switch_votes;







--==============================================================================
-- Function: html_whitelist_tokenize
-- Purpose: returns a varchar2 where every chunk of 4000 characters has been html_whitelisted and tokenized
--
-- Inputs:  p_string - the clob or varchar2 to be escaped/tokenized
--          p_session_id - the session id. We use this to get the name of the presenter/company/co-presenter
--          p_anonymize - whether to hide the info
--          p_escape_html - 
--          p_sql_trim  - If Y return only 4000 chars so tat SQL doesn't fail
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function html_whitelist_tokenize (
    p_string      in clob
  , p_session_id  in number
  , p_anonymize   in varchar2 default 'N'
  , p_escape_html in varchar2 default 'Y'
  , p_sql_trim    in varchar2 default 'N'
)
  return varchar2
is
  l_scope ks_log.scope := gc_scope_prefix || 'html_whitelist_tokenize';

  l_output varchar2(32767);

  l_presenter    ks_sessions.presenter%type;
  l_co_presenter ks_sessions.co_presenter%type;
  l_company      ks_sessions.company%type;
begin
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  ks_log.log('p_session_id:' || p_session_id, l_scope);
  $END

  --The id is usually null when the user's session got reset
  --We don't want to create an ugly error on top of the page already showing errors
  --So silently exit.
  if p_session_id is null then
    return '';
  end if;

  if p_escape_html = 'Y' then
    l_output := apex_escape.html_whitelist(p_string, gc_html_whitelist_tags);
    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('..output escaped', l_scope);
    $END
  else
    l_output := p_string;
  end if;
  l_output := regexp_replace(l_output, '_x000D_', '', 1, 0, 'i');
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('..weird delimiters removed', l_scope);
  $END

  if p_anonymize = 'Y' and nvl(ks_util.get_param('ANONYMIZE_TOKENS'), 'YES') = 'YES' then
    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('..anonymizing', l_scope);
    $END
    select s.presenter, s.company, s.co_presenter
      into l_presenter, l_company, l_co_presenter
      from ks_sessions s
     where s.id = p_session_id;

     l_output := ks_util.replace_tokens(l_output 
                                      , l_presenter || ' ' || l_company || ' ' || l_co_presenter ||' ' || ks_util.get_param(gc_parameter_tokens_name)
                                      , gc_token_exceptions);


  end if;

  if p_sql_trim = 'Y' then
    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('..trimming for SQL', l_scope);
    ks_log.log('..l_output:' || length(l_output), l_scope);
    $END

    l_output := substr(l_output,1,3700);
    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('..New l_output:' || length(l_output), l_scope);
    $END

  end if;

  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  html_whitelist_tokenize;




/**
 * Get the following data to allow navigation of the sessions:
 *    - Previous Session ID
 *    - Next Session ID
 *    - Current Row
 *    - Total Row
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 1, 2018
 * @param p_id
 * @param p_region_static_id
 * @param p_page_id
 * @return
 * @param p_previous_id
 * @param p_next_id
 * @param p_total_rows
 * @param p_current_row
 */
procedure session_id_navigation (
   p_id in ks_sessions.id%type
  ,p_region_static_id in varchar2
  ,p_page_id in number
  ,p_previous_id out ks_sessions.event_track_id%type
  ,p_next_id out ks_sessions.event_track_id%type
  ,p_total_rows out number
  ,p_current_row out number
)
is
  l_report apex_ir.t_report;
  l_sql clob;
  l_next_id number;
  l_previous_id number;
  l_order_by varchar2 (32000);
  l_cur number;
  l_res number;
  l_total_rows number;
  l_row_num number;
  l_alias varchar2(1);
  l_scope ks_log.scope := gc_scope_prefix || 'session_id_navigation';

begin
  ks_log.log('START', l_scope);

  l_report := ks_util.get_ir_report (
      p_page_id => p_page_id
    , p_static_id => p_region_static_id
  );
          
  l_sql := l_report.sql_query;  
  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('l_sql:' || l_sql, l_scope);
  $END

  $IF wwv_flow_api.c_current >= 20180404 $THEN
    -- in 18.1 the alias changed from r to i
    l_alias := 'i';
  $ELSE
    l_alias := 'r';
  $END

  --l_report.sql_query selects the columns indicated on the option "menu Action > Select Columns" from the SQL Query indicated on the App Builder's IR Configuration.
  --The following line replaces the list of selected columns on l_report.sql_query by all the columns.
  --Ex: SESSION_NUM is not displayed on the IR, so it is not selected on l_report.sql_query.
  --Selecting all the columns with r.*, allows to order by any column indicated on the option "menu Action > Data > Sort" even if it is not included on "menu Action > Select Columns".
  --Also, the total number of rows is calculated at this level.
  l_sql := 'select count (id) over () as total_rows'
       || ',' || l_alias || '.*'
       || substr (l_sql, instr (l_sql, ' from '));

  l_order_by := ks_util.get_ir_order_by (p_ir_query => l_sql);
  $IF wwv_flow_api.c_current >= 20180404 $THEN
  -- in APEX 18.1 the order by construct changed and got an extra wrap ")i"
  if instr(l_order_by, ')i') > 0 then
    l_order_by := substr(l_order_by, 1, instr(l_order_by, ')i') -1);
  end if;
  $END

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('order by:' || l_order_by, l_scope);
  $END

  if l_order_by is null then
    l_order_by := 'order by session_num';
  end if;

  l_sql := 'select next
      ,previous
      ,total_rows
      ,row_num
    from (' ||
        '   select    id
                    , lead (id) over ( ' || l_order_by || ') next ' ||
        '           , lag (id) over ( ' || l_order_by || ') previous ' ||
        '           , total_rows ' ||
        '           , row_number () over ( ' || l_order_by || ') as row_num ' ||
        '   from (' || l_sql || 
        ' ))  where id=:ID';

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log ('New l_sql:' || l_sql, l_scope);
  $END

  l_cur := dbms_sql.open_cursor;

  dbms_sql.parse (l_cur, l_sql, dbms_sql.native);

  for i in 1..l_report.binds.count
  loop
    dbms_sql.bind_variable (l_cur, l_report.binds(i).name, l_report.binds(i).value);
    $IF $$VERBOSE_OUTPUT $THEN
      ks_log.log (l_report.binds(i).name || ':' || l_report.binds(i).value, l_scope);
    $END
  end loop;

  dbms_sql.bind_variable (l_cur, 'ID', p_id);
  dbms_sql.define_column (l_cur, 1, p_next_id);
  dbms_sql.define_column (l_cur, 2, p_previous_id);
  dbms_sql.define_column (l_cur, 3, p_total_rows);
  dbms_sql.define_column (l_cur, 4, p_current_row);

  l_res := dbms_sql.execute(l_cur);

  if dbms_sql.fetch_rows (l_cur) > 0 then
    dbms_sql.column_value (l_cur, 1, p_next_id);
    dbms_sql.column_value (l_cur, 2, p_previous_id);
    dbms_sql.column_value (l_cur, 3, p_total_rows);
    dbms_sql.column_value (l_cur, 4, p_current_row);
  end if;

  $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('p_next_id:' || p_next_id, l_scope);
    ks_log.log('p_previous_id:' || p_previous_id, l_scope);
    ks_log.log('p_total_rows:' || p_total_rows, l_scope);
    ks_log.log('p_current_row:' || p_current_row, l_scope);
  $END

  dbms_sql.close_cursor (l_cur);
  ks_log.log('END', l_scope);
exception
  when others then
    if dbms_sql.is_open (l_cur) then
      dbms_sql.close_cursor (l_cur);
    end if;

    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  session_id_navigation;




/**
 * For a given track session and user, indicate if the given user is the presenter 
 * or copresenter of the session.
 * The comparison is done against the ks_users.external_sys_ref which identifies users
 * in the external system.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 5, 2018
 * @param p_id
 * @return 'Y','N'
 */
function is_session_owner (
  p_session_id in ks_sessions.id%type
 ,p_username   in varchar2
)
return varchar2
is 
  l_scope ks_log.scope := gc_scope_prefix || 'is_session_owner';
  
  l_return varchar2(1) := 'N';

  l_external_sys_ref ks_users.external_sys_ref%type;
  l_presenter_user_id ks_sessions.presenter_user_id%type;
  l_co_presenter_user_id ks_sessions.co_presenter_user_id%type;
begin
  ks_log.log('START', l_scope);

  select s.presenter_user_id
       , s.co_presenter_user_id
    into l_presenter_user_id
       , l_co_presenter_user_id
    from ks_sessions s
   where s.id = p_session_id;

  select u.external_sys_ref
    into l_external_sys_ref
    from ks_users u
   where u.username = p_username;

  if l_external_sys_ref in (l_presenter_user_id, l_co_presenter_user_id) then
    l_return := 'Y';
  end if;

  ks_log.log('END', l_scope);
  return l_return;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end is_session_owner;




/**
 * Parse the "video link" text returning one line per link and formatting the link as an html anchor tag when applied.
 *
 * @example
 *
 * @issue
 *
 * @author Juan Wall
 * @created November 15, 2018
 * @param p_video_link
 * @return parsed text containing the link as a html anchor tag.
 */
function parse_video_link (
  p_video_link in ks_sessions.video_link%type
)
return varchar2
is 
  l_scope ks_log.scope := gc_scope_prefix || 'parse_video_link';
  
  c_link_format constant varchar2(1000) := '<a id="VIDEO_URL" href="#LINK#" target="_blank" alt="Video" title="Video">#LINK#</a>';
  
  l_links apex_t_varchar2;
  l_key varchar2(1000);
  l_link varchar2(32000);
  l_return varchar2(32000);
  l_is_not_first_line boolean := FALSE;
begin
  ks_log.log ('START', l_scope);

  l_links := apex_string.split(p_video_link, '<br />');
  l_key := l_links.first;
  
  while (l_key is not null)
  loop
    l_link := l_links (l_key);

    if substr (trim (l_link), 1, 4) = 'http' then 
      l_link := replace (c_link_format, '#LINK#', l_link);
    end if;

    if l_is_not_first_line then 
      l_return := l_return || '<br>' || l_link;
    else 
      l_return := l_link;
      l_is_not_first_line := TRUE;
    end if;

    l_key := l_links.next (l_key);
  end loop;

  ks_log.log ('END', l_scope);
  return l_return;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end parse_video_link;






/**
 * The function returns presenter's comp per track - this is identical for all tracks 
 * for which the user has submitted sessions.
 * Assumes that it will be called from within a SQL query, hence no track validation.
 * And the UDF pragma
 * 
 * @example - Displays presenter's comp for each associated track
    select  s.event_track_id
          , s.presenter_user_id
          , ks_session_api.get_presenter_comp(s.event_id, s.event_track_id , s.presenter_user_id) as presenter_comp
       from ks_sessions s
      where s.event_id = :p_event_id
        and s.presenter_user_id = :p_presenter_user_id
   group by s.event_id, s.event_track_id, s.presenter_user_id
   order by s.event_track_id
 *
 * @issue #36
 *
 * @author Ramona Birsan
 * @created October 7, 2019
 * @param p_event_id   
 * @param p_event_track_id
 * @param p_presenter_user_id
 * @return number
 */
function get_presenter_comp (
    p_event_id in ks_sessions.event_id%type 
  , p_event_track_id in ks_sessions.event_track_id%type    
  , p_presenter_user_id in ks_sessions.presenter_user_id%type 
) return number
is 
  pragma UDF;

  l_scope  ks_log.scope := gc_scope_prefix || 'get_presenter_comp';
  -- l_params logger.tab_param;
  l_presenter_comp number(3,2) := 0;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_event_track_id', p_event_track_id);
  -- logger.append_param(l_params, 'p_presenter_user_id', p_presenter_user_id);
  $IF $$VERBOSE_OUTPUT $THEN
  ks_log.log('START', l_scope);
  $END
  
  if is_speaker_comped (p_event_id, p_presenter_user_id) = 1 then 
    l_presenter_comp := 0;
  else
    -- "distinct event_track_id" is used because we calculate the total number of 
    -- tracks which have at least one session accepted
    with speaker_comp_track_ratio as (
      select  r.presenter_user_id
            , round(1/sum (r.track_comp),2) as speaker_comp_ratio
        from (
             select s.presenter_user_id
                  , count(distinct s.event_track_id) as track_comp
               from ks_sessions s
              where s.status_code = 'ACCEPTED' 
                and s.event_id = p_event_id 
              group by s.event_track_id, s.presenter_user_id 
         ) r
       group by r.presenter_user_id
      having r.presenter_user_id = p_presenter_user_id
    )
    select count (*) * tr.speaker_comp_ratio 
      into l_presenter_comp
      from speaker_comp_track_ratio tr
     where exists ( select 1
                      from ks_sessions ss
                     where ss.status_code = 'ACCEPTED'
                       and ss.event_id = p_event_id
                       and ss.event_track_id = p_event_track_id
                       and ss.presenter_user_id = p_presenter_user_id)
     group by tr.speaker_comp_ratio;
      
  end if;
  
  return l_presenter_comp;

  exception
    when no_data_found then
      return l_presenter_comp;
    when others then
      ks_log.log_error('Unhandled Exception ', l_scope);
      raise;
end get_presenter_comp;



end ks_session_api;
/

-- #44
-- @../plsql/ks_session_load_api.pls
create or replace package ks_session_load_api
is

--------------------------------------------------------------------------------
--*
--*
--*
--------------------------------------------------------------------------------

-- CONSTANTS

--------------------------------------------------------------------------------


procedure load_xlsx_data (
    p_xlsx      in blob
  , p_username  in varchar2 default v('APP_USER')
);

function validate_data(
    p_into_event_id in ks_event_tracks.event_id%TYPE
) return boolean;

procedure load_sessions (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
  , x_load_count in out number
);

procedure purge_event(
    p_event_id			in ks_sessions.event_id%TYPE
  , p_track_id			in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind	in varchar2
  , p_force_ind			in varchar2
);

procedure create_loaded_session_coll (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
);

procedure toggle_track_notification(p_seq_id in number);


end ks_session_load_api;
/
-- @../plsql/ks_session_load_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
create or replace package body ks_session_load_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix: Standard logger package name
 * @constant gc_all_clob_columns: comma separeted list of columns that are clobs
 * @constant c_loaded_session_coll: Name of the collection created during the load session wizard
 * @column_names_t: is the table type for columns taken from the export file.
 * @c_max_errors_to_display: the maximum number of errors to display to the user.
 * @index_map_t: maps column numbers from the export file to column names in ks_full_session_load
*/
gc_scope_prefix      constant varchar2(31) := lower($$PLSQL_UNIT) || '.';
gc_all_clob_columns  constant varchar2(4000) := 'SESSION_DESCRIPTION';
c_session_load_table constant varchar2(30) := 'KS_FULL_SESSION_LOAD';
c_loaded_session_coll constant varchar2 (30) := 'LOADED_SESSIONS';

c_max_errors_to_display constant number := 6;

type column_names_t is varray(4000) of varchar2(4000);

-- type index_map_t is table of varchar2(30) index by varchar2(10);
type index_map_t is table of varchar2(30) index by pls_integer;



--==============================================================================
-- Function: add_error_check_continue
-- Purpose: Wrapper function for apex_error. It logs the error and if we've reached the threshold c_max_errors_to_display we return false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function add_error_check_continue (p_message in varchar2,
                                   p_display_location in varchar2)
  return boolean
is
  l_scope ks_log.scope := 'add_error_check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);

  apex_error.add_error(
            p_message => p_message
          , p_display_location => p_display_location
        );

  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end add_error_check_continue;




--==============================================================================
-- Function: check_continue
-- Purpose: Checks if we've reached the threshold c_max_errors_to_display. If so, then it returns false.
--
-- Inputs:  p_message - message to be displayed
--          p_display_location - apex_error constant for display location
-- Output: whether we have crossed the c_max_errors_to_display threshold
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function check_continue
  return boolean
is
  l_scope ks_log.scope := 'check_continue';
  --l_params logger.tab_param;
begin
  --logger.append_param(l_params, 'p_message', p_message);
  --ks_log.append_param(l_params, 'p_display_location', p_display_location);
  ks_log.log('START', l_scope);


  if apex_error.get_error_count >= c_max_errors_to_display
  then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end check_continue;




--==============================================================================
-- Function: validate_uniqueness
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_uniqueness
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_uniqueness';

  l_count number;
  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select session_num
      from ks_full_session_load
     where app_user = l_username
     group by session_num
    having count(*) > 1
  )
  loop
    if not add_error_check_continue(p_message => 'The session_number "' || row.session_num || '", is not unique. Correct to continue.'
                             ,  p_display_location => apex_error.c_inline_in_notification
                                )
    then
      return false;
    end if;
  end loop;

  --Do the same thing for external_sys_ref
  for row in (
    select external_sys_ref
      from ks_full_session_load
     where app_user = l_username
     group by external_sys_ref
     having count(*) > 1
  )
  loop
    if not add_error_check_continue(
        p_message => 'The session id (external system reference) "' || row.external_sys_ref || '", is not unique. Correct to continue.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;

  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_uniqueness;



--==============================================================================
-- Function: validate_not_null
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_not_null
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_not_null';

  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select title
      from ks_full_session_load
     where app_user = l_username
       and ( session_num is null
          or external_sys_ref is null
        )
  )
  loop
    if not add_error_check_continue(
        p_message => 'Session "' || substr(row.title,1,20) || '" is missing a session_num or external_sys_ref.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  for row in (
    select session_num || ':' || title name
      from ks_full_session_load
     where app_user = l_username
       and event_track_id is null
  )
  loop
    if not add_error_check_continue(
        p_message => 'Session "' || substr(row.name,1,20) || '" is missing a track.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_not_null;



--==============================================================================
-- Function: validate_new_session
-- Purpose:
--
-- Inputs:
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_new_session(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_new_session';

  l_username varchar2(60);
begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  for row in (
    select sl.session_num
      from ks_full_session_load sl
         , ks_sessions s
     where sl.app_user = l_username
       and s.session_num = sl.session_num
       and s.event_id = p_into_event_id
  )
  loop
    if not add_error_check_continue(
        p_message => 'A session with session number "' || row.session_num || '" already exists for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  for row in (
    select sl.external_sys_ref
      from ks_full_session_load sl
         , ks_sessions s
     where sl.app_user = l_username
       and s.external_sys_ref = sl.external_sys_ref
       and s.event_id = p_into_event_id
  )
  loop
    if not add_error_check_continue(
        p_message => 'A session with session id (external_sys_ref) "' || row.external_sys_ref || '" already exists for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      return false;
    end if;
  end loop;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_new_session;




--==============================================================================
-- Function: validate_correct_tracks
-- Purpose:
--
-- Inputs: p_into_event_id - the id of the event
-- Output:
-- Scope: Not publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/13/2017
--==============================================================================
function validate_correct_tracks(p_into_event_id varchar2)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_correct_tracks';

  l_username varchar2(60);

begin
  ks_log.log('START', l_scope);

  l_username := v('APP_USER');

  --First check the track
  -- Sorry, ks_full_session_load.event_track_id is not an ID at all but a name!
  for row in (
    select distinct sl.event_track_id
      from ks_full_session_load sl
     where sl.app_user = l_username
       and sl.event_track_id not in (
        select name
          from ks_event_tracks
         where event_id = p_into_event_id
     )
  )
  loop
    if not add_error_check_continue(
        p_message => 'The track "'|| row.event_track_id ||'" does not exist for this event.'
      , p_display_location => apex_error.c_inline_in_notification
    )
    then
      ks_log.log('Missing track, Abort!', l_scope);
      return false;
    end if;
  end loop;

  ks_log.log('END', l_scope);
  
  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_correct_tracks;





--==============================================================================
-- Function: validate_data
-- Purpose: Runs validations checks on the data. This occurs after ks_full_session_load is loaded and it's columns are validated,
--             but before we have submitted it's data to the corresponding tables.
--
-- Inputs: p_into_event_id, the id the of the event
-- Output: whether the data is avalid or not
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/12/2017
--==============================================================================
function validate_data(p_into_event_id ks_event_tracks.event_id%TYPE)
  return boolean
is
  l_scope ks_log.scope := gc_scope_prefix || 'validate_data';

begin
  ks_log.log('START', l_scope);

  if not validate_uniqueness
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_not_null
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_new_session(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;

  if not validate_correct_tracks(p_into_event_id => p_into_event_id)
  then
    if not check_continue then
      return false;
    end if;
  end if;


  if apex_error.get_error_count > 0
  then
    return false;
  end if;

  ks_log.log('END', l_scope);

  return true;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end validate_data;





--==============================================================================
-- Function: validate_column_names
-- Purpose: This makes sure that the first row of the .xlsx file contains row names FOR EACH column in ks_session_load (minus event_id, track_id, and app_user)
--
-- Inputs: p_column_names - varray of column names
-- Output: returns true if valid, false if invalid
-- Scope: Not  Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/09/2017
--==============================================================================
function validate_column_names (p_column_names in column_names_t)
return boolean
is
  l_scope ks_log.scope := 'validate_column_names';
  --l_params logger.tab_param;
  type column_names_dict_t is table of varchar2(20) index by varchar2(4000);
  l_column_names_dict column_names_dict_t;

  i number := 0;
  idx varchar2(4000);
begin
  --logger.append_param(l_params, 'p_column_names', p_column_names);
  ks_log.log('START', l_scope);


  for row in (
    select trim(upper(lm.header_name)) header
      from ks_load_mapping lm
     where table_name = c_session_load_table
  )
  loop
    l_column_names_dict(row.header) := 'not_matched';
  end loop;

  for i in 1..p_column_names.count
  loop
      if not l_column_names_dict.exists(trim(upper(p_column_names(i))))
      then
        if not add_error_check_continue(p_message => 'The column "' || p_column_names(i) || '" does not match any column names specified in the instructions.'
                                     ,  p_display_location => apex_error.c_inline_in_notification
                            )
        then
          return false;
        end if;
      else
        l_column_names_dict(trim(upper(p_column_names(i)))) := 'matched';
      end if;
  end loop;

  ks_log.log('before l_column_names_dict loop', l_scope);

  idx := l_column_names_dict.first;
  while idx is not null
  loop
    if l_column_names_dict(idx) = 'not_matched'
    then
      ks_log.log('Not matched l_column_names_dict(' || idx || '):', l_scope);
      if not add_error_check_continue(p_message => 'The column "' || initcap(idx) || '", was not found in the file. Please ensure this column exists in the file.'
                       ,  p_display_location => apex_error.c_inline_in_notification
                            )
       then
        return false;
       end if;
    end if;
    idx := l_column_names_dict.next(idx);
  end loop;

  ks_log.log('after l_column_names_dict loop. Errors:' || apex_error.get_error_count, l_scope);

  if apex_error.get_error_count > 0 then
    return false;
  else
    return true;
  end if;

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_names;




--==============================================================================
-- Function: validate_column_order
-- Purpose: validates that the columns provided in the export file are in the correct order
--
-- Inputs:  p_column_names - an array of colum names
-- Output: returns true if valid, false if invalid
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes: THIS FUNCTION IS NOT USED - the function works, but turned out to not be useful.
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
function validate_column_order (p_column_names in column_names_t)
  return boolean
is
  l_scope ks_log.scope := 'validate_column_order';
  --l_params logger.tab_param;
  l_idx number := 1;
  l_columns_in_their_order varchar2(4000);
begin
  --logger.append_param(l_params, 'p_column_names', p_column_names);
  ks_log.log('START', l_scope);

  for row in (select trim(upper(lm.header_name)) header_name,
                     display_seq
              from ks_load_mapping lm
             where 1=1
            and table_name = c_session_load_table
            and lm.to_column_name is not null
            order by lm.display_seq
            )
  loop
    if p_column_names(row.display_seq) != row.header_name
    then
      select listagg(lm.header_name, ', ') within group (order by lm.display_seq) value
        into l_columns_in_their_order
        from ks_load_mapping lm
        where 1=1
          and table_name = c_session_load_table;


        apex_error.add_error(
                  p_message => 'The columns in the export file are in an incorrect order. The proper order is: ' ||
                                  l_columns_in_their_order || '. At least this column is out of order: ' || p_column_names(l_idx)
                , p_display_location => apex_error.c_inline_in_notification
              );
      --This is a big error (lots of text), so exit here regardless of number of errors.
      return false;
    end if;

  end loop;

  return true;
exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end validate_column_order;



--==============================================================================
-- Procedure: init_index_map
-- Purpose: After the column names have been validated from the file,
--            we need to map which columns headers in the export go to which columns in ks_full_session_load
-- ASUMPTION(S): Column names are valid, and there aren't any missing
-- Inputs:  l_column_names - column names from the import file
--          l_cells - the final table we will create our view from.
-- Output:
-- Scope: Not Publicly accessible
-- Errors: Logged and Raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/11/2017
--==============================================================================
procedure init_index_map ( p_index_map in out nocopy index_map_t)
is
  l_scope ks_log.scope := gc_scope_prefix || 'init_index_map';
  --l_params logger.tab_param;

  l_index pls_integer;
begin
  --logger.append_param(l_params, 'l_column_names', l_column_names);
  ks_log.log('START', l_scope);

  for row in (
    select m.to_column_name
         , m.display_seq
      from ks_load_mapping m
     where m.table_name = c_session_load_table
     order by m.display_seq
  )
  loop
    p_index_map(p_index_map.count + 1) := nvl(row.to_column_name, '- not mapped -');
    ks_log.log('mapped: ' || p_index_map.count || ' to '  || row.to_column_name, l_scope);
  end loop;

  ks_log.log('map size: ' || p_index_map.count, l_scope);

  $IF $$VERBOSE_OUTPUT $THEN
  l_index := p_index_map.first;
  while l_index is not null
  loop
    ks_log.log('p_index_map(' || l_index ||'): ' || p_index_map(l_index), l_scope);    
    l_index := p_index_map.next(l_index);
  end loop;
  $END

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end init_index_map;


/**
 * Load data from xlsx into appropriate collection for parsing. All data is
 * loaded to into the session APP_USER
 *
 * @example
 * 
 * @issue
 *
 * @author Ben Shumway (Insum Solutions)
 * @created Oct/09/2017
 * @param p_xlsx blob with all data
 */
procedure load_xlsx_data (
    p_xlsx      in blob
  , p_username  in varchar2 default v('APP_USER')
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'load_xlsx_data';

  l_column_names column_names_t;

  l_cells as_read_xlsx_clob.tp_all_cells;
  l_curr_row number;

  l_rows_row number;

  type session_load_row_t is table of ks_full_session_load%rowtype;
  l_rows session_load_row_t;

  l_curr_col varchar2(30);

  --column index for spreadsheet_content
  l_col_ind number;

  l_index_map index_map_t;
  l_index pls_integer;

  --used to get the first 4000 bytes of any string data
  l_substr varchar2(4000);
  --used to get the length of the string data
  l_substr_len number;

  l_string_val clob;
  l_number_val number;
  l_date_val date;

  l_reached_final_line boolean := false;

  --An array of tags
  l_tags apex_application_global.vc_arr2;

  --An array of session_length
  l_session_length apex_application_global.vc_arr2;
    

begin
   --logger.append_param(l_params, 'p_username', p_username);
   --logger.append_param(l_params, 'p_into_event_id', p_into_event_id);
   --logger.append_param(l_params, 'p_into_track_id', p_into_track_id);
   ks_log.log('BEGIN', l_scope);

   l_column_names := column_names_t();
   l_rows := session_load_row_t();

   select *
    bulk collect into l_cells
    from table(AS_READ_XLSX_CLOB.read(p_xlsx => p_xlsx))
   order by row_nr, col_nr;

   for i in 1 ..  l_cells.count
   loop
      l_curr_row := l_cells(i).row_nr;
      $IF $$VERBOSE_OUTPUT $THEN
      ks_log.log('BEGIN cell: ' ||  l_cells(i).row_nr || ',' || l_cells(i).col_nr, l_scope);
      $END

      --NOTE: Assumption, the bulk collect gets all cells in order by row then column
      if l_curr_row = 2 and l_cells(i).col_nr = 1
      then
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('Length of l_column_names: ' || l_column_names.count, l_scope);
        $END
        if not ks_session_load_api.validate_column_names(l_column_names) then
          return;
        end if;

        --modify l_cells so that the column names are correct
        init_index_map(l_index_map);

      elsif l_curr_row = 1 then
        l_column_names.extend;
        --Get the column name (allows the .xlsx header to be defined "fuzzilly"
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('Adding name: "' || l_cells(i).string_val || '"" to (' || i || ')', l_scope);
        $END
        l_column_names(i) := trim(upper(cast(l_cells(i).string_val as varchar2)));
     end if;

     $IF $$VERBOSE_OUTPUT $THEN
     ks_log.log('i: ' || i, l_scope);
     $END

     if l_curr_row > 1 then

        if l_rows.count < l_curr_row -1 then
          if l_reached_final_line then
            l_rows.delete(l_rows.count);
            exit;
          else
            l_reached_final_line := true; --Considered true until proven otherwise
          end if;
          l_rows.extend;
        end if;

        -- l_string_val := coalesce(l_cells(i).string_val, to_char(l_cells(i).number_val), to_char(l_cells(i).date_val));

        l_string_val := trim(l_cells(i).string_val);
        l_number_val := l_cells(i).number_val;
        l_date_val := l_cells(i).date_val;

        l_rows_row := l_curr_row -1;

        if   l_string_val is not null
          or l_number_val is not null
          or l_date_val is not null
        then
          l_reached_final_line := false;
        end if;
        
        if l_number_val is not null
        then
          $IF $$VERBOSE_OUTPUT $THEN
          ks_log.log('found number column, converting to vc', l_scope);
          $END
          l_string_val := to_char(l_number_val);
        end if;

        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('current:' || l_string_val, l_scope);
        $END


        --The commented out code shows when the as_read_xlsx_clob package skips cells
        /*ks_log.log('Checking existence of: ' || to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end) || ', l_cells(i).col_nr: ' || l_cells(i).col_nr 
                                                                       || ', string_val: ' || l_cells(i).string_val );
        l_index := to_char(case when 
                                                                  mod(i, l_column_names.count) = 0 
                                                                  then l_column_names.count 
                                                                  else mod(i, l_column_names.count)
                                                                  end);*/
        l_index := l_cells(i).col_nr;
        if l_index_map.exists(l_index) then

          l_curr_col := l_index_map(l_index);
          $IF $$VERBOSE_OUTPUT $THEN
          ks_log.log('l_curr_col: ' || l_curr_col, l_scope);
          $END
          
          if l_curr_col = 'EXTERNAL_SYS_REF'
          then            
            l_rows(l_rows_row).external_sys_ref := l_string_val;
          elsif l_curr_col = 'SESSION_NUM'
          then
            l_rows(l_rows_row).session_num :=  l_string_val;
          elsif l_curr_col = 'EVENT_TRACK_ID'
          then
            l_rows(l_rows_row).event_track_id := l_string_val;
          elsif l_curr_col = 'SUB_CATEGORY'
          then
            l_rows(l_rows_row).sub_category := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_TYPE'
          then
            l_rows(l_rows_row).session_type := substr(l_string_val,1,500);
          elsif l_curr_col = 'TITLE'
          then
            l_rows(l_rows_row).title := substr(l_string_val,1,500);
          elsif l_curr_col = 'ACE_LEVEL'
          then
            l_rows(l_rows_row).ace_level := substr(l_string_val,1,30);
          elsif l_curr_col = 'COMPANY'
          then
            l_rows(l_rows_row).company := substr(l_string_val,1,500);
          elsif l_curr_col = 'SESSION_ABSTRACT'
          then
            l_rows(l_rows_row).session_abstract := l_string_val;
          elsif l_curr_col = 'SESSION_SUMMARY'
          then
            l_rows(l_rows_row).session_summary := substr(l_string_val,1,4000);
          elsif l_curr_col = 'TARGET_AUDIENCE'
          then
            l_rows(l_rows_row).target_audience := substr(l_string_val,1,60);
          elsif l_curr_col = 'TECHNOLOGY_PRODUCT'
          then
            l_rows(l_rows_row).technology_product := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTED_BEFORE_IND'
          then
            l_rows(l_rows_row).presented_before_ind := l_string_val;
          elsif l_curr_col = 'PRESENTED_BEFORE_WHERE'
          then
            l_rows(l_rows_row).presented_before_where := substr(l_string_val,1,4000);
          elsif l_curr_col = 'PRESENTED_ANYTHING_IND'
          then
            l_rows(l_rows_row).presented_anything_ind := l_string_val;
          elsif l_curr_col = 'PRESENTED_ANYTHING_WHERE'
          then
            l_rows(l_rows_row).presented_anything_where := substr(l_string_val,1,4000);            
          elsif l_curr_col = 'VIDEO_LINK'
          then
            l_rows(l_rows_row).video_link := substr(l_string_val,1,4000);
          elsif l_curr_col = 'CO_PRESENTER'
          then
            l_rows(l_rows_row).co_presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_COMPANY'
          then
            l_rows(l_rows_row).co_presenter_company := substr(l_string_val,1,500);
          elsif l_curr_col = 'PRESENTER_BIOGRAPHY'
          then
            l_rows(l_rows_row).presenter_biography := l_string_val;
          elsif l_curr_col = 'PRESENTER'
          then
            l_rows(l_rows_row).presenter := substr(l_string_val,1,500);
          elsif l_curr_col = 'TAGS'
          then
            l_tags := apex_util.string_to_table(l_string_val,',');
            for i in 1..l_tags.count
            loop
              l_tags(i) := trim(l_tags(i));
            end loop;
            l_rows(l_rows_row).tags := substr(apex_util.table_to_string(l_tags,':'),1,1000);
          elsif l_curr_col = 'SESSION_LENGTH'
          then
            l_session_length := apex_util.string_to_table(l_string_val,',');
            for i in 1..l_session_length.count
            loop
              l_session_length(i) := trim(l_session_length(i));
            end loop;
            l_rows(l_rows_row).session_length := substr(apex_util.table_to_string(l_session_length,':'),1,500);
          elsif l_curr_col = 'CONTAINS_DEMO_IND'
          then
            l_rows(l_rows_row).contains_demo_ind := l_string_val;
          elsif l_curr_col = 'WEBINAR_WILLING_IND'
          then
            l_rows(l_rows_row).webinar_willing_ind := l_string_val;
          elsif l_curr_col = 'PRESENTER_EMAIL'
          then
            l_rows(l_rows_row).presenter_email := substr(l_string_val,1,500);
          elsif l_curr_col = 'CO_PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).co_presenter_user_id := case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'PRESENTER_USER_ID'
          then
            l_rows(l_rows_row).presenter_user_id :=  case when l_number_val = 0 then null else l_number_val end;
          elsif l_curr_col = 'SUBMISSION_DATE'
          then
            -- l_rows(l_rows_row).submission_date := to_date(l_string_val, 'DD/MM/RR HH24:MI');
            l_rows(l_rows_row).submission_date := l_date_val;
          end if;

        end if;
      end if;
    end loop;


    ks_log.log('Removing previous load data (if present)', l_scope);
    delete 
      from ks_full_session_load s
     where app_user = p_username;


    ks_log.log('Inserting into ks_full_session_load', l_scope);
    forall i in l_rows.first .. l_rows.last
      insert into ks_full_session_load (
          app_user
        , external_sys_ref
        , session_num
        , event_track_id
        , sub_category
        , session_type
        , title
        , ace_level
        , presented_before_ind
        , presented_before_where
        , presented_anything_ind
        , presented_anything_where
        , video_link
        , co_presenter
        , co_presenter_company
        , presenter_biography
        , company
        , presenter
        , session_abstract
        , session_summary
        , tags
        , session_length
        , target_audience
        , technology_product
        , contains_demo_ind
        , webinar_willing_ind
        , presenter_email
        , co_presenter_user_id
        , presenter_user_id
        , submission_date
      )
      values (
          p_username
        , l_rows(i).external_sys_ref
        , l_rows(i).session_num
        , l_rows(i).event_track_id
        , l_rows(i).sub_category
        , l_rows(i).session_type
        , l_rows(i).title
        , l_rows(i).ace_level
        , l_rows(i).presented_before_ind
        , l_rows(i).presented_before_where
        , l_rows(i).presented_anything_ind
        , l_rows(i).presented_anything_where
        , l_rows(i).video_link
        , l_rows(i).co_presenter
        , l_rows(i).co_presenter_company
        , l_rows(i).presenter_biography
        , l_rows(i).company
        , l_rows(i).presenter
        , l_rows(i).session_abstract
        , l_rows(i).session_summary
        , l_rows(i).tags || nvl2(l_rows(i).session_length, nvl2(l_rows(i).tags, ':', ''), '') || l_rows(i).session_length
        , l_rows(i).session_length
        , l_rows(i).target_audience
        , l_rows(i).technology_product
        , l_rows(i).contains_demo_ind
        , l_rows(i).webinar_willing_ind
        , l_rows(i).presenter_email
        , l_rows(i).co_presenter_user_id
        , l_rows(i).presenter_user_id
        , l_rows(i).submission_date
      );

  ks_log.log('END', l_scope);
  
  exception when others
  then
    ks_log.log('ERROR', l_scope);
    raise;

end load_xlsx_data;



/**
 *
 *
 * @example
 *  ks_session_load_api.load_sessions(
 *      p_event_id   => :P5040_EVENT_ID
 *    , x_load_count => :P5041_ROW_COUNT
 *  );
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created January 6, 2018
 * @param p_event_id
 * @param p_username (optional)
 * @param x_load_count - final load count
 * @return
 */
procedure load_sessions (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
  , x_load_count in out number
)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'load_sessions';
begin
  ks_log.log('BEGIN', l_scope);

  insert into ks_sessions(
      id
    , event_id
    , event_track_id
    , external_sys_ref
    , session_num
    , sub_category
    , session_type
    , title
    , presenter
    , company
    , co_presenter
    , co_presenter_company
    , tags
    , session_length
    , presenter_email
    , session_abstract
    , session_summary
    , target_audience
    , presented_before_ind
    , presented_before_where
    , presented_anything_ind
    , presented_anything_where
    , technology_product
    , ace_level
    , video_link        
    , contains_demo_ind
    , webinar_willing_ind
    , presenter_biography
    , co_presenter_user_id
    , presenter_user_id
    , submission_date
   )            
  select null
       , p_event_id
       , e.id
       , s.external_sys_ref
       , s.session_num
       , s.sub_category
       , s.session_type
       , s.title
       , s.presenter
       , s.company
       , s.co_presenter
       , s.co_presenter_company
       , s.tags
       , s.session_length
       , s.presenter_email
       , s.session_abstract
       , s.session_summary
       , s.target_audience
       , decode(trim(lower(s.presented_before_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presented_before_where
       , decode(trim(lower(s.presented_anything_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presented_anything_where
       , s.technology_product        
       , s.ace_level
       , s.video_link        
       , decode(trim(lower(s.contains_demo_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , decode(trim(lower(s.webinar_willing_ind))
          , null, 'N'
          , 'n', 'N'
          , 'yes', 'Y'
          , 'y', 'Y'
          , 'N'
         )
       , s.presenter_biography
       , co_presenter_user_id
       , presenter_user_id
       , coalesce(submission_date, sysdate)
    from ks_full_session_load s
         left outer join ks_event_tracks e on s.event_track_id = e.name and e.event_id = p_event_id
   where s.app_user = p_username
   order by s.session_num;

  x_load_count := SQL%ROWCOUNT;

  ks_log.log('END', l_scope);

  exception
    when OTHERS then
      ks_log.log_error('Unhandled Exception', l_scope);
      raise;
end load_sessions;






/**
 * Process to purge votes, sessions and tags from and event and/or track.
 *
 * @example
 *
 * @issue
 *
 * @author Guillermo Hernandez
 * @created October 25, 2017
 * @param p_event_id id of the specific event.
 * @param p_track_id id of a specific track.
 * @param p_votes_only_ind to specify that only votes should be deleted.
 * @param p_force_ind to force the execution of the process even when votes
 *                    are present.
 */
procedure purge_event(
  p_event_id          in ks_sessions.event_id%TYPE
  , p_track_id        in ks_sessions.event_track_id%TYPE default null
  , p_votes_only_ind  in varchar2
  , p_force_ind       in varchar2
)
is
  l_scope  ks_log.scope := gc_scope_prefix || 'purge_event';

  no_action exception;

  l_votes_count number := 0;

begin
  ks_log.log('BEGIN', l_scope);

  -- This count is for pretection.
  -- We don't want to delete when there are votes present.
  select count(1)
    into l_votes_count
    from ks_session_votes v
       , ks_sessions s
   where v.session_id = s.id
     and s.event_id = p_event_id
     and (p_track_id is null or s.event_track_id = p_track_id)
     and p_votes_only_ind = 'N';


  if l_votes_count > 0 then
    -- if this parameter equals No 'N' then the process raises an error indicating no action will be done.
    raise no_action;
  end if;


  -- Delete the votes when the user selects "Votes Only" or "Force Purge"
  delete 
    from ks_session_votes v
   where v.session_id in (
      select ss.id
        from ks_sessions ss
       where ss.event_id = p_event_id
         and (p_track_id is null or ss.event_track_id = p_track_id)
   )
     and (p_votes_only_ind = 'Y' or p_force_ind = 'Y');


  -- Only delete sessions when the there are no votes and user selected Votes Only
  -- OR 
  -- Delete when user selected "Force Purge"
  delete
    from ks_sessions
   where event_id = p_event_id
     and (p_track_id is null or event_track_id = p_track_id)
     and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
         or p_force_ind = 'Y'
       );


  -- Remove unused tags after the "delete ks_sessions"
  --   When the there are no votes and user selected Votes Only
  --   OR 
  --   Delete when user selected "Force Purge"
  delete
    from ks_tag_type_sums ts
   where exists (
    select 1
     from ks_tag_type_sums s
        , ks_event_tracks t
    where s.content_type = 'SESSION' || ':' || t.id
      and s.tag_count = 0
      and s.rowid = ts.rowid
      and t.event_id = p_event_id
      and (p_track_id is null or t.id = p_track_id)
   )
    and ( (l_votes_count = 0 and p_votes_only_ind = 'N')
        or p_force_ind = 'Y'
      );

  ks_log.log('END', l_scope);

  exception
    when no_action then
      raise_application_error (-20000,'Votes are present. Purge action aborted.');
    
end purge_event;




/**
 * Create collection session loaded having
 *    - The name of the track 
 *    - The number of loaded sessions by track
 *    - The checked flag (set Y by default)
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/07/2019
 * @param 
 */
procedure create_loaded_session_coll (
    p_event_id   in ks_events.id%TYPE
  , p_username   in varchar2 default v('APP_USER')
)
is
  l_scope ks_log.scope := gc_scope_prefix || 'create_loaded_session_coll';
  l_sql varchar2 (32000);
  l_param_names apex_application_global.vc_arr2;
  l_param_values apex_application_global.vc_arr2;
begin
  ks_log.log('START', l_scope);
  
  l_sql := q'[select e.id track_id
          ,count(*) session_count
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,null
          ,s.event_track_id track_name
          ,'Y' notify_ind
  from    ks_full_session_load s
  left    outer join ks_event_tracks e 
  on      s.event_track_id = e.name 
  and     e.event_id = :p_event_id
  where   s.app_user = :p_username
  group   by s.event_track_id
         ,e.id]';

  if apex_collection.collection_exists (p_collection_name => c_loaded_session_coll) then 
    apex_collection.delete_collection (p_collection_name  => c_loaded_session_coll);
  end if;

  l_param_names(l_param_names.count + 1) := 'p_event_id';
  l_param_values(l_param_values.count + 1) := p_event_id;
  
  l_param_names(l_param_names.count + 1) := 'p_username';
  l_param_values(l_param_values.count + 1) := p_username;

  apex_collection.create_collection_from_queryb2 (
    p_collection_name => c_loaded_session_coll
   ,p_query           => l_sql
   ,p_names           => l_param_names
   ,p_values          => l_param_values
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception', l_scope);
    raise;
end create_loaded_session_coll;



/**
 * Toggle the notification status of a loaded track
 *
 * @example
 * 
 * @issue
 *
 * @author Juan Wall (Insum Solutions)
 * @created Nov/08/2019
 * @param p_seq_id position in the collection
 * @param p_notification_ind Y|N
 */
procedure toggle_track_notification(p_seq_id in number)
is
  l_scope ks_log.scope := gc_scope_prefix || 'toggle_track_notification';

  l_notification_ind varchar2(1);

begin
  ks_log.log('START', l_scope);
  ks_log.log('p_seq_id:' || p_seq_id, l_scope);
  
  -- Get the new value
  select decode(notify_ind, 'Y', 'N', 'Y')
    into l_notification_ind
    from ks_session_load_coll_v
   where seq_id = p_seq_id;

  ks_log.log('l_notification_ind:' || l_notification_ind, l_scope);

  apex_collection.update_member_attribute  (
      p_collection_name => c_loaded_session_coll
    , p_seq => p_seq_id
    , p_attr_number => 2
    , p_attr_value  => l_notification_ind
  );

  ks_log.log('END', l_scope);

exception
  when others then
    ks_log.log('Unhandled Exception:' || sqlerrm, l_scope);
    raise;
end toggle_track_notification;



end ks_session_load_api;
/


-- @../plsql/ks_util.pls
create or replace package ks_util
as

type gc_clob_arr_type is table of clob;

--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2;

--------------------------------------------------------------------------------
procedure set_param(
    p_name_key  in ks_parameters.name_key%TYPE
  , p_value     in ks_parameters.value%TYPE
);


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2;


--------------------------------------------------------------------------------
function format_full_name
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2;


--------------------------------------------------------------------------------
function is_number
(
  p_value        in         varchar2
) return boolean;

--------------------------------------------------------------------------------
function string_to_coll (p_string in varchar2) return sys.ODCIVarchar2List;

--------------------------------------------------------------------------------
function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         )
  return varchar2;

--------------------------------------------------------------------------------
function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report;


---------------------------------------------------------------------------------
function blob2clob(
  p_blob in blob,
  p_blob_csid in integer default dbms_lob.default_csid)
  return clob;

function replace_tokens (p_string in varchar2,
                         p_tokens in varchar2,
                         p_token_exceptions in varchar2)
 return varchar2;

function clob_to_varchar2_table (p_clob in out nocopy clob)
  return gc_clob_arr_type;

function ir_has_filters(
    p_ir_t      in apex_ir.t_report) 
  return boolean;
end ks_util;
/
-- @../plsql/ks_util.plb
create or replace package body ks_util
as

--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';


--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2
is
  l_value ks_parameters.value%TYPE;
begin

  select value
    into l_value
    from ks_parameters
   where name_key = p_name_key;

  return l_value;

exception
  when NO_DATA_FOUND then
    return null;

end get_param;



--------------------------------------------------------------------------------
procedure set_param(
    p_name_key      in ks_parameters.name_key%TYPE
  , p_value         in ks_parameters.value%TYPE
)
is
begin

  update ks_parameters
     set value = p_value
   where name_key = p_name_key;

  if sql%rowcount = 0 then
    raise_application_error(
        -20001
      , 'Parameter ' || p_name_key || ' does not exist.'
    );
  end if;

end set_param;


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2
is
  -- l_scope   logger_logs.scope%type := gc_scope_prefix || 'get_email';
  -- l_params  logger.tab_param;

  l_email ks_users.email%TYPE;
begin
  -- logger.append_param(l_params, 'p_username', p_username);
  -- logger.log('START', l_scope, null, l_params);

  select email
    into l_email
    from ks_users
   where username = p_username;

  return l_email;

exception
  when NO_DATA_FOUND then
    -- logger.log_error('Probably an invalid user.');
    return null;

end get_email;




function format_full_name
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2
IS
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'format_full_name';
  -- l_params logger.tab_param;
begin
--  logger.append_param(l_params, 'p_text', p_text);

  RETURN rtrim(p_first_name || ' ' || p_last_name);

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end format_full_name;






function is_number
(
  p_value        in         varchar2
) return boolean
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'is_number';
  -- l_params            logger.tab_param;

  non_numeric      exception;
  pragma exception_init (non_numeric, -06502);

  l_number     number;
begin
   l_number := p_value;

   return true;

exception
  when non_numeric then
    return false;
end is_number;





function string_to_coll (p_string in VARCHAR2) return sys.ODCIVarchar2List
is
  l_table wwv_flow_global.vc_arr2;
  l_list  sys.ODCIVarchar2List := new sys.ODCIVarchar2List();
begin
  l_table := apex_util.string_to_table(p_string);
  l_list.extend(l_table.count());
  for i in 1..l_table.count()
  loop
    l_list(i) := l_table(i);
  end loop;
  return l_list;
end string_to_coll;




function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         )
  return varchar2
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_order_by';
  -- l_params            logger.tab_param;

  l_order_by          varchar2(32000);
  l_instr             number;
begin
  -- logger.log('START', l_scope, null, l_params);

  l_instr := instr (p_ir_query, 'order by', -1);

  if l_instr > 0
  then
     -- grab the final order by from the IR query and trim off any trailing ")"
     l_order_by := rtrim (substr (p_ir_query, l_instr), ')');

  else -- add default order by for use by analytics lead/gag functions
    l_order_by := 'order by ' || p_default_pk; -- Use a column that's always present
  end if;

  -- logger.log('order by:' || l_order_by, l_scope, null, l_params);
  return l_order_by;

exception
  when others then
    null;
end get_ir_order_by;





function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_report';
  -- l_params            logger.tab_param;

  l_region_id          number;
begin
  -- logger.append_param(l_params, 'p_page_id', p_page_id);
  -- logger.append_param(l_params, 'p_static_id', p_static_id);
  -- logger.log('START', l_scope, null, l_params);

  select region_id
    into l_region_id
    from apex_application_page_regions
   where static_id = p_static_id
     and page_id   = p_page_id
     and application_id = (select v('APP_ID') from dual);

  return apex_ir.get_report
         (
            p_page_id   => p_page_id
          , p_region_id => l_region_id
         );

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end get_ir_report;


/**
  * Converts blob to clob
  *
  * Notes:
  *  - Copied from OOS Utils https://github.com/OraOpenSource/oos-utils/blob/master/source/packages/oos_util_lob.pkb
  *
  */
 function blob2clob(
   p_blob in blob,
   p_blob_csid in integer default dbms_lob.default_csid)
   return clob
 as
   l_clob clob;
   l_dest_offset integer := 1;
   l_src_offset integer := 1;
   l_lang_context integer := dbms_lob.default_lang_ctx;
   l_warning integer;
 begin
   if p_blob is null then
     return null;
   end if;

   dbms_lob.createtemporary(
     lob_loc => l_clob,
     cache => false);

   dbms_lob.converttoclob(
     dest_lob => l_clob,
     src_blob => p_blob,
     amount => dbms_lob.lobmaxsize,
     dest_offset => l_dest_offset,
     src_offset => l_src_offset,
     blob_csid => p_blob_csid,
     lang_context => l_lang_context,
     warning => l_warning);

   return l_clob;
 end blob2clob;



--==============================================================================
-- Function: clob_to_varchar2_table
-- Purpose: takes a clob and returns it as a table of varchar2s with size 4000
--
-- Inputs:  p_clob - the clob to be passed in
-- Output:
-- Scope: Publicly accessible
-- Errors: Logged and Raised.
-- Notes:  Some of this code taken from https://stackoverflow.com/questions/11647041/reading-clob-line-by-line-with-pl-sql
-- Author: Ben Shumway (Insum Solutions) - Oct/26/2017
--==============================================================================
function clob_to_varchar2_table (p_clob in out nocopy clob)
  return gc_clob_arr_type
is
  l_scope varchar2(255) := gc_scope_prefix || 'clob_to_varchar2_table';
  l_varchar2s gc_clob_arr_type;
  l_varchar2 varchar2(4000);
  l_offset number := 1;
  l_amount number := 3000;
  len    number;
  i number := 1;
begin

  ks_log.log('START', l_scope);

  l_varchar2s := gc_clob_arr_type();

  if p_clob is null
  then
    return l_varchar2s;
  end if;

  if ( dbms_lob.isopen(p_clob) != 1 ) then
    dbms_lob.open(p_clob,0);
  end if;

  len := dbms_lob.getlength(p_clob);

  while(l_offset < len)
  loop
    -- ks_log.log('inside main loop "while(l_offset < len)"', l_scope);
    dbms_lob.read(p_clob, l_amount, l_offset, l_varchar2);
    l_offset := l_offset + l_amount;
    l_varchar2s.extend;
    -- ks_log.log('len: ' || len || ', l_offset: ' || l_offset || ', l_varchar2: ' || l_varchar2, 'l_scope');
    l_varchar2s(i) := l_varchar2;
    i := i + 1;
  end loop;

  if ( dbms_lob.isopen(p_clob) = 1 ) then
    dbms_lob.close(p_clob);
  end if;


  return l_varchar2s;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end  clob_to_varchar2_table;


--==============================================================================
-- Function: tokenize_string
-- Purpose: helper function for html_whitelist_tokenize
--
-- Inputs:  p_string - the to have its tokens replaced
--          p_tokens - a string containing the tokens
-- Output:
-- Scope: Publicly accessible
-- Errors: logged and raised.
-- Notes:
-- Author: Ben Shumway (Insum Solutions) - Oct/27/2017
--==============================================================================
function replace_tokens (p_string in varchar2,
                         p_tokens in varchar2,
                         p_token_exceptions in varchar2)
 return varchar2
is
  l_scope varchar2(255) := gc_scope_prefix || 'tokenize_string';

  l_output         varchar2(32767);
  l_tokens_table   apex_application_global.vc_arr2;
  l_tokens         varchar2(4000);
  found_match      boolean := true;
  l_index          number := -1;
  l_regex          varchar2(4000);
  l_infinite_check number := 0;
begin
  -- ks_log.log('BEGIN', l_scope);
  -- ks_log.log(p_tokens, l_scope);

  if trim(p_tokens) is null
  then
    return p_string;
  end if;


  --Cleanse p_tokens so that it only contains alphanumeric characters.
  --Get rid of all non-alphanumerics
  l_tokens := regexp_replace(p_tokens, '[^A-Za-z0-9]', ' ');
  --Remove from tokens the token exceptions
  l_tokens := regexp_replace(l_tokens, p_token_exceptions, '', 1, 0, 'i');
  --Get rid of all multiple spaces so that everything is only one space apart
  l_tokens := regexp_replace(l_tokens, '\s{2,}', ' ');

  l_tokens := trim(l_tokens);
  --Replace spaces with |
  l_tokens := regexp_replace(l_tokens, '\s', '|');

  -- ks_log.log(l_tokens, l_scope);

  --I wanted to use something like the oneliner below, but pl/sql doesn't support lookaheads (yet)
  --l_output := regexp_replace(p_string, '(\W)('|| l_tokens || ')(?=\W)', '\1XXXX', 1, 0, 'i');


  l_regex := '(^|\W)(' || l_tokens || ')(\W|$)';
  --ks_log.log('l_regex:' || l_regex, l_scope);


  l_output := p_string;
  --ks_log.log(l_output, l_scope);

  while(l_index != 0)
  loop

    l_index  := regexp_instr(l_output, l_regex, 1, 1, 0, 'i');

    if(l_index != 0)
    then
      --ks_log.log('Found match at index ' || l_index, l_scope);
      l_output := regexp_replace(l_output, l_regex, '\1💩\3', l_index, 1, 'i');

    end if;

    l_infinite_check := l_infinite_check + 1;
    if l_infinite_check > 9999
    then
      --Something's gone wrong
      raise_application_error(-20001, 'Error Tokenizing Data');
    end if;

  end loop;

  ks_log.log('> ' || l_output, l_scope);

  return l_output;
exception
  when others then
    ks_log.log_error('Unhandled Exception', l_scope);
    raise;
end replace_tokens;
/**
 * Given IR type, determine if there are any filters applied
 * Filters are identified by the precense of the :APXWS_EXPR_n and
 * :APXWS_SEARCH_STRING_n binds
 *
 * @author Jorge Rimblas
 * @created October 11, 2019
 * @param p_ir_t An IR type apex_ir.t_report
 * @return boolean
 */
function ir_has_filters(
    p_ir_t      in apex_ir.t_report
)
  return boolean
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'ir_has_filters';
  -- l_params            logger.tab_param;
  l_bind     apex_plugin_util.t_bind;
  l_index    pls_integer;
  l_found    boolean;
begin
--  logger.log('START', l_scope, null, l_params);

  l_index := p_ir_t.binds.first;
  l_found := false;
  while (l_index is not null and not l_found)
  loop
--    logger.log('p_ir_t.binds(l_index):' || p_ir_t.binds(l_index).name || ':' || p_ir_t.binds(l_index).value, l_scope, null, l_params);
    -- Search for binds named APXWS_EXPR_n
    if  p_ir_t.binds(l_index).name like 'APXWS_EXPR%'
     or p_ir_t.binds(l_index).name like 'APXWS_SEARCH_STRING%' then
      l_found := true;
    end if;
    l_index := p_ir_t.binds.next(l_index);
  end loop;
  return l_found;
exception
    when OTHERS then
--      logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end ir_has_filters;
end ks_util;
/


-- @../plsql/ks_tags_api.plb
-- alter session set PLSQL_CCFLAGS='VERBOSE_OUTPUT:TRUE';
PROMPT ks_tags_api body
create or replace package body ks_tags_api
is
        
--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

---
--- Tag Synchronisation Procedure
---
procedure tag_sync (
    p_new_tags          in varchar2,
    p_old_tags          in varchar2,
    p_content_type      in varchar2,
    p_content_id        in number )
as
    l_scope  ks_log.scope := gc_scope_prefix || 'tag_sync';
  -- l_params logger.tab_param;

    type tags is table of varchar2(255) index by varchar2(255);
    l_new_tags_a    tags;
    l_old_tags_a    tags;
    l_new_tags      apex_application_global.vc_arr2;
    l_old_tags      apex_application_global.vc_arr2;
    l_merge_tags    apex_application_global.vc_arr2;
    l_dummy_tag     varchar2(255);
    i               integer;

begin
  -- we call tag_sync form a trigger, so lets not call logger unless we need to.
  -- logger.append_param(l_params, 'p_option_name', p_option_name);
    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('START', l_scope);
    ks_log.log('p_content_type: ' || p_content_type, l_scope);
    ks_log.log('  p_content_id: ' || p_content_id, l_scope);
    ks_log.log('p_new_tags: ' || p_new_tags, l_scope);
    ks_log.log('p_old_tags: ' || p_old_tags, l_scope);
    $END

    l_old_tags := apex_util.string_to_table(p_old_tags,':');
    l_new_tags := apex_util.string_to_table(p_new_tags,':');
    if l_old_tags.count > 0 then --do inserts and deletes
        --build the associative arrays
        for i in 1..l_old_tags.count loop
            l_old_tags_a(l_old_tags(i)) := l_old_tags(i);
        end loop;
        for i in 1..l_new_tags.count loop
            l_new_tags_a(l_new_tags(i)) := l_new_tags(i);
        end loop;
        --do the inserts
        for i in 1..l_new_tags.count loop
            begin
                l_dummy_tag := l_old_tags_a(l_new_tags(i));
            exception when no_data_found then
                insert into ks_tags (tag, content_id, content_type )
                    values (l_new_tags(i), p_content_id, p_content_type );
                l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
            end;
        end loop;
        --do the deletes
        for i in 1..l_old_tags.count loop
            begin
                l_dummy_tag := l_new_tags_a(l_old_tags(i));
            exception when no_data_found then
                delete from ks_tags where content_id = p_content_id and tag = l_old_tags(i);
                l_merge_tags(l_merge_tags.count + 1) := l_old_tags(i);
            end;
        end loop;
    else --just do inserts
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('insert: ' || l_new_tags.count, l_scope);
        $END
        for i in 1..l_new_tags.count loop
            insert into ks_tags (tag, content_id, content_type )
                values (l_new_tags(i), p_content_id, p_content_type );
            l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
        end loop;
    end if;

    for i in 1..l_merge_tags.count 
    loop
        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('merging(' || i || '): ' || l_merge_tags(i), l_scope);
        ks_log.log('merging ks_tag_type_sums', l_scope);
        $END
        merge into ks_tag_type_sums s
        using (select count(*) tag_count
                 from ks_tags
                where tag = l_merge_tags(i) 
                  and content_type = p_content_type ) t
           on (s.tag = l_merge_tags(i) and s.content_type = p_content_type )
         when not matched then
           insert (tag, content_type, tag_count)
           values (l_merge_tags(i), p_content_type, t.tag_count)
         when matched then
           update set s.tag_count = t.tag_count;


        $IF $$VERBOSE_OUTPUT $THEN
        ks_log.log('merging ks_tag_sums', l_scope);
        $END
        merge into ks_tag_sums s
        using (select sum(tag_count) tag_count
                 from ks_tag_type_sums
                where tag = l_merge_tags(i) ) t
           on (s.tag = l_merge_tags(i) )
         when not matched then
           insert (tag, tag_count)
           values (l_merge_tags(i), t.tag_count)
         when matched then
           update set s.tag_count = t.tag_count;
    end loop;

    $IF $$VERBOSE_OUTPUT $THEN
    ks_log.log('END', l_scope);
    $END

end tag_sync;

/*******************************************************************
 * Maintain the collection elements when using search filters
 *   p_coll: collection_name
 *    p_sub: Optional sub level/area for the tags.
 *     p_id: ID being managed
 * p_status: YES/NO is the element checked (YES) or un-checked (NO)
 *******************************************************************/
procedure maintain_filter_coll(
       p_coll   in varchar2
     , p_sub    in varchar2 := null
     , p_id     in varchar2
     , p_status in varchar2 := 'NO')
is
  l_scope  ks_log.scope := gc_scope_prefix || 'maintain_filter_coll';

  l_seq_id number;
begin

  ks_log.log('START', l_scope);

  /*
  The collections being used:
    SESSIONTAGFILTER: For Session (abstract) filters
  */

  if p_coll in ('SESSIONTAGFILTER') then
    -- is this the top level selection
    if p_id = 'top' then

      -- Because it's the top level, empty the collection
      if apex_collection.collection_exists(p_coll) then
        apex_collection.truncate_collection(p_coll);
      else
        apex_collection.create_collection(p_coll);
      end if;

      -- the collection is already empty, but if the status
      -- is YES then we need to populate ALL of the elmemnts
      if p_status = 'YES' then
        for i in (
          select tag id from ks_tag_type_sums where content_type='SESSION' || nvl2(p_sub, ':' || p_sub, '') and p_coll = 'SESSIONTAGFILTER'
          )
        loop
          apex_collection.add_member(p_coll, p_c001 => i.id);
        end loop;
      end if;

    else
      -- We're dealing with a single element

      -- Create the collection if it doesn't exist.
      if not apex_collection.collection_exists(p_coll) then
          apex_collection.create_collection(p_coll);
      end if;

      -- The element was checked so add it
      if p_status = 'YES' then
          apex_collection.add_member(p_coll, p_c001 => p_id);
      else

        -- the element was unchecked so remove it.
        begin
        select seq_id
          into l_seq_id
          from apex_collections
         where collection_name = p_coll
           and c001 = p_id;

          apex_collection.delete_member(p_coll, l_seq_id);
        exception
        when NO_DATA_FOUND then
          null;
        end;
      end if;

    end if;
  end if;

  ks_log.log('END', l_scope);

end maintain_filter_coll;


end ks_tags_api;
/

-- #43 
-- @../plsql/pretius_apex_nested_reports.pls
create or replace package PRETIUS_APEX_NESTED_REPORTS as

  function pretius_row_details (
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_render_result;

  function pretius_row_details_ajax(
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_ajax_result;

end;
/

-- @../plsql/pretius_apex_nested_reports.plb
create or replace package body "PRETIUS_APEX_NESTED_REPORTS" is

  ------------------------
  function printAttributes(
    p_dynamic_action_render_result in apex_plugin.t_dynamic_action_render_result
  ) return clob is
    
  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_dynamic_action_render_result' );

    apex_json.write( 'javascript_function'  , p_dynamic_action_render_result.javascript_function  );
    apex_json.write( 'ajax_identifier'      , p_dynamic_action_render_result.ajax_identifier  );
    apex_json.write( 'attribute_01'         , p_dynamic_action_render_result.attribute_01 );
    apex_json.write( 'attribute_02'         , p_dynamic_action_render_result.attribute_02 );
    apex_json.write( 'attribute_03'         , p_dynamic_action_render_result.attribute_03 );
    apex_json.write( 'attribute_04'         , p_dynamic_action_render_result.attribute_04 );
    apex_json.write( 'attribute_05'         , p_dynamic_action_render_result.attribute_05 );
    apex_json.write( 'attribute_06'         , p_dynamic_action_render_result.attribute_06 );
    apex_json.write( 'attribute_07'         , p_dynamic_action_render_result.attribute_07 );
    apex_json.write( 'attribute_08'         , p_dynamic_action_render_result.attribute_08 );
    apex_json.write( 'attribute_09'         , p_dynamic_action_render_result.attribute_09 );
    apex_json.write( 'attribute_10'         , p_dynamic_action_render_result.attribute_10 );
    apex_json.write( 'attribute_11'         , p_dynamic_action_render_result.attribute_11 );
    apex_json.write( 'attribute_12'         , p_dynamic_action_render_result.attribute_12 );
    apex_json.write( 'attribute_13'         , p_dynamic_action_render_result.attribute_13 );
    apex_json.write( 'attribute_14'         , p_dynamic_action_render_result.attribute_14 );
    apex_json.write( 'attribute_15'         , p_dynamic_action_render_result.attribute_15 );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;


  ------------------------
  function printAttributes(
    p_plugin in apex_plugin.t_plugin
  ) return clob is
    
  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_plugin' );

    apex_json.write( 'name'        , p_plugin.name         );
    apex_json.write( 'file_prefix' , p_plugin.file_prefix  );
    apex_json.write( 'attribute_01', p_plugin.attribute_01 );
    apex_json.write( 'attribute_02', p_plugin.attribute_02 );
    apex_json.write( 'attribute_03', p_plugin.attribute_03 );
    apex_json.write( 'attribute_04', p_plugin.attribute_04 );
    apex_json.write( 'attribute_05', p_plugin.attribute_05 );
    apex_json.write( 'attribute_06', p_plugin.attribute_06 );
    apex_json.write( 'attribute_07', p_plugin.attribute_07 );
    apex_json.write( 'attribute_08', p_plugin.attribute_08 );
    apex_json.write( 'attribute_09', p_plugin.attribute_09 );
    apex_json.write( 'attribute_10', p_plugin.attribute_10 );
    apex_json.write( 'attribute_11', p_plugin.attribute_11 );
    apex_json.write( 'attribute_12', p_plugin.attribute_12 );
    apex_json.write( 'attribute_13', p_plugin.attribute_13 );
    apex_json.write( 'attribute_14', p_plugin.attribute_14 );
    apex_json.write( 'attribute_15', p_plugin.attribute_15 );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;

  ------------------------
  function printAttributes(
    p_dynamic_action in apex_plugin.t_dynamic_action
  ) return clob is
    
  begin

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'type', 'apex_plugin.t_dynamic_action' );

    apex_json.write( 'id'          , p_dynamic_action.id          , false );
    apex_json.write( 'action'      , p_dynamic_action.action      , false );
    apex_json.write( 'attribute_01', p_dynamic_action.attribute_01, true );
    apex_json.write( 'attribute_02', p_dynamic_action.attribute_02, true );
    apex_json.write( 'attribute_03', p_dynamic_action.attribute_03, true );
    apex_json.write( 'attribute_04', p_dynamic_action.attribute_04, true );
    apex_json.write( 'attribute_05', p_dynamic_action.attribute_05, true );
    apex_json.write( 'attribute_06', p_dynamic_action.attribute_06, true );
    apex_json.write( 'attribute_07', p_dynamic_action.attribute_07, true );
    apex_json.write( 'attribute_08', p_dynamic_action.attribute_08, true );
    apex_json.write( 'attribute_09', p_dynamic_action.attribute_09, true );
    apex_json.write( 'attribute_10', p_dynamic_action.attribute_10, true );
    apex_json.write( 'attribute_11', p_dynamic_action.attribute_11, true );
    apex_json.write( 'attribute_12', p_dynamic_action.attribute_12, true );
    apex_json.write( 'attribute_13', p_dynamic_action.attribute_13, true );
    apex_json.write( 'attribute_14', p_dynamic_action.attribute_14, true );
    apex_json.write( 'attribute_15', p_dynamic_action.attribute_15, true );

    apex_json.close_object;

    return apex_json.get_clob_output;

  end printAttributes;

  --------------------------------
  function getColumnNamesFromQuery(
    p_string in varchar2
  ) return clob is
    v_count   number;
    v_pattern varchar2(50) := '#.+?#';
    
  begin
    apex_json.initialize_clob_output;

    v_count := regexp_count(p_string, v_pattern, 1, 'm');

    apex_json.open_object;
    apex_json.open_array('queryColumns');

    for i in 1..v_count loop
      apex_json.write( trim(both '#' from regexp_substr(p_string, v_pattern, 1, i, 'm') ) );
    end loop;  

    apex_json.close_array;
    apex_json.close_object;

    return apex_json.get_clob_output;
  end;

  -------------------------
  function getBindVariables(
    p_string in varchar2
  ) return clob is
    l_names DBMS_SQL.VARCHAR2_TABLE;
  begin
    l_names := WWV_FLOW_UTILITIES.GET_BINDS( p_string );

    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.open_array('queryItems');

    for i in 1..l_names.count loop
      apex_json.write( trim(both ':' from  l_names(i) ) );
    end loop;  

    apex_json.close_array;
    apex_json.close_object;

    return apex_json.get_clob_output;

  end getBindVariables;

  -------------------------------
  function getPluginAppAttributes(
    p_plugin in apex_plugin.t_plugin
  ) return varchar2 is
    attr_app_expand_time   number  := NVL(p_plugin.attribute_01, 200);
    attr_app_collapse_time number  := NVL(p_plugin.attribute_02, 400);
  begin
    apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.open_object('plugin');
    apex_json.write('animationTime',      attr_app_expand_time   );
    apex_json.write('closeOtherDuration', attr_app_collapse_time );
    apex_json.close_object;
    apex_json.close_object;

    return apex_json.get_clob_output;

  end getPluginAppAttributes;

  ----------------------------
  function pretius_row_details (
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_render_result
  is
    l_result apex_plugin.t_dynamic_action_render_result;

    l_attr_nestedQuery      varchar2(32767) := p_dynamic_action.attribute_01;
    l_attr_dc_settings      varchar2(100)   := p_dynamic_action.attribute_02;

    l_attr_mode             varchar2(100)   := p_dynamic_action.attribute_03;
    l_attr_customTemplate   varchar2(32767) := p_dynamic_action.attribute_04;
    l_attr_customCallback   varchar2(32767) := p_dynamic_action.attribute_05;
    l_attr_bgColor          varchar2(20)    := NVL( p_dynamic_action.attribute_06, '#EBEBEB' );
    l_attr_setMaxHeight     number          := p_dynamic_action.attribute_07;
    l_attr_borderColor      varchar2(20)    := NVL( p_dynamic_action.attribute_08, '#c5c5c5' );
    l_attr_highlightColor   varchar2(20)    := NVL( p_dynamic_action.attribute_09, '#F2F2F2' );
    l_attr_cc_settings      varchar2(100)   := p_dynamic_action.attribute_10;
    l_attr_noDataFound      varchar2(32767) := p_dynamic_action.attribute_11;
    l_attr_spinnerOptions   varchar2(100)   := NVL( p_dynamic_action.attribute_12, 'ATR' );
    l_attr_defaultTemplate  varchar2(4000)  := NVL(p_dynamic_action.attribute_13,  '#DEFAULT_TEMPLATE#');
    l_attr_dt_settings      varchar2(100)   := p_dynamic_action.attribute_14;
    /*
    p_dynamic_action.attribute_12;
    p_dynamic_action.attribute_13;
    p_dynamic_action.attribute_14;
    p_dynamic_action.attribute_15;  
    */
    attr_app_embedMustache boolean := CASE WHEN p_plugin.attribute_03 = 'Y' then true else false end;

  begin
    l_result.ajax_identifier     := wwv_flow_plugin.get_ajax_identifier;
    l_result.javascript_function := '
      function(){
        pretiusNestedReport(this, '||getColumnNamesFromQuery( l_attr_nestedQuery )||', '||getBindVariables( l_attr_nestedQuery )||', true, '||getPluginAppAttributes( p_plugin )||');
      }
    ';
    --l_result.attribute_01        := p_dynamic_action.attribute_01; --tajne, bo to zapytaie SQL, ktore mogloby byc dostepne przez this.options
    l_result.attribute_02        := l_attr_dc_settings;
    l_result.attribute_03        := l_attr_mode;
    l_result.attribute_04        := l_attr_customTemplate;
    l_result.attribute_05        := l_attr_customCallback;
    l_result.attribute_06        := l_attr_bgColor;
    l_result.attribute_07        := l_attr_setMaxHeight;
    l_result.attribute_08        := l_attr_borderColor;
    l_result.attribute_09        := l_attr_highlightColor;
    l_result.attribute_10        := l_attr_cc_settings;
    l_result.attribute_11        := l_attr_noDataFound;
    l_result.attribute_12        := l_attr_spinnerOptions;
    l_result.attribute_13        := l_attr_defaultTemplate;
    l_result.attribute_14        := l_attr_dt_settings;
    --l_result.attribute_15        := p_dynamic_action.attribute_15;

    --add mustache library
    if attr_app_embedMustache then

      apex_javascript.add_library(
        p_name => 'mustache', 
        p_directory => p_plugin.file_prefix, 
        p_version => null 
      );

    end if;

    if apex_application.G_DEBUG then

      APEX_PLUGIN_UTIL.DEBUG_DYNAMIC_ACTION (
        p_plugin         => p_plugin,
        p_dynamic_action => p_dynamic_action
      );

      apex_javascript.add_onload_code ('
        apex.debug.info("p_dynamic_action", '||printAttributes( p_dynamic_action )||');
        apex.debug.info("p_plugin",         '||printAttributes( p_plugin )||');
        apex.debug.info("l_result",         '||printAttributes( l_result )||');
      ');

    end if;

    return l_result;

  end pretius_row_details;

  --------------------
  function clean_query( 
    p_query in varchar2 
  ) return varchar2 is
    l_query varchar2(32767) := p_query;
  begin
    loop
      if substr(l_query,-1) in (chr(10),chr(13),';',' ','/') then
        l_query := substr(l_query,1,length(l_query)-1);
      else
        exit;
      end if;
    end loop;

    return l_query;

  end clean_query;

  -----------------------
  function is_valid_query( 
    p_query in varchar2 
  ) return varchar2 is
    l_source_query  varchar2(32767) := p_query;
    l_source_queryv varchar2(32767);
    l_report_cursor integer;
  begin
    if l_source_query is not null then
      if 
        substr(upper(ltrim(l_source_query)),1,6) != 'SELECT'
        and substr(upper(ltrim(l_source_query)),1,4) != 'WITH' 
      then
        return 'Query must begin with SELECT or WITH';
      end if;
      
      l_source_query := clean_query( l_source_query );
      l_source_queryv := sys.dbms_assert.noop( str => l_source_query );

      begin
        l_report_cursor := sys.dbms_sql.open_cursor;
        sys.dbms_sql.parse( l_report_cursor, l_source_queryv, SYS.DBMS_SQL.NATIVE );
        sys.dbms_sql.close_cursor(l_report_cursor);
      exception 
        when others then
          if sys.dbms_sql.is_open( l_report_cursor ) then
            sys.dbms_sql.close_cursor( l_report_cursor );
          end if;
          return sqlerrm;--||': '||chr(10)||chr(10)||l_source_query;
      end;
    end if;

    return null;
  exception
    when others then
      return SQLERRM;--||':'||chr(10)||chr(10)||p_query;
  end is_valid_query;

  ----------------------------
  function getColumnTypeString(
    p_col_type in number
  ) return varchar2 is 
    l_col_type varchar2(50);
  begin
    if p_col_type = 1 then
      l_col_type := 'VARCHAR2';

    elsif p_col_type = 2 then
      l_col_type := 'NUMBER';

    elsif p_col_type = 12 then
      l_col_type := 'DATE';
        
    elsif p_col_type in (180,181,231) then
      l_col_type := 'TIMESTAMP';

      if p_col_type = 231 then
          l_col_type := 'TIMESTAMP_LTZ';
      end if;

    elsif p_col_type = 112 then
      l_col_type := 'CLOB';

    elsif p_col_type = 113 then

      l_col_type := 'BLOB';

    elsif p_col_type = 96 then
      l_col_type := 'CHAR';

    else
        l_col_type := 'OTHER';
    end if;

    return l_col_type;

  end getColumnTypeString;

  ---------------------------------
  function pretius_row_details_ajax(
    p_dynamic_action in apex_plugin.t_dynamic_action,
    p_plugin         in apex_plugin.t_plugin 
  ) return apex_plugin.t_dynamic_action_ajax_result
  is
    l_status              number;
    l_desc_col_no         number          := 0;

    l_ajax_column_name    varchar2(4000);
    l_ajax_column_values  varchar2(4000);

    l_sql                 varchar2(32767);
    l_delimeter           varchar2(1)     := ':';
    l_parseResult         varchar2(4000);

    l_result              apex_plugin.t_dynamic_action_ajax_result;
    
    l_columnNames         apex_application_global.vc_arr2;
    l_columnValues        apex_application_global.vc_arr2;

    l_sys_cursor          sys_refcursor;

    l_cursor              pls_integer;

    l_desc_col_info       sys.dbms_sql.desc_tab2;

    l_apex_items_names    DBMS_SQL.VARCHAR2_TABLE;
  begin

    l_ajax_column_name    := apex_application.g_x01;
    l_ajax_column_values  := apex_application.g_x02;

    l_sql                 := p_dynamic_action.attribute_01;
    l_apex_items_names    := WWV_FLOW_UTILITIES.GET_BINDS( l_sql );

    l_columnNames         := apex_util.string_to_table( l_ajax_column_name  , l_delimeter );
    l_columnValues        := apex_util.string_to_table( l_ajax_column_values, l_delimeter );
    
    if l_columnNames.count <> l_columnValues.count then
      apex_json.open_object;
      apex_json.write('addInfo', 'The number of column names must be equal to the number of column values.</br>Check whether the query columns exist in parent report.');
      apex_json.write('error', 'Column names = "'||l_ajax_column_name||'"'||chr(10)||'Column values = "'||l_ajax_column_values||'"');
      apex_json.close_object;
      return null;      
    end if;

    --replacing space within column name is required to work with column aliases
    for i in 1..l_columnNames.count loop
      l_sql := replace( l_sql, chr(39)||'#'||l_columnNames(i)||'#'||chr(39) , ':' || replace(l_columnNames(i), ' ', '') );  
      l_sql := replace( l_sql, '#'||l_columnNames(i)||'#'                   , ':' || replace(l_columnNames(i), ' ', '') );  
    end loop;

    l_parseResult := is_valid_query( l_sql );

    if l_parseResult is not null then
      apex_json.open_object;
      apex_json.write('addInfo', 'Nested report SQL query is not valid');
      apex_json.write('error', l_parseResult);
      --apex_json.write('query', l_sql);
      apex_json.close_object;
      return null;
    end if;

    -- open l_cursor;
    l_cursor := dbms_sql.open_cursor;
    dbms_sql.parse (l_cursor, l_sql, dbms_sql.native);

    -- bind items
    begin

      for i in 1..l_apex_items_names.count loop
        dbms_sql.bind_variable (l_cursor, l_apex_items_names(i), v( trim(both ':' from l_apex_items_names(i)) ) );
      end loop;

    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While binding APEX items error occured');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    --bind all the values
    --replacing space within column name is required to work with column aliases
    begin
      for i in 1 .. l_columnNames.count loop
        dbms_sql.bind_variable (l_cursor, replace(l_columnNames(i), ' ', ''), l_columnValues(i));
      end loop;
    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While binding query variables error occured');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    -- describe columns
    sys.dbms_sql.describe_columns2( l_cursor, l_desc_col_no , l_desc_col_info);

    begin
      l_status := dbms_sql.execute(l_cursor);
    exception
      when others then
        apex_json.open_object;
        apex_json.write('addInfo', 'While executing query error occured ');
        apex_json.write('error', SQLERRM);
        apex_json.close_object;
        return null;      
    end;

    l_sys_cursor := dbms_sql.to_refcursor(l_cursor);  

    --apex_json.initialize_clob_output;

    apex_json.open_object;
    apex_json.write( 'data', l_sys_cursor );
    apex_json.open_array('headers');

    for i in 1..l_desc_col_no loop
      apex_json.open_object;
      apex_json.write('COLUMN_NAME', l_desc_col_info(i).col_name);
      apex_json.write('COLUMN_TYPE', getColumnTypeString( l_desc_col_info(i).col_type ) );
      apex_json.close_object;
    end loop;
    
    apex_json.close_array;
    
    apex_json.write( 'x01', l_ajax_column_name, true );
    apex_json.write( 'x02', l_ajax_column_values, true );

    apex_json.close_object;

    --htp.p( apex_json.get_clob_output );

    return l_result;
  exception
    when others then
      apex_json.open_object;
      apex_json.write('addInfo', 'Unknown ajax error');
      apex_json.write('error', SQLERRM);
      apex_json.close_object;
      htp.p( apex_json.get_clob_output );
      return l_result;
  end pretius_row_details_ajax;
  
end "PRETIUS_APEX_NESTED_REPORTS";
/


-- #43 
-- @../plsql/ks_plugins.pls
create or replace package ks_plugins
is


--------------------------------------------------------------------------------
--*
--* Save application plugins code
--*
--------------------------------------------------------------------------------

subtype gt_string is varchar2(32767);

--------------------------------------------------------------------------------
FUNCTION built_with_love_render_region(p_region              IN apex_plugin.t_region,
                       p_plugin              IN apex_plugin.t_plugin,
                       p_is_printer_friendly IN BOOLEAN)
  RETURN apex_plugin.t_region_render_result;

--------------------------------------------------------------------------------
function select2_render(
           p_item in apex_plugin.t_page_item,
           p_plugin in apex_plugin.t_plugin,
           p_value in gt_string,
           p_is_readonly in boolean,
           p_is_printer_friendly in boolean
         ) 
  return apex_plugin.t_page_item_render_result;

function select2_ajax(
           p_item in apex_plugin.t_page_item,
           p_plugin in apex_plugin.t_plugin
         ) 
  return apex_plugin.t_page_item_ajax_result;

--------------------------------------------------------------------------------
function render_simple_checkbox (
    p_item                in apex_plugin.t_page_item,
    p_plugin              in apex_plugin.t_plugin,
    p_value               in varchar2,
    p_is_readonly         in boolean,
    p_is_printer_friendly in boolean )
    return apex_plugin.t_page_item_render_result;

function validate_simple_checkbox (
    p_item   in apex_plugin.t_page_item,
    p_plugin in apex_plugin.t_plugin,
    p_value  in varchar2
)
return apex_plugin.t_page_item_validation_result;


--------------------------------------------------------------------------------
FUNCTION render_apexspotlight(p_dynamic_action IN apex_plugin.t_dynamic_action,
                              p_plugin         IN apex_plugin.t_plugin)
  RETURN apex_plugin.t_dynamic_action_render_result;

FUNCTION ajax_apexspotlight(p_dynamic_action IN apex_plugin.t_dynamic_action,
                            p_plugin         IN apex_plugin.t_plugin)
  RETURN apex_plugin.t_dynamic_action_ajax_result;


end ks_plugins;
/
-- @../plsql/ks_plugins.plb
set define off
create or replace package body ks_plugins
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';


gco_min_lov_cols constant number(1) := 2;
gco_max_lov_cols constant number(1) := 3;
gco_lov_display_col constant number(1) := 1;
gco_lov_return_col constant number(1) := 2;
gco_lov_group_col constant number(1) := 3;
gco_contains_ignore_case constant char(3) := 'CIC';
gco_contains_ignore_case_diac constant char(4) := 'CICD';
gco_contains_case_sensitive constant char(3) := 'CCS';
gco_exact_ignore_case constant char(3) := 'EIC';
gco_exact_case_sensitive constant char(3) := 'ECS';
gco_starts_with_ignore_case constant char(3) := 'SIC';
gco_starts_with_case_sensitive constant char(3) := 'SCS';
gco_multi_word constant char(2) := 'MW';


------------------------------------------------------------------------------

-- ========================================
-- Built with love
-- ========================================
FUNCTION built_with_love_render_region(p_region              IN apex_plugin.t_region,
                       p_plugin              IN apex_plugin.t_plugin,
                       p_is_printer_friendly IN BOOLEAN)
  RETURN apex_plugin.t_region_render_result
IS
  -- plugin attributes
  l_result apex_plugin.t_region_render_result;
  -- other vars
  l_region_id VARCHAR2(200);
  --
BEGIN
  -- Debug
  IF apex_application.g_debug THEN
    apex_plugin_util.debug_region(p_plugin => p_plugin,
                                  p_region => p_region);
  END IF;
  -- set vars
  l_region_id := apex_escape.html_attribute(p_region.static_id ||
                                            '_orclapex_builtwithlove');
  --
  -- write region html
  sys.htp.p('<div id="' || l_region_id || '">' ||
            '<span class="footer-apex">Built with <span class="fa fa-heart"><span class="u-VisuallyHidden">love</span></span> ' ||
            'using <a href="https://apex.oracle.com/" target="_blank" title="Oracle Application Express">Oracle APEX</a> ' ||
            'by <a href="https://insum.ca/" target="_blank" title="Insum Solutions">Insum Solutions</a>' ||
            '</span>' ||
            '</div>');
  --
  RETURN l_result;
  --
END built_with_love_render_region;


-- ========================================
-- Select2
-- ========================================




procedure print_lov_options(
            p_item in apex_plugin.t_page_item,
            p_plugin in apex_plugin.t_plugin,
            p_value in gt_string default null
          ) is
  l_null_optgroup_label_app gt_string := p_plugin.attribute_05;
  l_select_list_type gt_string := p_item.attribute_01;
  l_null_optgroup_label_cmp gt_string := p_item.attribute_09;
  l_drag_and_drop_sorting gt_string := p_item.attribute_11;
  l_lazy_loading gt_string := p_item.attribute_14;

  lco_null_optgroup_label constant gt_string := 'Ungrouped';

  l_lov apex_plugin_util.t_column_value_list;
  l_null_optgroup gt_string;
  l_tmp_optgroup gt_string;
  l_selected_values apex_application_global.vc_arr2;
  l_display_value gt_string;

  type gt_optgroups
    is table of gt_string
    index by pls_integer;
  laa_optgroups gt_optgroups;

  -- local subprograms
  function optgroup_exists(
             p_optgroups in gt_optgroups,
             p_optgroup in gt_string
           ) return boolean is
    l_index pls_integer := p_optgroups.first;
  begin
    while (l_index is not null) loop
      if p_optgroups(l_index) = p_optgroup then
        return true;
      end if;

      l_index := p_optgroups.next(l_index);
    end loop;

    return false;
  end optgroup_exists;


  function is_selected_value(
             p_value in gt_string,
             p_selected_values in gt_string
           ) return boolean is
    l_selected_values apex_application_global.vc_arr2;
  begin
    l_selected_values := apex_util.string_to_table(p_selected_values);

    for i in 1 .. l_selected_values.count loop
      if apex_plugin_util.is_equal(p_value, l_selected_values(i)) then
        return true;
      end if;
    end loop;

    return false;
  end is_selected_value;
begin
  l_lov := apex_plugin_util.get_data(
             p_sql_statement  => p_item.lov_definition,
             p_min_columns => gco_min_lov_cols,
             p_max_columns => gco_max_lov_cols,
             p_component_name => p_item.name
           );

  -- print the selected LOV options in case of lazy loading or when drag and drop sorting is enabled
  if (l_lazy_loading is not null or l_drag_and_drop_sorting is not null) then
    if p_value is not null then
      l_selected_values := apex_util.string_to_table(p_value);

      for i in 1 .. l_selected_values.count loop
        begin
          l_display_value := apex_plugin_util.get_display_data(
                               p_sql_statement => p_item.lov_definition,
                               p_min_columns => gco_min_lov_cols,
                               p_max_columns => gco_max_lov_cols,
                               p_component_name => p_item.name,
                               p_display_column_no => gco_lov_display_col,
                               p_search_column_no => gco_lov_return_col,
                               p_search_string => l_selected_values(i),
                               p_display_extra => false
                             );
        exception
          when no_data_found then
            l_display_value := null;
        end;

        if not (l_display_value is null and not p_item.lov_display_extra) then
          -- print the display value, or return value if no display value was found
          apex_plugin_util.print_option(
            p_display_value => nvl(l_display_value, l_selected_values(i)),
            p_return_value => l_selected_values(i),
            p_is_selected => true,
            p_attributes => p_item.element_option_attributes,
            p_escape => p_item.escape_output
          );
        end if;
      end loop;
    end if;
  end if;

  if l_lazy_loading is null then
    if l_lov.exists(gco_lov_group_col) then
      if l_null_optgroup_label_cmp is not null then
        l_null_optgroup := l_null_optgroup_label_cmp;
      else
        l_null_optgroup := nvl(l_null_optgroup_label_app, lco_null_optgroup_label);
      end if;

      for i in 1 .. l_lov(gco_lov_display_col).count loop
        l_tmp_optgroup := nvl(l_lov(gco_lov_group_col)(i), l_null_optgroup);

        if not optgroup_exists(laa_optgroups, l_tmp_optgroup) then
          htp.p('<optgroup label="' || l_tmp_optgroup || '">');
          for j in 1 .. l_lov(gco_lov_display_col).count loop
            if nvl(l_lov(gco_lov_group_col)(j), l_null_optgroup) = l_tmp_optgroup then
              apex_plugin_util.print_option(
                p_display_value => l_lov(gco_lov_display_col)(j),
                p_return_value => l_lov(gco_lov_return_col)(j),
                p_is_selected => is_selected_value(l_lov(gco_lov_return_col)(j), p_value),
                p_attributes => p_item.element_option_attributes,
                p_escape => p_item.escape_output
              );
            end if;
          end loop;
          htp.p('</optgroup>');

          laa_optgroups(i) := l_tmp_optgroup;
        end if;
      end loop;
    else
      if (l_drag_and_drop_sorting is not null and p_value is not null) then
        for i in 1 .. l_lov(gco_lov_display_col).count loop
          if not is_selected_value(l_lov(gco_lov_return_col)(i), p_value) then
            apex_plugin_util.print_option(
              p_display_value => l_lov(gco_lov_display_col)(i),
              p_return_value => l_lov(gco_lov_return_col)(i),
              p_is_selected => false,
              p_attributes => p_item.element_option_attributes,
              p_escape => p_item.escape_output
            );
          end if;
        end loop;
      else
        for i in 1 .. l_lov(gco_lov_display_col).count loop
          apex_plugin_util.print_option(
            p_display_value => l_lov(gco_lov_display_col)(i),
            p_return_value => l_lov(gco_lov_return_col)(i),
            p_is_selected => is_selected_value(l_lov(gco_lov_return_col)(i), p_value),
            p_attributes => p_item.element_option_attributes,
            p_escape => p_item.escape_output
          );
        end loop;
      end if;
    end if;
  end if;

  if (p_value is not null and (l_select_list_type = 'TAG' or p_item.lov_display_extra)) then
    if not (l_lazy_loading is not null or l_drag_and_drop_sorting is not null) then
      l_selected_values := apex_util.string_to_table(p_value);

      for i in 1 .. l_selected_values.count loop
        begin
          l_display_value := apex_plugin_util.get_display_data(
                               p_sql_statement => p_item.lov_definition,
                               p_min_columns => gco_min_lov_cols,
                               p_max_columns => gco_max_lov_cols,
                               p_component_name => p_item.name,
                               p_display_column_no => gco_lov_display_col,
                               p_search_column_no => gco_lov_return_col,
                               p_search_string => l_selected_values(i),
                               p_display_extra => false
                             );
        exception
          when no_data_found then
            l_display_value := null;
        end;

        if l_display_value is null then
          apex_plugin_util.print_option(
            p_display_value => l_selected_values(i),
            p_return_value => l_selected_values(i),
            p_is_selected => true,
            p_attributes => p_item.element_option_attributes,
            p_escape => p_item.escape_output
          );
        end if;
      end loop;
    end if;
  end if;
end print_lov_options;


function select2_render(
           p_item in apex_plugin.t_page_item,
           p_plugin in apex_plugin.t_plugin,
           p_value in gt_string,
           p_is_readonly in boolean,
           p_is_printer_friendly in boolean
         ) return apex_plugin.t_page_item_render_result is
  l_no_matches_msg gt_string := p_plugin.attribute_01;
  l_input_too_short_msg gt_string := p_plugin.attribute_02;
  l_selection_too_big_msg gt_string := p_plugin.attribute_03;
  l_searching_msg gt_string := p_plugin.attribute_04;
  l_null_optgroup_label_app gt_string := p_plugin.attribute_05;
  l_loading_more_results_msg gt_string := p_plugin.attribute_06;
  l_look_and_feel gt_string := p_plugin.attribute_07;
  l_error_loading_msg gt_string := p_plugin.attribute_08;
  l_input_too_long_msg gt_string := p_plugin.attribute_09;
  l_custom_css_path gt_string := p_plugin.attribute_10;
  l_custom_css_filename gt_string := p_plugin.attribute_11;

  l_select_list_type gt_string := p_item.attribute_01;
  l_min_results_for_search gt_string := p_item.attribute_02;
  l_min_input_length gt_string := p_item.attribute_03;
  l_max_input_length gt_string := p_item.attribute_04;
  l_max_selection_size gt_string := p_item.attribute_05;
  l_rapid_selection gt_string := p_item.attribute_06;
  l_select_on_blur gt_string := p_item.attribute_07;
  l_search_logic gt_string := p_item.attribute_08;
  l_null_optgroup_label_cmp gt_string := p_item.attribute_09;
  l_width gt_string := p_item.attribute_10;
  l_drag_and_drop_sorting gt_string := p_item.attribute_11;
  l_token_separators gt_string := p_item.attribute_12;
  l_extra_options gt_string := p_item.attribute_13;
  l_lazy_loading gt_string := p_item.attribute_14;
  l_lazy_append_row_count gt_string := p_item.attribute_15;

  l_display_values apex_application_global.vc_arr2;
  l_multiselect gt_string;

  l_item_jq gt_string := apex_plugin_util.page_item_names_to_jquery(p_item.name);
  l_cascade_parent_items_jq gt_string := apex_plugin_util.page_item_names_to_jquery(p_item.lov_cascade_parent_items);
  l_cascade_items_to_submit_jq gt_string := apex_plugin_util.page_item_names_to_jquery(p_item.ajax_items_to_submit);
  l_items_for_session_state_jq gt_string;
  l_cascade_parent_items apex_application_global.vc_arr2;
  l_optimize_refresh_condition gt_string;

  l_apex_version gt_string;
  l_onload_code gt_string;
  l_render_result apex_plugin.t_page_item_render_result;

  -- local subprograms
  function get_select2_constructor
  return gt_string is
    l_selected_values apex_application_global.vc_arr2;
    l_display_values apex_application_global.vc_arr2;
    l_json gt_string;
    l_code gt_string;

    l_allow_clear_bool boolean;
    l_rapid_selection_bool boolean;
    l_select_on_blur_bool boolean;
  begin
    if p_item.lov_display_null then
      l_allow_clear_bool := true;
    else
      l_allow_clear_bool := false;
    end if;

    if l_rapid_selection is null then
      l_rapid_selection_bool := true;
    else
      l_rapid_selection_bool := false;
    end if;

    if l_select_on_blur is null then
      l_select_on_blur_bool := false;
    else
      l_select_on_blur_bool := true;
    end if;

    -- make sure the last character of l_extra_options is a comma
    if trim(l_extra_options) is not null then
      if substr(trim(l_extra_options), -1, 1) != ',' then
        l_extra_options := l_extra_options || ',';
      end if;
    end if;

    l_code := '
      $("' || l_item_jq || '").select2({' ||
        apex_javascript.add_attribute('placeholder', p_item.lov_null_text, false) ||
        apex_javascript.add_attribute('allowClear', l_allow_clear_bool) ||
        apex_javascript.add_attribute('minimumInputLength', to_number(l_min_input_length)) ||
        apex_javascript.add_attribute('maximumInputLength', to_number(l_max_input_length)) ||
        apex_javascript.add_attribute('minimumResultsForSearch', to_number(l_min_results_for_search)) ||
        apex_javascript.add_attribute('maximumSelectionLength', to_number(l_max_selection_size)) ||
        apex_javascript.add_attribute('closeOnSelect', l_rapid_selection_bool) ||
        apex_javascript.add_attribute('selectOnClose', l_select_on_blur_bool) ||
        apex_javascript.add_attribute('tokenSeparators', l_token_separators) ||
        l_extra_options;

    if l_look_and_feel = 'SELECT2_CLASSIC' then
      l_code := l_code || apex_javascript.add_attribute('theme', 'classic');
    end if;

    l_code := l_code || '"language": {';

    if l_error_loading_msg is not null then
      l_code := l_code || '
        "errorLoading": function() {
                          return "' || l_error_loading_msg || '";
                        },';
    end if;
    if l_input_too_long_msg is not null then
      l_code := l_code || '
        "inputTooLong": function(args) {
                          var msg = "' || l_input_too_long_msg || '";
                          msg = msg.replace("#TERM#", args.input);
                          msg = msg.replace("#MAXLENGTH#", args.maximum);
                          msg = msg.replace("#OVERCHARS#", args.input.length - args.maximum);
                          return msg;
                        },';
    end if;
    if l_input_too_short_msg is not null then
      l_code := l_code || '
        "inputTooShort": function(args) {
                           var msg = "' || l_input_too_short_msg || '";
                           msg = msg.replace("#TERM#", args.input);
                           msg = msg.replace("#MINLENGTH#", args.minimum);
                           msg = msg.replace("#REMAININGCHARS#", args.minimum - args.input.length);
                           return msg;
                         },';
    end if;
    if l_loading_more_results_msg is not null then
      l_code := l_code || '
        "loadingMore": function() {
                         return "' || l_loading_more_results_msg || '";
                       },';
    end if;
    if l_selection_too_big_msg is not null then
      l_code := l_code || '
        "maximumSelected": function(args) {
                             var msg = "' || l_selection_too_big_msg || '";
                             msg = msg.replace("#MAXSIZE#", args.maximum);
                             return msg;
                           },';
    end if;
    if l_no_matches_msg is not null then
      l_code := l_code || '
        "noResults": function() {
                       return "' || l_no_matches_msg || '";
                     },';
    end if;
    if l_searching_msg is not null then
      l_code := l_code || '
        "searching": function() {
                       return "' || l_searching_msg || '";
                     },';
    end if;

    l_code := rtrim(l_code, ',') || '},';

    if l_search_logic != gco_contains_ignore_case then
      case l_search_logic
        when gco_contains_ignore_case_diac then l_search_logic := 'return text.toUpperCase().indexOf(term.toUpperCase()) >= 0;';
        when gco_contains_case_sensitive then l_search_logic := 'return text.indexOf(term) >= 0;';
        when gco_exact_ignore_case then l_search_logic := 'return text.toUpperCase() === term.toUpperCase() || term.length === 0;';
        when gco_exact_case_sensitive then l_search_logic := 'return text === term || term.length === 0;';
        when gco_starts_with_ignore_case then l_search_logic := 'return text.toUpperCase().indexOf(term.toUpperCase()) === 0;';
        when gco_starts_with_case_sensitive then l_search_logic := 'return text.indexOf(term) === 0;';
        when gco_multi_word then l_search_logic := '
          var escpTerm = term.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          return new RegExp(escpTerm.replace(/ /g, ".*"), "i").test(text);';
        else l_search_logic := 'return text.toUpperCase().indexOf(term.toUpperCase()) >= 0;';
      end case;

      l_code := '$.fn.select2.amd.require([''select2/compat/matcher''], function(oldMatcher) {' ||
        l_code || '
        matcher: oldMatcher(
                   function(term, text) {
                     ' || l_search_logic || '
                   }
                 ),';
    end if;

    if l_lazy_loading is not null then
      l_code := l_code || '
        ajax: {
          url: "wwv_flow.show",
          type: "POST",
          dataType: "json",
          delay: 400,
          data: function(params) {
                  return {
                    p_flow_id: $("#pFlowId").val(),
                    p_flow_step_id: $("#pFlowStepId").val(),
                    p_instance: $("#pInstance").val(),
                    x01: params.term,
                    x02: params.page,
                    x03: "LAZY_LOAD",
                    p_request: "PLUGIN=' || apex_plugin.get_ajax_identifier || '"
                  };
                },
          processResults: function(data, params) {
                            var select2Data = $.map(data.row, function(obj) {
                              obj.id = obj.R;
                              obj.text = obj.D;
                              return obj;
                            });

                            return {
                              results: select2Data,
                              pagination: { more: data.more }
                            };
                          },
          cache: true
        },
        escapeMarkup: function(markup) { return markup; },';
    end if;

    if l_select_list_type = 'TAG' then
      l_code := l_code || apex_javascript.add_attribute('tags', true);
    end if;

    l_code := l_code || apex_javascript.add_attribute('width', nvl(l_width, 'element'), true, false);
    l_code := l_code || '})';

    if l_search_logic != gco_contains_ignore_case then
      l_code := l_code || '});';
    else
      l_code := l_code || ';';
    end if;

    -- issue #71: fix focus after selection for single-value items
    if l_select_list_type = 'SINGLE' then
      l_code := l_code || '
        $("' || l_item_jq || '").on(
          "select2:select",
          function(){ $(this).focus(); }
        );';
    end if;

    return l_code;
  end get_select2_constructor;


  function get_sortable_constructor
  return gt_string is
    l_code gt_string;
  begin
    l_code := '
      var s2item = $("' || l_item_jq || '");
      var s2ul = s2item.next(".select2-container").find("ul.select2-selection__rendered");
      s2ul.sortable({
        containment: "parent",
        items: "li:not(.select2-search)",
        tolerance: "pointer",
        stop: function() {
          $(s2ul.find(".select2-selection__choice").get().reverse()).each(function() {
            s2item.prepend(s2item.find(''option[value="'' + $(this).data("data").id + ''"]'')[0]);
          });
        }
      });';

      /* prevent automatic tags sorting
         http://stackoverflow.com/questions/31431197/select2-how-to-prevent-tags-sorting
      s2item.on("select2:select", function(e) {
        var $element = $(e.params.data.element);

        $element.detach();
        $(this).append($element);
        $(this).trigger("change");
      });';
      */

    return l_code;
  end get_sortable_constructor;
begin
  if apex_application.g_debug then
    apex_plugin_util.debug_page_item(p_plugin, p_item, p_value, p_is_readonly, p_is_printer_friendly);
  end if;

  if (p_is_readonly or p_is_printer_friendly) then
    apex_plugin_util.print_hidden_if_readonly(p_item.name, p_value, p_is_readonly, p_is_printer_friendly);

    begin
      l_display_values := apex_plugin_util.get_display_data(
                            p_sql_statement => p_item.lov_definition,
                            p_min_columns => gco_min_lov_cols,
                            p_max_columns => gco_max_lov_cols,
                            p_component_name => p_item.name,
                            p_search_value_list => apex_util.string_to_table(p_value),
                            p_display_extra => p_item.lov_display_extra
                          );
    exception
      when no_data_found then
        null; -- https://github.com/nbuytaert1/apex-select2/issues/51
    end;

    if l_display_values.count = 1 then
      apex_plugin_util.print_display_only(
        p_item_name => p_item.name,
        p_display_value => l_display_values(1),
        p_show_line_breaks => false,
        p_escape => p_item.escape_output,
        p_attributes => p_item.element_attributes
      );
    elsif l_display_values.count > 1 then
      htp.p('
        <ul id="' || p_item.name || '_DISPLAY"
          class="display_only ' || p_item.element_css_classes || '"' ||
          p_item.element_attributes || '>');

      for i in 1 .. l_display_values.count loop
        if p_item.escape_output then
          htp.p('<li>' || htf.escape_sc(l_display_values(i)) || '</li>');
        else
          htp.p('<li>' || l_display_values(i) || '</li>');
        end if;
      end loop;

      htp.p('</ul>');
    end if;

    return l_render_result;
  end if;

  apex_javascript.add_library(
    p_name => 'select2.full.min',
    p_directory => p_plugin.file_prefix,
    p_version => null
  );
  apex_javascript.add_library(
    p_name => 'select2-apex',
    p_directory => p_plugin.file_prefix,
    p_version => null
  );
  apex_css.add_file(
    p_name => 'select2.min',
    p_directory => p_plugin.file_prefix,
    p_version => null
  );
  if l_look_and_feel = 'SELECT2_CLASSIC' then
    apex_css.add_file(
      p_name => 'select2-classic',
      p_directory => p_plugin.file_prefix,
      p_version => null
    );
  elsif l_look_and_feel = 'CUSTOM' then
    apex_css.add_file(
      p_name => apex_plugin_util.replace_substitutions(l_custom_css_filename),
      p_directory => apex_plugin_util.replace_substitutions(l_custom_css_path),
      p_version => null
    );
  end if;

  if l_select_list_type in ('MULTI', 'TAG') then
    l_multiselect := 'multiple="multiple"';
  end if;

  htp.p('
    <select ' || l_multiselect || '
      id="' || p_item.name || '"
      name="' || apex_plugin.get_input_name_for_page_item(true) || '"
      class="selectlist ' || p_item.element_css_classes || '"' ||
      p_item.element_attributes || '>');

  if (l_select_list_type = 'SINGLE' and p_item.lov_display_null) then
    apex_plugin_util.print_option(
      p_display_value => p_item.lov_null_text,
      p_return_value => p_item.lov_null_value,
      p_is_selected => false,
      p_attributes => p_item.element_option_attributes,
      p_escape => p_item.escape_output
    );
  end if;

  print_lov_options(p_item, p_plugin, p_value);

  htp.p('</select>');

  l_onload_code := get_select2_constructor;

  if l_drag_and_drop_sorting is not null then
    select substr(version_no, 1, 3)
    into l_apex_version
    from apex_release;

    if l_apex_version = '4.2' then
      apex_javascript.add_library(
        p_name => 'jquery.ui.sortable.min',
        p_directory => '#JQUERYUI_DIRECTORY#ui/minified/',
        p_version => null
      );
    else
      apex_javascript.add_library(
        p_name => 'jquery.ui.sortable.min',
        p_directory => '#IMAGE_PREFIX#libraries/jquery-ui/1.10.4/ui/minified/',
        p_version => null
      );
    end if;

    l_onload_code := l_onload_code || get_sortable_constructor();
  end if;

  if p_item.lov_cascade_parent_items is not null then
    l_items_for_session_state_jq := l_cascade_parent_items_jq;

    if l_cascade_items_to_submit_jq is not null then
      l_items_for_session_state_jq := l_items_for_session_state_jq || ',' || l_cascade_items_to_submit_jq;
    end if;

    l_onload_code := l_onload_code || '
      $("' || l_cascade_parent_items_jq || '").on("change", function(e) {';

    if p_item.ajax_optimize_refresh then
      l_cascade_parent_items := apex_util.string_to_table(l_cascade_parent_items_jq, ',');

      l_optimize_refresh_condition := '$("' || l_cascade_parent_items(1) || '").val() === ""';

      for i in 2 .. l_cascade_parent_items.count loop
        l_optimize_refresh_condition := l_optimize_refresh_condition || ' || $("' || l_cascade_parent_items(i) || '").val() === ""';
      end loop;

      l_onload_code := l_onload_code || '
        var item = $("' || l_item_jq || '");
        if (' || l_optimize_refresh_condition || ') {
          item.val("").trigger("change");
        } else {';
    end if;

    l_onload_code := l_onload_code || '
          apex.server.plugin(
            "' || apex_plugin.get_ajax_identifier || '",
            { pageItems: "' || l_items_for_session_state_jq || '" },
            { refreshObject: "' || l_item_jq || '",
              loadingIndicator: "' || l_item_jq || '",
              loadingIndicatorPosition: "after",
              dataType: "text",
              success: function(pData) {
                         var item = $("' || l_item_jq || '");
                         item.html(pData);
                         item.val("").trigger("change");
                       }
            });';

    if p_item.ajax_optimize_refresh then
      l_onload_code := l_onload_code || '}';
    end if;

    l_onload_code := l_onload_code || '});';
  end if;

  l_onload_code := l_onload_code || '
      beCtbSelect2.events.bind("' || l_item_jq || '");';

  apex_javascript.add_onload_code(l_onload_code);
  l_render_result.is_navigable := true;
  return l_render_result;
end select2_render;


function select2_ajax(
           p_item in apex_plugin.t_page_item,
           p_plugin in apex_plugin.t_plugin
         ) return apex_plugin.t_page_item_ajax_result is
  l_select_list_type gt_string := p_item.attribute_01;
  l_search_logic gt_string := p_item.attribute_08;
  l_lazy_append_row_count gt_string := p_item.attribute_15;

  l_lov apex_plugin_util.t_column_value_list;
  l_json gt_string;
  l_apex_plugin_search_logic gt_string;
  l_search_string gt_string;
  l_search_page number;
  l_first_row number;
  l_loop_count number;
  l_more_rows_boolean boolean;

  l_result apex_plugin.t_page_item_ajax_result;
begin
  if apex_application.g_x03 = 'LAZY_LOAD' then
    l_search_string := nvl(apex_application.g_x01, '%');
    l_search_page := nvl(apex_application.g_x02, 1);
    l_first_row := ((l_search_page - 1) * nvl(l_lazy_append_row_count, 0)) + 1;

    -- translate Select2 search logic into APEX_PLUGIN_UTIL search logic
    -- the percentage wildcard returns all rows whenever the search string is null
    case l_search_logic
      when gco_contains_case_sensitive then
        l_apex_plugin_search_logic := apex_plugin_util.c_search_like_case; -- uses LIKE %value%
      when gco_exact_ignore_case then
        l_apex_plugin_search_logic := apex_plugin_util.c_search_exact_ignore; -- uses LIKE VALUE% with UPPER (not completely correct)
      when gco_exact_case_sensitive then
        l_apex_plugin_search_logic := apex_plugin_util.c_search_lookup; -- uses = value
      when gco_starts_with_ignore_case then
        l_apex_plugin_search_logic := apex_plugin_util.c_search_exact_ignore; -- uses LIKE VALUE% with UPPER
      when gco_starts_with_case_sensitive then
        l_apex_plugin_search_logic := apex_plugin_util.c_search_exact_case; -- uses LIKE value%
      else
        l_apex_plugin_search_logic := apex_plugin_util.c_search_like_ignore; -- uses LIKE %VALUE% with UPPER
    end case;

    if l_search_logic = gco_multi_word then
      l_search_string := replace(l_search_string, ' ', '%');
    end if;

    l_lov := apex_plugin_util.get_data(
               p_sql_statement => p_item.lov_definition,
               p_min_columns => gco_min_lov_cols,
               p_max_columns => gco_max_lov_cols,
               p_component_name => p_item.name,
               p_search_type => l_apex_plugin_search_logic,
               p_search_column_no => gco_lov_display_col,
               p_search_string => apex_plugin_util.get_search_string(
                                    p_search_type => l_apex_plugin_search_logic,
                                    p_search_string => l_search_string
                                  ),
               p_first_row => l_first_row,
               p_max_rows => l_lazy_append_row_count + 1
             );

    if l_lov(gco_lov_return_col).count = l_lazy_append_row_count + 1 then
      l_loop_count := l_lov(gco_lov_return_col).count - 1;
    else
      l_loop_count := l_lov(gco_lov_return_col).count;
    end if;

    l_json := '{"row":[';

    if p_item.escape_output then
      for i in 1 .. l_loop_count loop
        l_json := l_json || '{' ||
          apex_javascript.add_attribute('R', htf.escape_sc(l_lov(gco_lov_return_col)(i)), false, true) ||
          apex_javascript.add_attribute('D', htf.escape_sc(l_lov(gco_lov_display_col)(i)), false, false) ||
        '},';
      end loop;
    else
      for i in 1 .. l_loop_count loop
        l_json := l_json || '{' ||
          apex_javascript.add_attribute('R', l_lov(gco_lov_return_col)(i), false, true) ||
          apex_javascript.add_attribute('D', l_lov(gco_lov_display_col)(i), false, false) ||
        '},';
      end loop;
    end if;

    l_json := rtrim(l_json, ',');

    if l_lov(gco_lov_return_col).exists(l_lazy_append_row_count + 1) then
      l_more_rows_boolean := true;
    else
      l_more_rows_boolean := false;
    end if;

    l_json := l_json || '],' || apex_javascript.add_attribute('more', l_more_rows_boolean, true, false) || '}';

    htp.p(l_json);
  else
    print_lov_options(p_item, p_plugin);
  end if;

  return l_result;
end select2_ajax;




-- ========================================
--  Simple Checkbox
-- ========================================
/**
 *
 * Renders the Simple Checkbox item type based on the configuration of the page item.
 *
 * @param p_item
 * @param p_plugin
 * @param p_value
 * @param p_is_readonly
 * @param p_is_printer_friendly
 *
 */
function render_simple_checkbox (
    p_item                in apex_plugin.t_page_item,
    p_plugin              in apex_plugin.t_plugin,
    p_value               in varchar2,
    p_is_readonly         in boolean,
    p_is_printer_friendly in boolean )
    return apex_plugin.t_page_item_render_result
is
    -- Use named variables instead of the generic attribute variables
    l_checked_value    varchar2(255)  := nvl(p_item.attribute_01, 'Y');
    l_unchecked_value  varchar2(255)  := p_item.attribute_02;
    l_checked_label    varchar2(4000) := p_item.attribute_03;

    l_name             varchar2(30);
    l_value            varchar2(255);
    l_checkbox_postfix varchar2(8);
    l_result           apex_plugin.t_page_item_render_result;
begin
    -- if the current value doesn't match our checked and unchecked value
    -- we fallback to the unchecked value 
    if p_value in (l_checked_value, l_unchecked_value) then
        l_value := p_value;
    else
        l_value := l_unchecked_value;
    end if;

    if p_is_readonly or p_is_printer_friendly then
        -- if the checkbox is readonly we will still render a hidden field with
        -- the value so that it can be used when the page gets submitted
        wwv_flow_plugin_util.print_hidden_if_readonly (
            p_item_name           => p_item.name,
            p_value               => p_value,
            p_is_readonly         => p_is_readonly,
            p_is_printer_friendly => p_is_printer_friendly );
        l_checkbox_postfix := '_DISPLAY';

        -- Tell APEX that this field is NOT navigable
        l_result.is_navigable := false;
    else
        -- If a page item saves state, we have to call the get_input_name_for_page_item
        -- to render the internal hidden p_arg_names field. It will also return the
        -- HTML field name which we have to use when we render the HTML input field.
        l_name := wwv_flow_plugin.get_input_name_for_page_item(false);

        -- render the hidden field which actually stores the checkbox value
        sys.htp.prn (
            '<input type="hidden" id="'||p_item.name||'_HIDDEN" name="'||l_name||'" '||
            'value="'||l_value||'" />');

        -- Add the JavaScript library and the call to initialize the widget
        apex_javascript.add_library (
            p_name      => 'com_oracle_apex_simple_checkbox.min',
            p_directory => p_plugin.file_prefix,
            p_version   => null );

        apex_javascript.add_onload_code (
            p_code => 'com_oracle_apex_simple_checkbox('||
                      apex_javascript.add_value(p_item.name)||
                      '{'||
                      apex_javascript.add_attribute('unchecked', l_unchecked_value, false)||
                      apex_javascript.add_attribute('checked',   l_checked_value, false, false)||
                      '});' );

        -- Tell APEX that this field is navigable
        l_result.is_navigable := true;
    end if;


    -- render the checkbox widget
    -- fieldset added for UT look and feel
    -- Added apex-item-group--rc for 19.1
    sys.htp.prn('<fieldset tabindex="-1" id="'||p_item.name||'_FIELDSET" class="checkbox_group apex-item-checkbox apex-item-group--rc">');
    sys.htp.prn (
        '<input type="checkbox" id="'||p_item.name||l_checkbox_postfix||'" '||
        'value="'||l_value||'" '||
        case when l_value = l_checked_value then 'checked="checked" ' end||
        -- case when p_is_readonly or p_is_printer_friendly then 'disabled="disabled" ' end||
        -- readonly fixes APEX 5.1 issue, but we should really switch to "Switch" ;-)
        case when p_is_readonly or p_is_printer_friendly then 'readonly="readonly" ' end||
        coalesce(p_item.element_attributes, 'class="simple_checkbox"')||' />');

    -- print label after checkbox
    -- if l_checked_label is not null then
    --   sys.htp.prn('<label for="'||p_item.name||l_checkbox_postfix||'">'||l_checked_label||'</label>');
    -- end if;
    -- for UT, always print the label even when l_checked_label is empty
    sys.htp.prn('<label for="'||p_item.name||l_checkbox_postfix||'">'||l_checked_label||'</label>');
    sys.htp.prn('</fieldset>');

    return l_result;
end render_simple_checkbox;



/**
 *
 * Validates the submitted "Simple Checkbox" value against the configuration to
 * make sure that invalid values submitted by hackers are detected.
 *
 * @param p_item
 * @param p_plugin
 * @param p_value
 *
 */
function validate_simple_checkbox (
    p_item   in apex_plugin.t_page_item,
    p_plugin in apex_plugin.t_plugin,
    p_value  in varchar2
)
return apex_plugin.t_page_item_validation_result
is
    l_checked_value   varchar2(255) := nvl(p_item.attribute_01, 'Y');
    l_unchecked_value varchar2(255) := p_item.attribute_02;

    l_result          apex_plugin.t_page_item_validation_result;
begin
    if not (   p_value in (l_checked_value, l_unchecked_value)
            or (p_value is null and l_unchecked_value is null)
           )
    then
        l_result.message := 'Checkbox contains invalid value!';
    end if;
    return l_result;
end validate_simple_checkbox;



-- ========================================
--  Spotlight Search
-- ========================================
/*-------------------------------------
 * APEX Spotlight Search
 * Version: 1.6.1
 * Author:  Daniel Hochleitner
 *-------------------------------------
*/

--
-- Plug-in Render Function
-- #param p_dynamic_action
-- #param p_plugin
-- #return apex_plugin.t_dynamic_action_render_result
FUNCTION render_apexspotlight(p_dynamic_action IN apex_plugin.t_dynamic_action,
                              p_plugin         IN apex_plugin.t_plugin)
  RETURN apex_plugin.t_dynamic_action_render_result IS
  --
  l_result apex_plugin.t_dynamic_action_render_result;
  --
  -- plugin attributes
  l_placeholder_text           p_plugin.attribute_01%TYPE := nvl(p_dynamic_action.attribute_12,
                                                                 p_plugin.attribute_01);
  l_more_chars_text            p_plugin.attribute_02%TYPE := p_plugin.attribute_02;
  l_no_match_text              p_plugin.attribute_03%TYPE := p_plugin.attribute_03;
  l_one_match_text             p_plugin.attribute_04%TYPE := p_plugin.attribute_04;
  l_multiple_matches_text      p_plugin.attribute_05%TYPE := p_plugin.attribute_05;
  l_inpage_search_text         p_plugin.attribute_06%TYPE := p_plugin.attribute_06;
  l_search_history_delete_text p_plugin.attribute_07%TYPE := p_plugin.attribute_07;
  --
  l_enable_keyboard_shortcuts    VARCHAR2(5) := nvl(p_dynamic_action.attribute_01,
                                                    'N');
  l_keyboard_shortcuts           p_dynamic_action.attribute_02%TYPE := p_dynamic_action.attribute_02;
  l_submit_items                 p_dynamic_action.attribute_04%TYPE := p_dynamic_action.attribute_04;
  l_enable_inpage_search         VARCHAR2(5) := nvl(p_dynamic_action.attribute_05,
                                                    'Y');
  l_max_display_results          NUMBER := to_number(p_dynamic_action.attribute_06);
  l_width                        p_dynamic_action.attribute_07%TYPE := p_dynamic_action.attribute_07;
  l_enable_data_cache            VARCHAR2(5) := nvl(p_dynamic_action.attribute_08,
                                                    'N');
  l_theme                        p_dynamic_action.attribute_09%TYPE := nvl(p_dynamic_action.attribute_09,
                                                                           'STANDARD');
  l_enable_prefill_selected_text VARCHAR2(5) := nvl(p_dynamic_action.attribute_10,
                                                    'N');
  l_show_processing              VARCHAR2(5) := nvl(p_dynamic_action.attribute_11,
                                                    'N');
  l_placeholder_icon             p_dynamic_action.attribute_13%TYPE := nvl(p_dynamic_action.attribute_13,
                                                                           'DEFAULT');
  l_escape_special_chars         VARCHAR2(5) := nvl(p_dynamic_action.attribute_14,
                                                    'Y');
  l_enable_search_history        VARCHAR2(5) := nvl(p_dynamic_action.attribute_15,
                                                    'N');
  --
  l_component_config_json CLOB := empty_clob();
  --
  -- Get DA internal event name
  FUNCTION get_da_event_name(p_action_id IN NUMBER) RETURN VARCHAR2 IS
    --
    l_da_event_name apex_application_page_da.when_event_internal_name%TYPE;
    --
    CURSOR l_cur_da_event IS
      SELECT aapd.when_event_internal_name
        FROM apex_application_page_da      aapd,
             apex_application_page_da_acts aapda
       WHERE aapd.dynamic_action_id = aapda.dynamic_action_id
         AND aapd.application_id = (SELECT nv('APP_ID')
                                      FROM dual)
         AND aapda.action_id = p_action_id;
    --
  BEGIN
    --
    OPEN l_cur_da_event;
    FETCH l_cur_da_event
      INTO l_da_event_name;
    CLOSE l_cur_da_event;
    --
    RETURN nvl(l_da_event_name,
               'ready');
    --
  END get_da_event_name;
  --
  -- Get DA Fire on Initialization property
  FUNCTION get_da_fire_on_init(p_action_id IN NUMBER) RETURN VARCHAR2 IS
    --
    l_da_fire_on_init apex_application_page_da_acts.execute_on_page_init%TYPE;
    --
    CURSOR l_cur_da_fire_on_init IS
      SELECT decode(aapda.execute_on_page_init,
                    'Yes',
                    'Y',
                    'No',
                    'N') AS execute_on_page_init
        FROM apex_application_page_da_acts aapda
       WHERE aapda.application_id = (SELECT nv('APP_ID')
                                       FROM dual)
         AND aapda.action_id = p_action_id;
    --
  BEGIN
    --
    OPEN l_cur_da_fire_on_init;
    FETCH l_cur_da_fire_on_init
      INTO l_da_fire_on_init;
    CLOSE l_cur_da_fire_on_init;
    --
    RETURN nvl(l_da_fire_on_init,
               'N');
    --
  END get_da_fire_on_init;
  --
BEGIN
  -- Debug
  IF apex_application.g_debug THEN
    apex_plugin_util.debug_dynamic_action(p_plugin         => p_plugin,
                                          p_dynamic_action => p_dynamic_action);
  END IF;
  --
  -- add mousetrap.js & mark.js libs & tippy libs
  IF l_enable_keyboard_shortcuts = 'Y' THEN
    apex_javascript.add_library(p_name                  => 'mousetrap',
                                p_directory             => p_plugin.file_prefix || 'js/',
                                p_version               => NULL,
                                p_skip_extension        => FALSE,
                                p_check_to_add_minified => TRUE);
  END IF;
  --
  IF l_enable_inpage_search = 'Y' THEN
    apex_javascript.add_library(p_name                  => 'jquery.mark',
                                p_directory             => p_plugin.file_prefix || 'js/',
                                p_version               => NULL,
                                p_skip_extension        => FALSE,
                                p_check_to_add_minified => TRUE);
  END IF;
  --
  IF l_enable_search_history = 'Y' THEN
    apex_javascript.add_library(p_name                  => 'tippy.all',
                                p_directory             => p_plugin.file_prefix || 'js/',
                                p_version               => NULL,
                                p_skip_extension        => FALSE,
                                p_check_to_add_minified => TRUE);
  END IF;
  -- escape input
  IF l_escape_special_chars = 'Y' THEN
    l_placeholder_text           := apex_escape.html(l_placeholder_text);
    l_more_chars_text            := apex_escape.html(l_more_chars_text);
    l_no_match_text              := apex_escape.html(l_no_match_text);
    l_one_match_text             := apex_escape.html(l_one_match_text);
    l_multiple_matches_text      := apex_escape.html(l_multiple_matches_text);
    l_inpage_search_text         := apex_escape.html(l_inpage_search_text);
    l_search_history_delete_text := apex_escape.html(l_search_history_delete_text);
    l_placeholder_icon           := apex_escape.html(l_placeholder_icon);
  END IF;
  -- build component config json
  apex_json.initialize_clob_output;
  apex_json.open_object();
  -- general
  apex_json.write('dynamicActionId',
                  p_dynamic_action.id);
  apex_json.write('ajaxIdentifier',
                  apex_plugin.get_ajax_identifier);
  apex_json.write('eventName',
                  get_da_event_name(p_action_id => p_dynamic_action.id));
  apex_json.write('fireOnInit',
                  get_da_fire_on_init(p_action_id => p_dynamic_action.id));
  -- app wide attributes
  apex_json.write('placeholderText',
                  l_placeholder_text);
  apex_json.write('moreCharsText',
                  l_more_chars_text);
  apex_json.write('noMatchText',
                  l_no_match_text);
  apex_json.write('oneMatchText',
                  l_one_match_text);
  apex_json.write('multipleMatchesText',
                  l_multiple_matches_text);
  apex_json.write('inPageSearchText',
                  l_inpage_search_text);
  apex_json.write('searchHistoryDeleteText',
                  l_search_history_delete_text);
  -- component attributes
  apex_json.write('enableKeyboardShortcuts',
                  l_enable_keyboard_shortcuts);
  apex_json.write('keyboardShortcuts',
                  l_keyboard_shortcuts);
  apex_json.write('submitItems',
                  l_submit_items);
  apex_json.write('enableInPageSearch',
                  l_enable_inpage_search);
  apex_json.write('maxNavResult',
                  l_max_display_results);
  apex_json.write('width',
                  l_width);
  apex_json.write('enableDataCache',
                  l_enable_data_cache);
  apex_json.write('spotlightTheme',
                  l_theme);
  apex_json.write('enablePrefillSelectedText',
                  l_enable_prefill_selected_text);
  apex_json.write('showProcessing',
                  l_show_processing);
  apex_json.write('placeHolderIcon',
                  l_placeholder_icon);
  apex_json.write('enableSearchHistory',
                  l_enable_search_history);
  apex_json.close_object();
  --
  l_component_config_json := apex_json.get_clob_output;
  apex_json.free_output;
  -- init keyboard shortcut
  IF l_enable_keyboard_shortcuts = 'Y' THEN
    apex_javascript.add_inline_code(p_code => 'function apexSpotlightInitKeyboardShortcuts' || p_dynamic_action.id ||
                                              '() { apex.da.apexSpotlight.initKeyboardShortcuts(' ||
                                              l_component_config_json || '); }');
    apex_javascript.add_onload_code(p_code => 'apexSpotlightInitKeyboardShortcuts' || p_dynamic_action.id || '();');
  END IF;
  -- DA javascript function
  l_result.javascript_function := 'function() { apex.da.apexSpotlight.pluginHandler(' || l_component_config_json ||
                                  '); }';
  --
  RETURN l_result;
  --
END render_apexspotlight;
--
-- Plug-in AJAX Function
-- #param p_dynamic_action
-- #param p_plugin
-- #return apex_plugin.t_dynamic_action_ajax_result
FUNCTION ajax_apexspotlight(p_dynamic_action IN apex_plugin.t_dynamic_action,
                            p_plugin         IN apex_plugin.t_plugin) RETURN apex_plugin.t_dynamic_action_ajax_result IS
  --
  l_result apex_plugin.t_dynamic_action_ajax_result;
  --
  l_request_type VARCHAR2(50);
  --
  -- Execute Spotlight GET_DATA Request
  PROCEDURE exec_get_data_request(p_dynamic_action IN apex_plugin.t_dynamic_action,
                                  p_plugin         IN apex_plugin.t_plugin) IS
    l_data_source_sql_query p_dynamic_action.attribute_03%TYPE := p_dynamic_action.attribute_03;
    l_escape_special_chars  VARCHAR2(5) := nvl(p_dynamic_action.attribute_14,
                                               'Y');
    l_data_type_list        apex_application_global.vc_arr2;
    l_column_value_list     apex_plugin_util.t_column_value_list2;
    l_row_count             NUMBER;
    l_name                  VARCHAR2(4000);
    l_description           VARCHAR2(4000);
    l_link                  VARCHAR2(4000);
    l_icon                  VARCHAR2(4000);
    l_icon_color            VARCHAR2(4000);
  BEGIN
    -- Data Types of SQL Source Columns
    l_data_type_list(1) := apex_plugin_util.c_data_type_varchar2;
    l_data_type_list(2) := apex_plugin_util.c_data_type_varchar2;
    l_data_type_list(3) := apex_plugin_util.c_data_type_varchar2;
    l_data_type_list(4) := apex_plugin_util.c_data_type_varchar2;
    l_data_type_list(5) := apex_plugin_util.c_data_type_varchar2;
    -- Get Data from SQL Source
    l_column_value_list := apex_plugin_util.get_data2(p_sql_statement  => l_data_source_sql_query,
                                                      p_min_columns    => 4,
                                                      p_max_columns    => 5,
                                                      p_data_type_list => l_data_type_list,
                                                      p_component_name => p_dynamic_action.action);
    -- loop over SQL Source results and write json
    apex_json.open_array();
    --
    l_row_count := l_column_value_list(1).value_list.count;
    --
    FOR i IN 1 .. l_row_count LOOP
      -- escape input
      IF l_escape_special_chars = 'Y' THEN
        l_name        := apex_escape.html(l_column_value_list(1).value_list(i).varchar2_value);
        l_description := apex_escape.html(l_column_value_list(2).value_list(i).varchar2_value);
        l_link        := l_column_value_list(3).value_list(i).varchar2_value;
        l_icon        := apex_escape.html(l_column_value_list(4).value_list(i).varchar2_value);
        IF l_column_value_list.last = 5 THEN
          l_icon_color := apex_escape.html(l_column_value_list(5).value_list(i).varchar2_value);
        END IF;
      ELSE
        l_name        := l_column_value_list(1).value_list(i).varchar2_value;
        l_description := l_column_value_list(2).value_list(i).varchar2_value;
        l_link        := l_column_value_list(3).value_list(i).varchar2_value;
        l_icon        := l_column_value_list(4).value_list(i).varchar2_value;
        IF l_column_value_list.last = 5 THEN
          l_icon_color := l_column_value_list(5).value_list(i).varchar2_value;
        END IF;
      END IF;
      -- write json
      apex_json.open_object;
      -- name / title
      apex_json.write('n',
                      l_name);
      -- description
      apex_json.write('d',
                      l_description);
      -- link / URL
      apex_json.write('u',
                      l_link);
      -- icon
      apex_json.write('i',
                      l_icon);
      -- icon color (optional)
      IF l_column_value_list.last = 5 THEN
        apex_json.write('ic',
                        nvl(l_icon_color,
                            'DEFAULT'));
      END IF;
      -- if URL contains ~SEARCH_VALUE~, make list entry static
      IF instr(l_link,
               '~SEARCH_VALUE~') > 0 THEN
        apex_json.write('s',
                        TRUE);
      ELSE
        apex_json.write('s',
                        FALSE);
      END IF;
      -- type
      apex_json.write('t',
                      'redirect');
      apex_json.close_object;
    END LOOP;
    --
    apex_json.close_array;
  END exec_get_data_request;
  --
  -- Execute Spotlight GET_URL Request
  PROCEDURE exec_get_url_request(p_dynamic_action IN apex_plugin.t_dynamic_action,
                                 p_plugin         IN apex_plugin.t_plugin) IS
    l_search_value VARCHAR2(1000);
    l_url          VARCHAR2(4000);
    l_url_new      VARCHAR2(4000);
  BEGIN
    -- get values from AJAX call X02/X03
    l_search_value := apex_application.g_x02;
    l_url          := apex_application.g_x03;
    -- Check for f?p URL and if URL contains ~SEARCH_VALUE~ substitution string
    IF instr(l_url,
             'f?p=') > 0
       AND instr(l_url,
                 '~SEARCH_VALUE~') > 0 THEN
      -- replace substitution string with real search value
      l_url := REPLACE(l_url,
                       '~SEARCH_VALUE~',
                       l_search_value);
      -- if input URL already contains a checksum > remove checksum
      IF instr(l_url,
               '&cs=') > 0 THEN
        l_url := substr(l_url,
                        1,
                        instr(l_url,
                              '&cs=') - 1);
      END IF;
      -- get SSP URL
      l_url_new := apex_util.prepare_url(p_url => l_url);
      --
      apex_json.open_object;
      apex_json.write('url',
                      l_url_new);
      apex_json.close_object;
      -- if checks don't succeed return input URL back
    ELSE
      apex_json.open_object;
      apex_json.write('url',
                      l_url);
      apex_json.close_object;
    END IF;
  END exec_get_url_request;
  --
BEGIN
  -- Check request type in X01
  l_request_type := apex_application.g_x01;
  -- GET_DATA Request
  IF l_request_type = 'GET_DATA' THEN
    exec_get_data_request(p_dynamic_action => p_dynamic_action,
                          p_plugin         => p_plugin);
    -- GET_URL Request
  ELSIF l_request_type = 'GET_URL' THEN
    exec_get_url_request(p_dynamic_action => p_dynamic_action,
                         p_plugin         => p_plugin);
    --
  END IF;
  --
  RETURN l_result;
  --
END ajax_apexspotlight;


-- ========================================
-- ========================================




end ks_plugins;
/



-- @../views/ks_events_comps_v.sql
PRO ks_events_comps_v
create or replace force view ks_events_comps_v
as
select  s.event_id
      , s.event_track_id
      , s.presenter_user_id
      , ks_session_api.get_presenter_comp(s.event_id, s.event_track_id , s.presenter_user_id) as presenter_comp
   from ks_sessions s
  where s.status_code = 'ACCEPTED'
group by s.event_id, s.event_track_id, s.presenter_user_id
/

PRO _________________________________________________
PRO . DML

PRO .. Make presenter_user_id mandatory
-- @../conversion/populate_presenter_user_id.sql


PRO ... create table tmp_presenters
create table tmp_presenters
as
select presenter, max(presenter_user_id) presenter_user_id
from ks_sessions
where presenter in (
    select presenter
    from ks_sessions
    where presenter_user_id is not null
)
  and presenter_user_id is not null
group by presenter
/

create or replace function get_presenter_user_id(p_presenter in ks_sessions.presenter%TYPE)
  return ks_sessions.presenter_user_id%TYPE
is
  l_presenter_user_id ks_sessions.presenter_user_id%TYPE;
  l_presenter_hash varchar2(128);
begin
  select presenter_user_id
    into l_presenter_user_id
    from tmp_presenters
   where presenter = p_presenter;

  -- ks_log.log('Got l_presenter_user_id:' || l_presenter_user_id, 'get_presenter_user_id');
  return l_presenter_user_id;

 exception
 when NO_DATA_FOUND then
   -- generate an ID:
   --   * create and MD5 of the presenter name
   --   * Convert it to a number (because we get a RAW back)
   --   * Convert the number back to a String and grab the first 20 only (the size limit of presenter_user_id)
   return substr(
      to_char(
          to_number(
            dbms_obfuscation_toolkit.md5(input => utl_raw.cast_to_raw(p_presenter))
            , 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')
      ),1,20);
end get_presenter_user_id;
/



declare
  cursor presenters_cur
  is
    select * from ks_sessions 
    where presenter_user_id is null
      for update of presenter_user_id;

  l_session_rec presenters_cur%rowtype;

begin

  open presenters_cur;
  loop
    fetch presenters_cur into l_session_rec;
    exit when presenters_cur%NOTFOUND;

    update ks_sessions
       set presenter_user_id = get_presenter_user_id(presenter)
     where current of presenters_cur;

  end loop;
  close presenters_cur;

end;
/


PRO ... Cleanup: Drop tmp_presenters, get_presenter_user_id
drop table tmp_presenters;

drop function get_presenter_user_id;



alter table ks_sessions modify presenter_user_id not null;



-- #2
insert into constraint_lookup (constraint_name,message) values ('KS_EVENT_COMMUNITY_TRACKS_U01','That track is already part of the community.');
insert into constraint_lookup (constraint_name,message) values ('KS_COMMUNITY_TRACKS_FK','The community cannot be removed when it has tracks.');
insert into constraint_lookup (constraint_name,message) values ('KS_EVENT_COMMUNITY_TRACKS_FK', 'The track cannot be removed if it is associated with a community.');
-- #35
insert into ks_parameters (category, name_key, value, description) values ('Notifications','SESSION_MOVED_BETWEEN_TRACKS_TEMPLATE','SESSION_MOVED_BETWEEN_TRACKS','Name of email template for when a session is moved between tracks');

insert into ks_parameters (category, name_key, value, description) values ('SYSTEM','ANONYMIZE_TOKENS','NO','YES|NO Set to NO to override anonimizing tokens, even for Blind Voting');

delete from ks_email_templates where name = 'SESSION_MOVED_BETWEEN_TRACKS';
insert into ks_email_templates (name, template_text)
 values ('SESSION_MOVED_BETWEEN_TRACKS'
  , q'{The session <i>"#SESSION_TITLE#"</i> from #SPEAKER# has been moved from <i>#FROM_TRACK#</i> to <b>#TO_TRACK#</b>

Sub Category : <i>#SUB_CATEGORY#</i>
Session Type : <i>#SESSION_TYPE#</i>

All existing votes from <i>#FROM_TRACK#</i> track have been removed.
Tags most likely should be revised.
}');

-- ## 44
-- @../conversion/seed_ks_load_mapping.sql
PRO Removing previous mapping
delete from KS_LOAD_MAPPING;
REM INSERTING into KS_LOAD_MAPPING
SET DEFINE OFF;
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',10,'SESSION_NUM','Session Number');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',20,'TITLE','Session Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',30,null,'Session Title Link');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',40,'EVENT_TRACK_ID','Track');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',50,'SUB_CATEGORY','Sub-Categorization');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',60,'SESSION_TYPE','Session Type');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',70,null,'Role:Submitter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',80,null,'Session Status');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',90,null,'All roles');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',100,null,'All roles (with line break)');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',110,'ACE_LEVEL','Are you part of the ACE program?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',120,null,'Cross-Listed Tracks');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',130,'PRESENTED_ANYTHING_IND','Have you ever presented before a live audience?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',140,'PRESENTED_BEFORE_IND','Have you presented this session before?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',150,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',160,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',170,null,'I Agree');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',180,'PRESENTED_BEFORE_WHERE','If yes, at what events?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',190,'PRESENTED_ANYTHING_WHERE','If yes, at what events?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',200,'SUBMISSION_DATE','Initial Submission');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',210,null,'Last Update');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',220,'VIDEO_LINK','Link to your optional abstract submission video');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',230,null,'Review Comments');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',240,null,'Role:Co-Presenter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',250,'CO_PRESENTER_COMPANY','Role:Co-Presenter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',260,null,'Role:Co-Presenter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',270,'CO_PRESENTER','Role:Co-Presenter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',280,null,'Role:Co-Presenter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',290,null,'Role:Co-Presenter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',300,'CO_PRESENTER_USER_ID','Role:Co-Presenter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',310,'PRESENTER_BIOGRAPHY','Role:Primary Presenter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',320,'COMPANY','Role:Primary Presenter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',330,'PRESENTER_EMAIL','Role:Primary Presenter Email');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',340,null,'Role:Primary Presenter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',350,'PRESENTER','Role:Primary Presenter Full Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',360,null,'Role:Primary Presenter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',370,null,'Role:Primary Presenter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',380,'PRESENTER_USER_ID','Role:Primary Presenter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',390,null,'Role:Submitter Biography');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',400,null,'Role:Submitter Company');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',410,null,'Role:Submitter Email');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',420,null,'Role:Submitter First Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',430,null,'Role:Submitter Last Name');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',440,null,'Role:Submitter Title');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',450,null,'Role:Submitter User Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',460,'SESSION_ABSTRACT','Session Description');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',470,'EXTERNAL_SYS_REF','Session Id');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',480,'SESSION_SUMMARY','Short Description');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',490,null,'Status Change');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',500,'TAGS','Tags');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',510,'TECHNOLOGY_PRODUCT','Technologies or Products Used');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',520,'SESSION_LENGTH','The length of my presentation can be');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',530,null,'Vote Average');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',540,null,'Vote Count');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',550,'CONTAINS_DEMO_IND','Will this presentation include a demo?');
Insert into KS_LOAD_MAPPING (TABLE_NAME,DISPLAY_SEQ,TO_COLUMN_NAME,HEADER_NAME) values ('KS_FULL_SESSION_LOAD',560,'WEBINAR_WILLING_IND','Would you be willing to present this as a webinar?');


-- DO NOT TOUCH/UPDATE BELOW THIS LINE


PRO Recompiling objects
exec dbms_utility.compile_schema(schema => user, compile_all => false);
