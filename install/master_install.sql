PRO  =============================  KS Review App =========================


set serveroutput on

declare
  l_count pls_integer;

begin
  -- Create Table
  select count(1)
  into l_count
  from user_tables
  where table_name = 'CONSTRAINT_LOOKUP';

  if l_count = 0 then
    execute immediate '
    create table constraint_lookup
    (   constraint_name varchar2(255) primary key not null
      , message         varchar2(4000)
    )';
    dbms_output.put_line('Table CONSTRAINT_LOOKUP created');
  else
    dbms_output.put_line('Table CONSTRAINT_LOOKUP already exists');
  end if;
end;
/

-- drop table ks_session_load purge;
create table ks_session_load (
    app_user     varchar2(60) default coalesce(
                                         sys_context('APEX$SESSION','app_user')
                                       , sys_context ('userenv', 'os_user'), user)
  , SESSION_NUM       number
  , SUB_CATEGORIZATION varchar2(4000)
  , session_type      varchar2(4000)
  , "SESSION"         varchar2(4000)
  , primary_presenter varchar2(4000)
  , co_presenter      varchar2(4000)
  , voter             varchar2(4000)
  , total             number
  , "COMMENT"         varchar2(4000)
)
/

comment on table ks_session_load is 'Staging table for loading sessions.';

/*
This table is based on these export columns. (-) column excluded from load
Session Num
Sub Categorization
Session Type
Session
Session Submitter(-)
Primary Presenter
Co-Presenter
Voter
Total
Vote(-)
Comment
*/

create table ks_users (
    id             number        generated by default on null as identity (start with 1) primary key not null
  , username       varchar2(60)  not null
  , password       varchar2(200)
  , first_name     varchar2(50)
  , last_name      varchar2(50)
  , email          varchar2(254)
  , active_ind     varchar2(1)   not null
  , admin_ind      varchar2(1)   not null
  , created_by     varchar2(60)  default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                    )
                    not null
  , created_on     date         default sysdate not null
  , updated_by     varchar2(60)
  , updated_on     date
  , constraint ks_users_ck_active
      check (active_ind in ('Y', 'N'))
  , constraint ks_admin_users_ck
      check (admin_ind in ('Y', 'N'))
  , constraint ks_username_u unique (username)
)
enable primary key using index
/

create unique index ks_users_u01
  on ks_users(upper(username))
/
create unique index ks_users_u02
  on ks_users(upper(email))
/

comment on table ks_users is 'All users in the system.';

comment on column ks_users.username is 'Order for displaying the lines';
comment on column ks_users.admin_ind is 'Is this a System Admin user Y/N?';
comment on column ks_users.active_ind is 'Is the record enabled Y/N?';
comment on column ks_users.created_by is 'User that created this record';
comment on column ks_users.created_on is 'Date the record was first created';
comment on column ks_users.updated_by is 'User that last modified this record';
comment on column ks_users.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--  DDL for Trigger ks_users_iu
--------------------------------------------------------
create or replace trigger ks_users_iu
before insert or update
on ks_users
referencing old as old new as new
for each row
begin
  if inserting then
    :new.created_on := sysdate;
    :new.created_by := coalesce(v('APP_USER'), sys_context ('userenv', 'os_user'), user);
  elsif updating then
    :new.updated_on := sysdate;
    :new.updated_by := coalesce(
                           sys_context('APEX$SESSION','app_user')
                         , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                         , sys_context('userenv','session_user')
                       );
  end if;
/*
  -- HEADS UP! This code is maintained and installed form plsql/ks_users_iu.sql
  -- This is due to the dependency on cw_sec

  if :new.password is not null then
    l_pass_w_salt := ks_sec.password_with_salt(:new.password);
    :new.password := l_pass_w_salt;
  end if;
*/

end;
/
alter trigger ks_users_iu enable;
create table ks_parameters (
    id            number        generated by default on null as identity (start with 1) primary key
  , category      varchar2(100) not null
  , name_key      varchar2(200) not null
  , value         varchar2(4000)
  , description   varchar2(4000)
  , created_by    varchar2(60) default 
                    coalesce(
                       sys_context('APEX$SESSION','app_user')
                       ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       ,sys_context('userenv','session_user')
                       )
                    not null
  , created_on    date         default sysdate not null
  , updated_by    varchar2(60)
  , updated_on    date
)
enable primary key using index
/

create unique index ks_parameters_u01
  on ks_parameters(name_key)
/

comment on table ks_parameters is 'Application parameters.';

comment on column ks_parameters.category is 'Informational field to group parameters by functional area. New categories are added by a developer.';
comment on column ks_parameters.name_key is 'Unique name to identify a parameter.';

--------------------------------------------------------
--  DDL for Trigger ks_parameters_u_trg
--------------------------------------------------------
create or replace trigger ks_parameters_u_trg
before insert or update
on  ks_parameters
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                     sys_context('APEX$SESSION','app_user')
                     ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                     ,sys_context('userenv','session_user')
                     );

end;
/
alter trigger ks_parameters_u_trg enable;
create table ks_tracks (
    id             number        generated by default on null as identity (start with 1) primary key not null
  , display_seq    number        not null
  , name           varchar2(100)  not null
  , alias          varchar2(32)
  , active_ind     varchar2(1)   not null
  , created_by     varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                       )
                    not null
  , created_on     date         default sysdate not null
  , updated_by     varchar2(60)
  , updated_on     date
  , constraint ks_tracks_ck_active
      check (active_ind in ('Y', 'N'))
)
enable primary key using index
/

create unique index ks_tracks_u01 on ks_tracks(upper(name));

comment on table ks_tracks is 'Master (seed) list of tracks used to seed ks_event_tracks';

comment on column ks_tracks.display_seq is 'Order for displaying the lines';
comment on column ks_tracks.active_ind is 'Is the record enabled Y/N?';
comment on column ks_tracks.created_by is 'User that created this record';
comment on column ks_tracks.created_on is 'Date the record was first created';
comment on column ks_tracks.updated_by is 'User that last modified this record';
comment on column ks_tracks.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--  DDL for Trigger ks_tracks_u_trg
--------------------------------------------------------
create or replace trigger ks_tracks_u_trg
before update
on ks_tracks
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_tracks_u_trg enable;
create table ks_events (
    id            number        generated by default on null as identity (start with 1) primary key not null
  , name          varchar2(100) not null
  , alias         varchar2(32)
  , location      varchar2(200)
  , begin_date    date          not null
  , end_date      date
  , active_ind    varchar2(1)   not null
  , created_by    varchar2(60) default 
                    coalesce(
                       sys_context('APEX$SESSION','app_user')
                       ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       ,sys_context('userenv','session_user')
                       )
                    not null
  , created_on    date         default sysdate not null
  , updated_by    varchar2(60)
  , updated_on    date
  , constraint ks_events_ck_active
      check (active_ind in ('Y', 'N'))
)
enable primary key using index
/

comment on table ks_events is 'List of Events (ie. Kscope17, ...)';

comment on column ks_events.name is 'Event name';
comment on column ks_events.alias is 'Event short name (if present)';
comment on column ks_events.location is 'Event location (city, state)';
comment on column ks_events.active_ind is 'Is the record enabled Y/N?';
comment on column ks_events.created_by is 'User that created this record';
comment on column ks_events.created_on is 'Date the record was first created';
comment on column ks_events.updated_by is 'User that last modified this record';
comment on column ks_events.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--  DDL for Trigger ks_events_u_trg
--------------------------------------------------------
create or replace trigger ks_events_u_trg
before update
on ks_events
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                     sys_context('APEX$SESSION','app_user')
                     ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                     ,sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_events_u_trg enable;
create table ks_event_tracks (
    id            number        generated by default on null as identity (start with 1) primary key not null
  , event_id      number        not null
  , display_seq   number        not null
  , name          varchar2(100)  not null
  , alias         varchar2(32)
  , owner         varchar2(60)
  , max_sessions  number
  , max_comps     number
  , active_ind    varchar2(1)   not null
  , created_by    varchar2(60) default 
                    coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                       )
                    not null
  , created_on    date         default sysdate not null
  , updated_by    varchar2(60)
  , updated_on    date
  , constraint ks_event_tracks_ck_active
      check (active_ind in ('Y', 'N'))
  , constraint ks_event_owner_fk foreign key ( owner ) references ks_users ( username ) not deferrable
  , constraint ks_event_tracks_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
)
enable primary key using index
/

comment on table ks_event_tracks is 'List of event tracks';

comment on column ks_event_tracks.event_id is 'Event this track belongs to';
comment on column ks_event_tracks.owner is 'User responsible for this track (username from ks_users)';
comment on column ks_event_tracks.display_seq is 'Order for displaying the lines';
comment on column ks_event_tracks.active_ind is 'Is the record enabled Y/N?';
comment on column ks_event_tracks.created_by is 'User that created this record';
comment on column ks_event_tracks.created_on is 'Date the record was first created';
comment on column ks_event_tracks.updated_by is 'User that last modified this record';
comment on column ks_event_tracks.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--  DDL for Trigger ks_event_tracks_u_trg
--------------------------------------------------------
create or replace trigger ks_event_tracks_u_trg
before update
on ks_event_tracks
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                     sys_context('APEX$SESSION','app_user')
                     ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                     ,sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_event_tracks_u_trg enable;

create table ks_sessions (
    id             number        generated by default on null as identity (start with 1) primary key
  , event_id       number
  , event_track_id number
  , session_num    number not null
  , sub_category   varchar2(500)
  , session_type   varchar2(500)
  , title          varchar2(500)
  , presenter      varchar2(500)
  , company        varchar2(500)
  , co_presenter   varchar2(500)
  , status_code    varchar2(20)
  , notes          varchar2(4000)
  , tags           varchar2(4000)
  , created_by     varchar2(60) default 
                    coalesce(
                       sys_context('APEX$SESSION','app_user')
                       ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       ,sys_context('userenv','session_user')
                       )
                    not null
  , created_on     date         default sysdate not null
  , updated_by     varchar2(60)
  , updated_on     date
  , constraint ks_events_fk foreign key ( event_id ) references ks_events ( id ) not deferrable
  , constraint ks_event_track_sessions_fk foreign key ( event_track_id ) references ks_event_tracks ( id ) not deferrable
)
/

create unique index ks_sessions_u01 on ks_sessions(session_num);
create index ks_sessions_n01 on ks_sessions(event_id);
create index ks_sessions_n02 on ks_sessions(event_track_id);

comment on table ks_sessions is 'Event Sessions.';

comment on column ks_sessions.session_num is 'Unique session identifier assigned by ODTUG';
comment on column ks_sessions.event_id is 'Event this session belongs to.';
comment on column ks_sessions.event_track_id is 'Track this session was submitted.';
comment on column ks_sessions.presenter is 'The name of the presenter for this session.';
comment on column ks_sessions.company is 'The company the presenter works for.';
comment on column ks_sessions.created_by is 'User that created this record';
comment on column ks_sessions.created_on is 'Date the record was first created';
comment on column ks_sessions.updated_by is 'User that last modified this record';
comment on column ks_sessions.updated_on is 'Date the record was last modified';

create or replace trigger ks_sessions_iu_trg 
before insert or update
on ks_sessions
referencing old as old new as new
for each row
begin
  if updating then
    :new.updated_on := sysdate;
    :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                         ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                         ,sys_context('userenv','session_user')
                       );
  end if;
/* this install trigger gets replaces by ks_tags_post_install.sql
  ks_tags_api.tag_sync(
     p_new_tags      => :new.tags,
     p_old_tags      => :old.tags,
     p_content_type  => 'SESSION',
     p_content_id    => :new.session_num );
*/
end;
/
create table ks_session_votes (
    id             number        generated by default on null as identity (start with 1) primary key
  , session_id     number not null
  , session_num    number not null
  , voter          varchar2(500)
  , vote           number
  , comments       varchar2(4000)
  , created_by     varchar2(60) default 
                    coalesce(
                       sys_context('APEX$SESSION','app_user')
                       ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       ,sys_context('userenv','session_user')
                       )
                    not null
  , created_on     date         default sysdate not null
  , updated_by     varchar2(60)
  , updated_on     date
  , constraint ks_sessions_fk foreign key ( session_id ) references ks_sessions ( id )
)
/

comment on table ks_session_votes is 'Event Session votes. One row per voter.';

comment on column ks_session_votes.session_num is 'Unique session identifier assigned by ODTUG. Denormalized include, to make things easy.';
comment on column ks_session_votes.voter is 'Name of individual that casted a vote';
comment on column ks_session_votes.vote is 'Vote rating (1..5)';
comment on column ks_session_votes.created_by is 'User that created this record';
comment on column ks_session_votes.created_on is 'Date the record was first created';
comment on column ks_session_votes.updated_by is 'User that last modified this record';
comment on column ks_session_votes.updated_on is 'Date the record was last modified';

create or replace trigger ks_session_votes_u_trg
before update
on ks_session_votes
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                         sys_context('APEX$SESSION','app_user')
                       , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       , sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_session_votes_u_trg enable;

create table ks_tags (
    id             number        generated by default on null as identity (start with 1) primary key not null
  , tag            varchar2(255) not null
  , content_id     number
  , content_type   varchar2(30) 
  , created_by     varchar2(60) default 
                    coalesce(
                       sys_context('APEX$SESSION','app_user')
                       ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       ,sys_context('userenv','session_user')
                       )
                    not null
  , created_on     date         default sysdate not null
  , updated_by     varchar2(60)
  , updated_on     date
)
enable primary key using index
/

create index ks_tags_i01 on ks_tags(tag)
/

comment on table ks_tags is 'Reference of Tags assigned and the row (content_type, content_id) they are assigned to.';

comment on column ks_tags.tag is 'Actual tag.';
comment on column ks_tags.content_type is 'Entity that uses the tag.  Currently SESSION:{TRACK_ID}';
comment on column ks_tags.content_id   is 'ID of Entity that uses the tag.';

--------------------------------------------------------
--  DDL for Trigger ks_tags_u_trg
--------------------------------------------------------
create or replace trigger ks_tags_u_trg
before update
on ks_tags
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                        sys_context('APEX$SESSION','app_user')
                      , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                      , sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_tags_u_trg enable;

-- ========================================
PROMPT ks_tag_sums
create table ks_tag_sums (
    tag                   varchar2(255) not null
  , tag_count             number
  , constraint ks_tag_sums_pk primary key (tag)
)
enable primary key using index 
/


comment on table ks_tag_sums is 'All tags and their counts.';

comment on column ks_tag_sums.tag is 'Actual tag.';
comment on column ks_tag_sums.tag_count is 'Number of times the tag appears.';

-- ========================================
PROMPT ks_tag_type_sums
create table ks_tag_type_sums (
    tag                   varchar2(255) not null
  , tag_count             number
  , content_type          varchar2(30)
  , constraint ks_tag_type_sums_pk primary key (tag, content_type)
)
enable primary key using index
/


comment on table ks_tag_type_sums is 'All tags and their counts by type.';

comment on column ks_tag_type_sums.tag is 'Actual tag.';
comment on column ks_tag_type_sums.tag_count is 'Number of times the tag appears.';
comment on column ks_tag_type_sums.content_type is 'Entity that uses the tag.  Currently SESSION:{TRACK_ID}';

create table ks_session_status (
    id            number        generated by default on null as identity (start with 1) primary key not null
  , display_seq   number        not null
  , code          varchar2(20)  not null
  , name          varchar2(32)  not null
  , active_ind    varchar2(1)   not null
  , created_by    varchar2(60) default 
                    coalesce(
                       sys_context('APEX$SESSION','app_user')
                       ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       ,sys_context('userenv','session_user')
                       )
                    not null
  , created_on    date         default sysdate not null
  , updated_by    varchar2(60)
  , updated_on    date
  , constraint ks_session_status_ck_active
      check (active_ind in ('Y', 'N'))
)
enable primary key using index
/

create unique index ks_session_status_u01 on ks_session_status(code);
  
comment on table ks_session_status is 'List of statuses of a session.';

comment on column ks_session_status.display_seq is 'Order for displaying the fav lines';
comment on column ks_session_status.active_ind is 'Is the record enabled Y/N?';
comment on column ks_session_status.created_by is 'User that created this record';
comment on column ks_session_status.created_on is 'Date the record was first created';
comment on column ks_session_status.updated_by is 'User that last modified this record';
comment on column ks_session_status.updated_on is 'Date the record was last modified';


--------------------------------------------------------
--  DDL for Trigger ks_session_status_u_trg
--------------------------------------------------------
create or replace trigger ks_session_status_u_trg
before update
on ks_session_status
referencing old as old new as new
for each row
begin
  :new.updated_on := sysdate;
  :new.updated_by := coalesce(
                       sys_context('APEX$SESSION','app_user')
                       ,regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                       ,sys_context('userenv','session_user')
                     );
end;
/
alter trigger ks_session_status_u_trg enable;
--  Seed Values -----------------------------
PRO seed ks_tracks

/*
 Seed the following Tracks:

  Application Express
  BI & Data Warehousing
  Big Data & Advanced Analytics
  Database
  EPM Applications
  EPM Business Content
  EPM Data Integration
  EPM Foundations
  EPM Platform
  EPM Reporting
  Essbase
  Financial Close
  Planning
  Vendor Presentation
*/
set define off

insert into ks_tracks (display_seq, name, alias, active_ind) values (10, 'Application Express', 'APEX', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (20, 'BI & Data Warehousing', 'BI', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (30, 'Big Data & Advanced Analytics', 'Big Data', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (40, 'Database', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (50, 'EPM Applications', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (60, 'EPM Business Content', 'EPM Business', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (70, 'EPM Data Integration', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (80, 'EPM Foundations', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (90, 'EPM Platform', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (100, 'EPM Reporting', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (110, 'Essbase', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (120, 'Financial Close', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (130, 'Planning', '', 'Y');
insert into ks_tracks (display_seq, name, alias, active_ind) values (140, 'Vendor Presentation', 'Vendor', 'Y');

set define on
PRO seed ks_session_status

SET DEFINE OFF;

insert into ks_session_status (display_seq, code, name, active_ind) values (10, 'ACCEPTED', 'Accepted', 'Y');
insert into ks_session_status (display_seq, code, name, active_ind) values (20, 'REJECTED', 'Rejected', 'Y');
insert into ks_session_status (display_seq, code, name, active_ind) values (30, 'ONHOLD', 'On-Hold', 'Y');
insert into ks_session_status (display_seq, code, name, active_ind) values (40, 'WEBINAR', 'Webinar', 'Y');
insert into ks_session_status (display_seq, code, name, active_ind) values (99, 'TBA', 'TBA', 'Y');
PRO seed ks_events

SET DEFINE OFF;


insert into ks_events(name, alias, location, begin_date, end_date, active_ind) values ('Kscope16', '', 'Chicago', to_date('26-JUN-2016', 'DD-MON-YYYY'), to_date('30-JUN-2016', 'DD-MON-YYYY'), 'Y');
insert into ks_events(name, alias, location, begin_date, end_date, active_ind) values ('Kscope17', '', 'San Antonio', to_date('25-JUN-2017', 'DD-MON-YYYY'), to_date('29-JUN-2017', 'DD-MON-YYYY'), 'Y');
  PRO seed ks_event_tracks

SET DEFINE OFF;

-- Insert tracks for events (All for Kscope17, APEX only for Kscope16)
insert into ks_event_tracks (event_id, display_seq, name, alias, active_ind)
select e.id, t.display_seq, t.name, t.alias, t.active_ind
  from ks_tracks t
     , ks_events e
 where t.active_ind = 'Y'
   and e.active_ind = 'Y'
   -- and ((e.name = 'Kscope16' and t.alias = 'APEX') 
   --    or e.name = 'Kscope17'
   -- )
/
prompt seed constraint_lookup

SET DEFINE OFF;
insert into constraint_lookup (constraint_name,message) values ('KS_USERS_U01','User already exists.');
insert into constraint_lookup (constraint_name,message) values ('KS_USERS_U02','Email already exists.');
insert into constraint_lookup (constraint_name,message) values ('KS_SESSIONS_U01','Session already exists.');
insert into constraint_lookup (constraint_name,message) values ('KS_TRACKS_U01','Track already exists.');
--  Install Code -----------------------------
create or replace package ks_tags_api
is
        
---
--- Tag Synchronisation Procedure
---
procedure tag_sync (
    p_new_tags          in varchar2,
    p_old_tags          in varchar2,
    p_content_type      in varchar2,
    p_content_id        in number );

procedure maintain_filter_coll(
       p_coll   in varchar2
     , p_sub    in varchar2 := null
     , p_id     in varchar2
     , p_status in varchar2 := 'NO');

end ks_tags_api;
/
create or replace package ks_sec
is

C_AUTH_SUCCESS            number := 0;
C_AUTH_UNKNOWN_USER       number := 1;
C_AUTH_ACCOUNT_LOCKED     number := 2;
C_AUTH_ACCOUNT_EXPIRED    number := 3;
C_AUTH_PASSWORD_INCORRECT number := 4;
C_AUTH_PASSWORD_FIRST_USE number := 5;
C_AUTH_ATTEMPTS_EXCEEDED  number := 6;
C_AUTH_INTERNAL_ERROR     number := 7;


subtype salt_type               is varchar2(16);
subtype password_type           is varchar2(128);
subtype password_with_salt_type is varchar2(145); --Length of salt and password, plus 1 character seperator


function is_valid_user (
       p_username IN varchar2
     , p_password IN varchar2
)
   return boolean;

function password_with_salt (p_password IN varchar2)
   return varchar2;

procedure post_login;
 
end ks_sec;
/
create or replace package ks_api
is

--------------------------------------------------------------------------------
--*
--* API Messages
--*
--------------------------------------------------------------------------------
type message_rec_type is record (
    message_text  varchar2(4000)
  , severity      varchar2(1)
);

type message_tbl_type
  is table of message_rec_type
  index by binary_integer;

subtype result_status_type is varchar2(1);
subtype gt_string is varchar2(32767);

--------------------------------------------------------------------------------
--*
--* Operations
--*
--------------------------------------------------------------------------------
g_opr_create  CONSTANT VARCHAR2(10) := 'CREATE';
g_opr_update  CONSTANT VARCHAR2(10) := 'UPDATE';
g_opr_delete  CONSTANT VARCHAR2(10) := 'DELETE';
g_opr_none    CONSTANT VARCHAR2(10) := 'NONE';

--------------------------------------------------------------------------------
--*
--* Return statuses
--*
--------------------------------------------------------------------------------
g_ret_sts_success     CONSTANT result_status_type := 'S';
g_ret_sts_error       CONSTANT result_status_type := 'E';
g_ret_sts_unexp_error CONSTANT result_status_type := 'U';

--------------------------------------------------------------------------------
--*
--* "Missing" values
--* These values are used to differentiate between NULLs and values
--* that are not provided.
--*
--------------------------------------------------------------------------------
g_miss_num  CONSTANT NUMBER       := 9.99E125;
g_miss_char CONSTANT VARCHAR2(1)  := chr(0);
g_miss_date CONSTANT DATE         := to_date('1','j');

--------------------------------------------------------------------------------
c_crlf      constant varchar2(30) := chr(13)||chr(10);

--------------------------------------------------------------------------------
--*
--* Exceptions
--*
--------------------------------------------------------------------------------
e_api_error        exception;
e_api_unexp_error  exception;

--------------------------------------------------------------------------------
procedure add_message(p_msg          in out NOCOPY ks_api.message_tbl_type
                    , p_message_text in VARCHAR2
                    , p_severity     in VARCHAR2 DEFAULT 'E');

--------------------------------------------------------------------------------
function format_error_messages(
    p_messages_tbl  in out NOCOPY ks_api.message_tbl_type
  , p_sep           in varchar2 default '<br>'
)
return varchar2;

--------------------------------------------------------------------------------
procedure set_page_errors(
    p_messages_tbl     in out NOCOPY ks_api.message_tbl_type
  , p_display_location in varchar2 default apex_error.c_inline_in_notification
);

end ks_api;
/
create or replace package ks_util
as

--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2;

--------------------------------------------------------------------------------
procedure set_param(
    p_name_key  in ks_parameters.name_key%TYPE
  , p_value     in ks_parameters.value%TYPE
);


--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2;


--------------------------------------------------------------------------------
function format_full_name 
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2;


--------------------------------------------------------------------------------
function is_number
(
  p_value        in         varchar2
) return boolean;

--------------------------------------------------------------------------------
function string_to_coll (p_string in varchar2) return sys.ODCIVarchar2List;

--------------------------------------------------------------------------------
function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         ) 
  return varchar2;

--------------------------------------------------------------------------------
function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report;


end ks_util;
/
create or replace package ks_error_handler
AS

/*
 * Use with:
 * ks_error_handler.error_handler_logging_session
 *
 */
  --============================================================================
  -- B A S I C   E R R O R   D U M P
  --============================================================================
FUNCTION basic_error_dump(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result;
  --============================================================================
  -- B A S I C   E R R O R   H A N D L E R
  --============================================================================
FUNCTION basic_error_handler(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result;
  --============================================================================
  -- B A S I C   E R R O R   H A N D L E R   W I T H   L O O K U P
  --============================================================================
FUNCTION basic_error_lookup(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result;
  --============================================================================
  -- E R R O R   H A N D L E R  -  L O G G I N G
  --============================================================================
FUNCTION error_handler_logging(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result;
  --============================================================================
  -- E R R O R   H A N D L E R  -  L O G G I N G  &  S E S S I O N   S T A T E
  --============================================================================
FUNCTION error_handler_logging_session(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result;
    --============================================================================
  -- F O R C E   P L / S Q L   E R R O R   
  --============================================================================
PROCEDURE force_plsql_error;
END ks_error_handler;
/
create or replace package ks_session_load_api
is

--------------------------------------------------------------------------------
--*
--* 
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
procedure load_sessions(
    p_app_user       in ks_users.username%TYPE
  , p_into_event_id  in ks_event_tracks.event_id%TYPE
  , p_into_track_id  in ks_event_tracks.id%TYPE);


end ks_session_load_api;
/
create or replace package ks_session_api
is

--------------------------------------------------------------------------------
--*
--* 
--*
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter in ks_sessions.presenter%TYPE);


end ks_session_api;
/

PROMPT ks_tags_api body
create or replace package body ks_tags_api
is
        
--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

---
--- Tag Synchronisation Procedure
---
procedure tag_sync (
    p_new_tags          in varchar2,
    p_old_tags          in varchar2,
    p_content_type      in varchar2,
    p_content_id        in number )
as
  -- l_scope  logger_logs.scope%type := gc_scope_prefix || 'tag_sync';
  -- l_params logger.tab_param;

    type tags is table of varchar2(255) index by varchar2(255);
    l_new_tags_a    tags;
    l_old_tags_a    tags;
    l_new_tags      apex_application_global.vc_arr2;
    l_old_tags      apex_application_global.vc_arr2;
    l_merge_tags    apex_application_global.vc_arr2;
    l_dummy_tag     varchar2(255);
    i               integer;


begin
  -- we call tag_sync form a trigger, so lets not call logger unless we need to.
  -- logger.append_param(l_params, 'p_option_name', p_option_name);
  -- logger.log('START', l_scope, null, l_params);

    l_old_tags := apex_util.string_to_table(p_old_tags,':');
    l_new_tags := apex_util.string_to_table(p_new_tags,':');
    if l_old_tags.count > 0 then --do inserts and deletes
        --build the associative arrays
        for i in 1..l_old_tags.count loop
            l_old_tags_a(l_old_tags(i)) := l_old_tags(i);
        end loop;
        for i in 1..l_new_tags.count loop
            l_new_tags_a(l_new_tags(i)) := l_new_tags(i);
        end loop;
        --do the inserts
        for i in 1..l_new_tags.count loop
            begin
                l_dummy_tag := l_old_tags_a(l_new_tags(i));
            exception when no_data_found then
                insert into ks_tags (tag, content_id, content_type )
                    values (l_new_tags(i), p_content_id, p_content_type );
                l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
            end;
        end loop;
        --do the deletes
        for i in 1..l_old_tags.count loop
            begin
                l_dummy_tag := l_new_tags_a(l_old_tags(i));
            exception when no_data_found then
                delete from ks_tags where content_id = p_content_id and tag = l_old_tags(i);
                l_merge_tags(l_merge_tags.count + 1) := l_old_tags(i);
            end;
        end loop;
    else --just do inserts
        for i in 1..l_new_tags.count loop
            insert into ks_tags (tag, content_id, content_type )
                values (l_new_tags(i), p_content_id, p_content_type );
            l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
        end loop;
    end if;
    for i in 1..l_merge_tags.count loop
        merge into ks_tag_type_sums s
        using (select count(*) tag_count
                 from ks_tags
                where tag = l_merge_tags(i) and content_type = p_content_type ) t
           on (s.tag = l_merge_tags(i) and s.content_type = p_content_type )
         when not matched then insert (tag, content_type, tag_count)
                               values (l_merge_tags(i), p_content_type, t.tag_count)
         when matched then update set s.tag_count = t.tag_count;
        merge into ks_tag_sums s
        using (select sum(tag_count) tag_count
                 from ks_tag_type_sums
                where tag = l_merge_tags(i) ) t
           on (s.tag = l_merge_tags(i) )
         when not matched then insert (tag, tag_count)
                               values (l_merge_tags(i), t.tag_count)
         when matched then update set s.tag_count = t.tag_count;
    end loop;
end tag_sync;

/*******************************************************************
 * Maintain the collection elements when using search filters
 *   p_coll: collection_name
 *    p_sub: Optional sub level/area for the tags.
 *     p_id: ID being managed
 * p_status: YES/NO is the element checked (YES) or un-checked (NO)
 *******************************************************************/
procedure maintain_filter_coll(
       p_coll   in varchar2
     , p_sub    in varchar2 := null
     , p_id     in varchar2
     , p_status in varchar2 := 'NO')
is
  l_seq_id number;
begin

  /*
  The collections being used:
    SESSIONTAGFILTER: For Session (abstract) filters
  */

  if p_coll in ('SESSIONTAGFILTER') then
    -- is this the top level selection
    if p_id = 'top' then

      -- Because it's the top level, empty the collection
      if apex_collection.collection_exists(p_coll) then
        apex_collection.truncate_collection(p_coll);
      else
        apex_collection.create_collection(p_coll);
      end if;

      -- the collection is already empty, but if the status
      -- is YES then we need to populate ALL of the elmemnts
      if p_status = 'YES' then
        for i in (
          select tag id from ks_tag_type_sums where content_type='SESSION' || nvl2(p_sub, ':' || p_sub, '') and p_coll = 'SESSIONTAGFILTER'
          )
        loop
          apex_collection.add_member(p_coll, p_c001 => i.id);
        end loop;
      end if;

    else
      -- We're dealing with a single element

      -- Create the collection if it doesn't exist.
      if not apex_collection.collection_exists(p_coll) then
          apex_collection.create_collection(p_coll);
      end if;

      -- The element was checked so add it
      if p_status = 'YES' then
          apex_collection.add_member(p_coll, p_c001 => p_id);
      else

        -- the element was unchecked so remove it.
        begin
        select seq_id
          into l_seq_id
          from apex_collections
         where collection_name = p_coll
           and c001 = p_id;

          apex_collection.delete_member(p_coll, l_seq_id);
        exception
        when NO_DATA_FOUND then
          null;
        end;
      end if;

    end if;
  end if;

end maintain_filter_coll;


end ks_tags_api;
/
set define off
create or replace PACKAGE BODY ks_error_handler
AS
--============================================================================
-- B A S I C   E R R O R   D U M P
--============================================================================
FUNCTION basic_error_dump(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
  l_test varchar2(32767);
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
        l_result.message := 'Here''s the full error details:<p/>'||
                            '<PRE>'||
                            '<BR/><B>          MESSAGE:</B> '||p_error.message||
                            '<BR/><B>  Additional Info:</B> '||p_error.additional_info||
                            '<BR/><B> Display Location:</B> '||p_error.display_location||
                            '<BR/><B> Association_Type:</B> '||p_error.Association_type||
                            '<BR/><B>   Page Item Name:</B> '||p_error.page_item_name||
                            '<BR/><B>        Region ID:</B> '||p_error.region_id||
                            '<BR/><B>     Column Alias:</B> '||p_error.column_alias||
                            '<BR/><B>          Row Num:</B> '||p_error.row_num||
                            '<BR/><B>Is Internal Error:</B> '||case when p_error.is_internal_error = TRUE 
                                                        THEN 'True'
                                                        ELSE 'False'
                                                   end||
                            '<BR/><B>  APEX ERROR CODE:</B> '||p_error.apex_error_code||
                            '<BR/><B>      ora_sqlcode:</B> '||p_error.ora_sqlcode||
                            '<BR/><B>      ora_sqlerrm:</B> '||p_error.ora_sqlerrm||
                            '<BR/><B>  Error Backtrace:</B><BR/>'||p_error.error_backtrace||
                            '<BR/><B>   Component.type:</B> '||p_error.component.type||
                            '<BR/><B>     Component.id:</B> '||p_error.component.id||
                            '<BR/><B>   Component.name:</B> '||p_error.component.name||
                            '<BR/><B>  First Error Text:</B> '||apex_error.get_first_ora_error_text ( p_error => p_error )||
                            '<BR/><B>   Application ID:</B> '||v('APP_ID')||
                            '<BR/><B>          Page ID:</B> '||v('APP_PAGE_ID')||'<P/><pre/>' ;
             
-- Now return the result record to the caller.
  
  RETURN l_result;
END basic_error_dump;
--============================================================================
-- B A S I C   E R R O R   H A N D L E R
--============================================================================
FUNCTION basic_error_handler(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
  -- Look at the error that was encountered. Is it an "internal" error?
  IF p_error.is_internal_error then
     -- If it is, then it may contain information that could give away clues to the 
     -- database structure.
     -- 
     -- However the errors for Authorization Checks should be fine... So if it's 
     -- anything BUT an authroization Check, we need to re-write the error 
     IF p_error.apex_error_code <> 'APEX.AUTHORIZATION.ACCESS_DENIED' then
 
     
        -- We'll try to construct an error that has good information 
        -- but doesn't give away any info into the DB Structure
        --
        l_result.message := 'We''re Sorry. An unexpected error has occurred. '||
                            'Please note the following information and contact the help desk:<p/>'||
                            '<PRE/>'||
                            '<BR/> Application ID: '||v('APP_ID')||
                            '<BR/>        Page ID: '||v('APP_PAGE_ID')||
                            '<BR/>APEX ERROR CODE: '||p_error.apex_error_code||
                            '<BR/>    ora_sqlcode: '||p_error.ora_sqlcode||
                            '<BR/>    ora_sqlerrm: '||p_error.ora_sqlerrm||
                            '</PRE>' ;
     END IF;
  ELSE 
    -- It's NOT an internal error, so we need to handle it.
    --
    -- First lets reset the place where it's going to display
    -- If at all possible we want to get away from the ugly error page scenario.
    -- 
    l_result.display_location :=
      CASE 
         -- If the error is supposed to be displayed on an error page
         WHEN l_result.display_location = apex_error.c_on_error_page 
           -- Then let's put it back inline
           THEN apex_error.c_inline_in_notification
         -- Otherwise keep it as defined.
         ELSE l_result.display_location
      END;
 
      -- If it was an ORA error that was raised
      -- we'll present the error text of to the end user in a nicer format.
      -- 
      -- To do this we'll get the "First Error Text" using the APEX_ERROR API
        
      IF p_error.ora_sqlcode IS NOT NULL then
            l_result.message := apex_error.get_first_ora_error_text (
                                    p_error => p_error );
      END IF;
      
      -- We can also use the APEX_ERROR API to automatically find the 
      -- item the error was associated with, IF they're not already set.
      if l_result.page_item_name is null and l_result.column_alias is null then
            apex_error.auto_set_associated_item (
                p_error        => p_error,
                p_error_result => l_result );
        end if;
      
      
   END IF;      
                            
-- Now return the result record to the caller.
  
  RETURN l_result;
END basic_error_handler;
--============================================================================
-- B A S I C   E R R O R   H A N D L E R   W I T H   L O O K U P
--============================================================================
FUNCTION basic_error_lookup(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
  l_constraint_name varchar2(255);
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
  -- Look at the error that was encountered. Is it an "internal" error?
  IF p_error.is_internal_error then
     -- If it is, then it may contain information that could give away clues to the 
     -- database structure.
     -- 
     -- However the errors for Authorization Checks should be fine... So if it's 
     -- anything BUT an authroization check, we need to re-write the error 
     IF p_error.apex_error_code <> 'APEX.AUTHORIZATION.ACCESS_DENIED' then
     
        
        -- We'll try to construct an error that has good information 
        -- but doesn't give away any info into the DB Structure
        --
        l_result.message := 'We''re Sorry. An unexpected error has occurred. '||
                            'Please note the following information and contact the help desk:<p/>'||
                            '<PRE/>'||
                            '<BR/> Application ID: '||v('APP_ID')||
                            '<BR/>        Page ID: '||v('APP_PAGE_ID')||
                            '<BR/>APEX ERROR CODE: '||p_error.apex_error_code||
                            '<BR/>    ora_sqlcode: '||p_error.ora_sqlcode||
                            '<BR/>    ora_sqlerrm: '||p_error.ora_sqlerrm||
                            '</PRE>';
     END IF;
  ELSE 
    -- It's NOT an internal error, so we need to handle it.
    --
    -- First lets reset the place where it's going to display
    -- If at all possible we want to get away from the ugly error page scenario.
    -- 
    l_result.display_location :=
      CASE 
         -- If the error is supposed to be displayed on an error page
         WHEN l_result.display_location = apex_error.c_on_error_page 
           -- Then let's put it back inline
           THEN apex_error.c_inline_in_notification
         -- Otherwise keep it as defined.
         ELSE l_result.display_location
      END;
 
      -- If it is an ORA error that was raised lets do our best to figure it out
      -- and present the error text of to the end user in a nicer format.
      -- 
      -- To do this we'll get the "First Error Text" using the APEX_ERROR API
        
      IF p_error.ora_sqlcode IS NOT NULL then
      
            -- If it's a constraint violation then we'll try to get a matching "friendly" message from our 
            -- Lookup table. Below is a reference of common constraint violations you may want to handle.
            --
            --   -) ORA-00001: unique constraint violated
            --   -) ORA-02091: transaction rolled back (-> can hide a deferred constraint)
            --   -) ORA-02290: check constraint violated
            --   -) ORA-02291: integrity constraint violated - parent key not found
            --   -) ORA-02292: integrity constraint violated - child record found
            --
            IF p_error.ora_sqlcode in (-1, -2091, -2290, -2291, -2292) then
            -- Get the contraint name 
            l_constraint_name := apex_error.extract_constraint_name ( p_error => p_error );
            -- Use that constraint name to see if we have a translation for it in our table.
            begin
                select message
                  into l_result.message
                  from constraint_lookup
                 where constraint_name = l_constraint_name;
            exception 
                 when no_data_found 
                 then null; 
            end;
            ELSE
               -- Lets check some common error codes here... 
             l_result.message :=
              case 
                  when p_error.ora_sqlcode = -1407
                  then 'Trying to insert a null value into a not null column.'
                  --WHEN p_error.ora_sqlcode =  -12899
                  --THEN 'The value you entered was to large for the field. Please try again.'
               else
                  apex_error.get_first_ora_error_text (p_error => p_error )
               end;
            end if;
      
      ELSE
            --l_result.message := apex_error.get_first_ora_error_text (p_error => p_error );
            null;
      END IF;
      
      -- We can also use the APEX_ERROR API to automatically find the 
      -- item the error was associated with, IF they're not already set.
      if l_result.page_item_name is null and l_result.column_alias is null then
            apex_error.auto_set_associated_item (
                p_error        => p_error,
                p_error_result => l_result );
        end if;
      
      
   END IF;   
                            
-- Now return the result record to the caller.
  
  RETURN l_result;
END basic_error_lookup;
--============================================================================
-- E R R O R   H A N D L E R  -  L O G G I N G
--============================================================================
FUNCTION error_handler_logging(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
  l_constraint_name varchar2(255);
  l_logger_message varchar2(4000);
  l_logger_scope   varchar2(1000);
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
  -- Look at the error that was encountered. Is it an "internal" error?
  IF p_error.is_internal_error then
     -- If it is, then it may contain information that could give away clues to the 
     -- database structure.
     -- 
     -- However the errors for Authorization Checks should be fine... So if it's 
     -- anything BUT an authroization check, we need to re-write the error 
     IF p_error.apex_error_code <> 'APEX.AUTHORIZATION.ACCESS_DENIED' then
     
        
        -- We'll try to construct an error that has good information 
        -- but doesn't give away any info into the DB Structure
        --
        l_result.message := 'We''re Sorry. An unexpected error has occurred. '||
                            'Please note the following information and contact the help desk:<p/>'||
                            '<PRE/>'||
                            '<BR/> Application ID: '||v('APP_ID')||
                            '<BR/>        Page ID: '||v('APP_PAGE_ID')||
                            '<BR/>APEX ERROR CODE: '||p_error.apex_error_code||
                            '<BR/>    ora_sqlcode: '||p_error.ora_sqlcode||
                            '<BR/>    ora_sqlerrm: '||p_error.ora_sqlerrm||
                            '</PRE>';
     END IF;
  ELSE 
    -- It's NOT an internal error, so we need to handle it.
    --
    -- First lets reset the place where it's going to display
    -- If at all possible we want to get away from the ugly error page scenario.
    -- 
    l_result.display_location :=
      CASE 
         -- If the error is supposed to be displayed on an error page
         WHEN l_result.display_location = apex_error.c_on_error_page 
           -- Then let's put it back inline
           THEN apex_error.c_inline_in_notification
         -- Otherwise keep it as defined.
         ELSE l_result.display_location
      END;
 
      -- If it is an ORA error that was raised lets do our best to figure it out
      -- and present the error text of to the end user in a nicer format.
      -- 
      -- To do this we'll get the "First Error Text" using the APEX_ERROR API
        
      IF p_error.ora_sqlcode IS NOT NULL then
      
            -- If it's a constraint violation then we'll try to get a matching "friendly" message from our 
            -- Lookup table. Below is a reference of common constraint violations you may want to handle.
            --
            --   -) ORA-00001: unique constraint violated
            --   -) ORA-02091: transaction rolled back (-> can hide a deferred constraint)
            --   -) ORA-02290: check constraint violated
            --   -) ORA-02291: integrity constraint violated - parent key not found
            --   -) ORA-02292: integrity constraint violated - child record found
            --
            IF p_error.ora_sqlcode in (-1, -2091, -2290, -2291, -2292) then
              -- Get the contraint name 
              l_constraint_name := apex_error.extract_constraint_name ( p_error => p_error );
              -- Use that constraint name to see if we have a translation for it in our table.
              begin
                  select message
                    into l_result.message
                    from constraint_lookup
                   where constraint_name = l_constraint_name;
              exception 
                   when no_data_found 
                   then null; 
              end;
            ELSE
               -- Lets check some common error codes here... 
             l_result.message :=
              CASE 
                  WHEN p_error.ora_sqlcode = -1407
                  THEN 'Trying to insert a null value into a not null column.'
                  --WHEN p_error.ora_sqlcode =  -12899
                  --THEN 'The value you entered was too large for the field. Please try again.'
               ELSE 
                  apex_error.get_first_ora_error_text (
                                    p_error => p_error )
               end;
            end if;
      
      ELSE
            --l_result.message := apex_error.get_first_ora_error_text (p_error => p_error );
            null;
      END IF;
      
      -- We can also use the APEX_ERROR API to automatically find the 
      -- item the error was associated with, IF they're not already set.
      if l_result.page_item_name is null and l_result.column_alias is null then
            apex_error.auto_set_associated_item (
                p_error        => p_error,
                p_error_result => l_result );
        end if;
      
      
   END IF;   
   
-- LAST thing we do before returning is log the error     
--
-- LOG THE UNKNOWN ERROR IN THE LOGGER TABLES
--
-- First build the log message
l_logger_message  := 'Here''s the full error details:<p/>'||
            '<PRE>'||
            '<BR/><B>          MESSAGE:</B> '||p_error.message||
            '<BR/><B>  Additional Info:</B> '||p_error.additional_info||
            '<BR/><B> Display Location:</B> '||p_error.display_location||
            '<BR/><B> Association_Type:</B> '||p_error.Association_type||
            '<BR/><B>   Page Item Name:</B> '||p_error.page_item_name||
            '<BR/><B>        Region ID:</B> '||p_error.region_id||
            '<BR/><B>     Column Alias:</B> '||p_error.column_alias||
            '<BR/><B>          Row Num:</B> '||p_error.row_num||
            '<BR/><B>Is Internal Error:</B> '||case when p_error.is_internal_error = TRUE 
                                        THEN 'True'
                                        ELSE 'False'
                                   end||
            '<BR/><B>  APEX ERROR CODE:</B> '||p_error.apex_error_code||
            '<BR/><B>      ora_sqlcode:</B> '||p_error.ora_sqlcode||
            '<BR/><B>      ora_sqlerrm:</B> '||p_error.ora_sqlerrm||
            '<BR/><B>  Error Backtrace:</B><BR/>'||p_error.error_backtrace||
            '<BR/><B>   Component.type:</B> '||p_error.component.type||
            '<BR/><B>     Component.id:</B> '||p_error.component.id||
            '<BR/><B>   Component.name:</B> '||p_error.component.name||
            '<BR/><B> First Error Text:</B> '||apex_error.get_first_ora_error_text ( p_error => p_error )||
            '<BR/><B>   Application ID:</B> '||v('APP_ID')||
            '<BR/><B>          Page ID:</B> '||v('APP_PAGE_ID')||'<P/><pre/>' ;
-- Generate a SCOPE string for logger so we can get a handle back on it
-- Format   YYYY-MM-DD HH24.MI.SS:USER:APP:PAGE:SESSION
--
l_logger_scope := to_char(sysdate,'YYYY-MM-DD HH24.MI.SS')||':'||v('APP_USER')||':'||v('APP_ID')||':'||v('APP_PAGE_ID')||':'||v('APP_SESSION');
-- Now create the log entry as an error so it captures the error stack.
-- but remove the HTML
l_logger_message := replace(l_logger_message, '<BR/>', chr(10));
-- logger.log_error(p_text => l_logger_message, p_scope => l_logger_scope);
                            
-- Now return the result record to the caller.
 
  RETURN l_result;
END error_handler_logging;
--============================================================================
-- E R R O R   H A N D L E R  -  L O G G I N G  &  S E S S I O N   S T A T E
--============================================================================
FUNCTION error_handler_logging_session(
    p_error IN apex_error.t_error )
  RETURN apex_error.t_error_result
AS
  l_result apex_error.t_error_result;
  l_constraint_name varchar2(255);
  l_logger_message varchar2(4000);
  l_logger_scope   varchar2(1000);
BEGIN
  -- The first thing we need to do is initialize the result variable.
  l_result := apex_error.init_error_result ( p_error => p_error );
  
  -- Look at the error that was encountered. Is it an "internal" error?
  IF p_error.is_internal_error then
     -- If it is, then it may contain information that could give away clues to the 
     -- database structure.
     -- 
     -- However the errors for Authorization Checks should be fine... So if it's 
     -- anything BUT an authroization check, we need to re-write the error 
     -- Oh and if the session expired, don't report it as an error.
     IF p_error.apex_error_code = 'APEX.SESSION.EXPIRED' then -- added for APEX5
        -- Keep the error, but add more to it. And capture with logger below (for now).
        -- Redirect to Home Page after 1.5 second.
        l_result.message := p_error.message
            || '<script>setTimeout(function(){location.href="f?p=' || v('APP_ID') || '";},1500);</script>';
        -- leave the additional_info alone.
        -- l_result.additional_info := '';
     ELSIF p_error.apex_error_code <> 'APEX.AUTHORIZATION.ACCESS_DENIED' then
     
        
        -- We'll try to construct an error that has good information 
        -- but doesn't give away any info into the DB Structure
        --
        l_result.message := 'We''re Sorry. An unexpected error has occurred. '||
                            'Please note the following information and contact the help desk:<p/>'||
                            '<PRE/>'||
                            '<BR/> Application ID: '||v('APP_ID')||
                            '<BR/>        Page ID: '||v('APP_PAGE_ID')||
                            '<BR/>APEX ERROR CODE: '||p_error.apex_error_code||
                            '<BR/>    ora_sqlcode: '||p_error.ora_sqlcode||
                            '<BR/>    ora_sqlerrm: '||p_error.ora_sqlerrm||
                            '</PRE>';
     END IF;
  ELSE 
    -- It's NOT an internal error, so we need to handle it.
    --
    -- First lets reset the place where it's going to display
    -- If at all possible we want to get away from the ugly error page scenario.
    -- 
    l_result.display_location :=
      CASE 
         -- If the error is supposed to be displayed on an error page
         WHEN l_result.display_location = apex_error.c_on_error_page 
           -- Then let's put it back inline
           THEN apex_error.c_inline_in_notification
         -- Otherwise keep it as defined.
         ELSE l_result.display_location
      END;
 
      -- If it is an ORA error that was raised lets do our best to figure it out
      -- and present the error text of to the end user in a nicer format.
      -- 
      -- To do this we'll get the "First Error Text" using the APEX_ERROR API
        
      IF p_error.ora_sqlcode IS NOT NULL then
      
            -- If it's a constraint violation then we'll try to get a matching "friendly" message from our 
            -- Lookup table. Below is a reference of common constraint violations you may want to handle.
            --
            --   -) ORA-00001: unique constraint violated
            --   -) ORA-02091: transaction rolled back (-> can hide a deferred constraint)
            --   -) ORA-02290: check constraint violated
            --   -) ORA-02291: integrity constraint violated - parent key not found
            --   -) ORA-02292: integrity constraint violated - child record found
            --
            IF p_error.ora_sqlcode in (-1, -2091, -2290, -2291, -2292) then
              -- Get the contraint name 
              l_constraint_name := apex_error.extract_constraint_name ( p_error => p_error );
              -- Use that constraint name to see if we have a translation for it in our table.
              begin
                  select message
                    into l_result.message
                    from constraint_lookup
                   where constraint_name = l_constraint_name;
              exception 
                   when no_data_found 
                   then null;
              end;
            ELSE
               -- Lets check some common error codes here... 
             l_result.message :=
              case 
                  when p_error.ora_sqlcode = -1407 THEN
                   'Trying to insert a null value into a not null column.'
                  --WHEN p_error.ora_sqlcode =  -12899
                  --THEN 'The value you entered was to large for the field. Please try again.'
               else 
                  apex_error.get_first_ora_error_text (
                                    p_error => p_error )
               end;
            end if;
      
      ELSE
            --l_result.message := apex_error.get_first_ora_error_text (p_error => p_error );
            null;
      END IF;
      
      -- We can also use the APEX_ERROR API to automatically find the 
      -- item the error was associated with, IF they're not already set.
      if l_result.page_item_name is null and l_result.column_alias is null then
            apex_error.auto_set_associated_item (
                p_error        => p_error,
                p_error_result => l_result );
        end if;
      
      
   END IF;   
   
  -- LAST thing we do before returning is log the error     
  --
  -- LOG THE UNKNOWN ERROR IN THE LOGGER TABLES
  --
  -- First build the log message
  l_logger_message  := 'Here''s the full error details:<p/>'||
              '<PRE>'||
              '<BR/><B>          MESSAGE:</B> '||p_error.message||
              '<BR/><B>  Additional Info:</B> '||p_error.additional_info||
              '<BR/><B> Display Location:</B> '||p_error.display_location||
              '<BR/><B> Association_Type:</B> '||p_error.Association_type||
              '<BR/><B>   Page Item Name:</B> '||p_error.page_item_name||
              '<BR/><B>        Region ID:</B> '||p_error.region_id||
              '<BR/><B>     Column Alias:</B> '||p_error.column_alias||
              '<BR/><B>          Row Num:</B> '||p_error.row_num||
              '<BR/><B>Is Internal Error:</B> '||case when p_error.is_internal_error = TRUE 
                                          THEN 'True'
                                          ELSE 'False'
                                     end||
              '<BR/><B>  APEX ERROR CODE:</B> '||p_error.apex_error_code||
              '<BR/><B>      ora_sqlcode:</B> '||p_error.ora_sqlcode||
              '<BR/><B>      ora_sqlerrm:</B> '||p_error.ora_sqlerrm||
              '<BR/><B>  Error Backtrace:</B><BR/>'||p_error.error_backtrace||
              '<BR/><B>   Component.type:</B> '||p_error.component.type||
              '<BR/><B>     Component.id:</B> '||p_error.component.id||
              '<BR/><B>   Component.name:</B> '||p_error.component.name||
              '<BR/><B> First Error Text:</B> '||apex_error.get_first_ora_error_text ( p_error => p_error )||
              '<BR/><B>   Application ID:</B> '||v('APP_ID')||
              '<BR/><B>          Page ID:</B> '||v('APP_PAGE_ID')||'<P/><pre/>' ;
  -- Generate a SCOPE string for logger so we can get a handle back on it
  -- Format   YYYY-MM-DD HH24.MI.SS:USER:APP:PAGE:SESSION
  --
  l_logger_scope := to_char(sysdate,'YYYY-MM-DD HH24.MI.SS')||':'||v('APP_USER')||':'||v('APP_ID')||':'||v('APP_PAGE_ID')||':'||v('APP_SESSION');
  -- Now create the log entry as an error so it captures the error stack.
  -- but remove the HTML
  l_logger_message := replace(l_logger_message, '<BR/>', chr(10));
  l_logger_message := replace(replace(l_logger_message, '<B>', '*'), '</B>', '*');
  -- logger.log_apex_items(p_text => l_logger_message, p_scope => l_logger_scope);
                              
  -- Now return the result record to the caller.
 
  RETURN l_result;
END error_handler_logging_session;


--============================================================================
-- F O R C E   P L / S Q L   E R R O R   
--============================================================================
PROCEDURE force_plsql_error
AS
    l_NUMBER number;
BEGIN
  l_number := 1/0;
END force_plsql_error;


end ks_error_handler;
/
set define off
-- alter session set PLSQL_CCFLAGS='CRYPTO_AVAILABLE:TRUE';
create or replace package body ks_sec
is

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

/*****************************************************************************/
g_salt salt_type := 'rQ/PfG?Z8(C*4RP';
/*****************************************************************************/

/**
 * Validate a given user and password
 *
 * 
 *
 * @author Jorge Rimblas
 * @created September 2, 2016
 * @param p_username case insensitive username
 * @param p_password case sensitive password for the user login in
 * @return true/false
 */
function is_valid_user (
       p_username IN varchar2
     , p_password IN varchar2
)
   return boolean
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'load_sessions';
  -- l_params logger.tab_param;

  l_retval           boolean := FALSE;
  l_old_pass_w_salt  password_with_salt_type;
  l_old_pass_hash    password_type;
  l_new_pass_hash    password_type;
  l_salt             salt_type;
  l_active_ind       ks_users.active_ind%TYPE;

begin

   select password, active_ind
     into l_old_pass_w_salt
        , l_active_ind
     from ks_users
    where username = upper(p_username);

   if l_active_ind = 'Y' then
      l_old_pass_hash := SUBSTR(l_old_pass_w_salt, 1, INSTR(l_old_pass_w_salt, ':') - 1);
      l_salt := SUBSTR(l_old_pass_w_salt, INSTR(l_old_pass_w_salt, ':') + 1);

      $IF $$CRYPTO_AVAILABLE $THEN
      l_new_pass_hash := RAWTOHEX(dbms_crypto.hash(
         src => utl_raw.cast_to_raw(g_salt || p_password || l_salt),
         typ => dbms_crypto.HASH_SH512
      ));
      $ELSE
      -- old 
      -- 
      l_new_pass_hash := RAWTOHEX(dbms_obfuscation_toolkit.md5(
         input => utl_raw.cast_to_raw(g_salt || p_password || l_salt)
      ));
      $END

      l_retval := l_new_pass_hash = l_old_pass_hash;

      if l_retval then
        apex_util.set_authentication_result (p_code => C_AUTH_SUCCESS);
      else
        apex_util.set_authentication_result (p_code => C_AUTH_PASSWORD_INCORRECT);
      end if;

   else
     apex_util.set_authentication_result (p_code => C_AUTH_ACCOUNT_LOCKED);
   end if;

   return l_retval;

exception

  when NO_DATA_FOUND then
    -- Set APEX authentication Codes
    apex_util.set_authentication_result (p_code => C_AUTH_UNKNOWN_USER);
    return l_retval;

end is_valid_user;





/*****************************************************************************/
function password_with_salt (p_password IN varchar2)
   return varchar2
is
   l_retval password_with_salt_type;
   l_salt   salt_type;
begin

   l_salt := SUBSTR(SYS_GUID(), 1, 16);

   $IF $$CRYPTO_AVAILABLE $THEN
   l_retval := RAWTOHEX(dbms_crypto.hash(
      src => utl_raw.cast_to_raw(g_salt || p_password || l_salt),
      typ => dbms_crypto.HASH_SH512
   ));
   $ELSE
   l_retval := RAWTOHEX(dbms_obfuscation_toolkit.md5(
      input => utl_raw.cast_to_raw(g_salt || p_password || l_salt)
   ));
   $END

   l_retval := l_retval || ':' || l_salt;

   return l_retval;

end password_with_salt;




/**
 * Sets enrionmonet after user successfully logs in.
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param
 * @return
 */
procedure post_login
is
  -- l_scope  logger_logs.scope%type := gc_scope_prefix || 'post_login';
  -- l_params logger.tab_param;
begin
  -- logger.append_param(l_params, 'p_param1', p_param1);
  -- logger.log('BEGIN', l_scope, null, l_params);

  apex_util.set_session_state(
      p_name  => 'G_ADMIN'
    , p_value => case when apex_authorization.is_authorized('ADMIN') then 'YES' else 'NO' end
  );

  -- logger.log('END', l_scope, null, l_params);

  exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end post_login;

end ks_sec;
/
create or replace package body ks_api
is

--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';



--------------------------------------------------------------------------------
--*
--* Add messages to the queue
--*
procedure add_message(p_msg          in out NOCOPY ks_api.message_tbl_type
                    , p_message_text in VARCHAR2
                    , p_severity     in VARCHAR2 DEFAULT 'E')
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'add_message';
  -- l_params logger.tab_param;
  l_index  PLS_INTEGER;
begin
  -- logger.append_param(l_params, 'p_message_text', p_message_text);

  l_index := p_msg.COUNT + 1;
  p_msg(l_index).message_text := p_message_text;
  p_msg(l_index).severity := p_severity;

  -- logger.log('Message added:'||p_msg(l_index).message_text, l_scope, null, l_params);

  exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end add_message;


--------------------------------------------------------------------------------
--*
--* Receives a message table and will concatenate it into a
--* formatted varchar2(4000) value.
--* p_sep is used as the separator between the messages. You can
--* use chr(13)||chr(10) if working with a textarea or printing.
--*
--------------------------------------------------------------------------------
function format_error_messages (
    p_messages_tbl  in out NOCOPY ks_api.message_tbl_type
  , p_sep           in varchar2 default '<br>'
)
return varchar2
is
  -- l_scope   logger_logs.scope%type := gc_scope_prefix || 'format_error_messages';
  -- l_params  logger.tab_param;

  len       number;
  l_output  varchar2(4000);
begin
  -- logger.append_param(l_params, 'p_sep', p_sep);
  -- logger.log('BEGIN', l_scope, null, l_params);

  l_output := '';

  for i in 1..p_messages_tbl.COUNT loop
    len := 4000 - nvl(length(l_output),0) - length(p_sep);
    if len > 0 then
      l_output := l_output || substr(p_messages_tbl(i).message_text,1,len)
                    || p_sep;
    end if;
  end loop;

  -- logger.log('END', l_scope, null, l_params);
  return l_output;

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    raise;
end format_error_messages;



--------------------------------------------------------------------------------
--*
--* Receives a message table and will add the entries as
--* errors on the APEX page.
--*
--------------------------------------------------------------------------------
procedure set_page_errors(
    p_messages_tbl     in out NOCOPY ks_api.message_tbl_type
  , p_display_location in varchar2 default apex_error.c_inline_in_notification
)
is
  -- l_scope   logger_logs.scope%type := gc_scope_prefix || 'set_page_errors';
  -- l_params  logger.tab_param;
begin
  -- logger.append_param(l_params, 'p_display_location', p_display_location);
  -- logger.log_information('BEGIN', l_scope, null, l_params);


  for i in 1..p_messages_tbl.COUNT loop
    -- logger.log('message:' || i, l_scope);
    apex_error.add_error(
        p_message           => p_messages_tbl(i).message_text
      , p_display_location  => p_display_location
    );
  end loop;

  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    raise;
end set_page_errors;



end ks_api;
/
create or replace package body ks_util
as

--------------------------------------------------------------------------------
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

--------------------------------------------------------------------------------
function get_param(
  p_name_key  in ks_parameters.name_key%TYPE
)
return varchar2
is
  l_value ks_parameters.value%TYPE;
begin

  select value
    into l_value
    from ks_parameters
   where name_key = p_name_key;

  return l_value;

exception
  when NO_DATA_FOUND then
    return null;

end get_param;



--------------------------------------------------------------------------------
procedure set_param(
    p_name_key      in ks_parameters.name_key%TYPE
  , p_value         in ks_parameters.value%TYPE
)
is
begin

  update ks_parameters
     set value = p_value
   where name_key = p_name_key;

  if sql%rowcount = 0 then
    raise_application_error(
        -20001
      , 'Parameter ' || p_name_key || ' does not exist.'
    );
  end if;

end set_param;



--------------------------------------------------------------------------------
function get_email(
    p_username  in ks_users.username%TYPE
)
return varchar2
is
  -- l_scope   logger_logs.scope%type := gc_scope_prefix || 'get_email';
  -- l_params  logger.tab_param;

  l_email ks_users.email%TYPE;
begin
  -- logger.append_param(l_params, 'p_username', p_username);
  -- logger.log('START', l_scope, null, l_params);

  select email
    into l_email
    from ks_users
   where username = p_username;

  return l_email;

exception
  when NO_DATA_FOUND then
    -- logger.log_error('Probably an invalid user.');
    return null;

end get_email;




function format_full_name 
(
   p_first_name      IN      ks_users.first_name%TYPE,
   p_last_name       IN      ks_users.last_name%TYPE
)  RETURN VARCHAR2
IS
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'format_full_name';
  -- l_params logger.tab_param;
begin
--  logger.append_param(l_params, 'p_text', p_text);

  RETURN rtrim(p_first_name || ' ' || p_last_name);

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end format_full_name;






function is_number
(
  p_value        in         varchar2
) return boolean
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'is_number';
  -- l_params            logger.tab_param;
  
  non_numeric      exception;
  pragma exception_init (non_numeric, -06502);

  l_number     number;
begin
   l_number := p_value;

   return true;

exception
  when non_numeric then
    return false;
end is_number;





function string_to_coll (p_string in VARCHAR2) return sys.ODCIVarchar2List
is
  l_table wwv_flow_global.vc_arr2;
  l_list  sys.ODCIVarchar2List := new sys.ODCIVarchar2List();
begin
  l_table := apex_util.string_to_table(p_string);
  l_list.extend(l_table.count());
  for i in 1..l_table.count()
  loop
    l_list(i) := l_table(i);
  end loop;
  return l_list;
end string_to_coll;




function get_ir_order_by(p_ir_query    in varchar2
                       , p_default_pk  in varchar2 default '"ID"'
         ) 
  return varchar2
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_order_by';
  -- l_params            logger.tab_param;

  l_order_by          varchar2(32000);
  l_instr             number;
begin 
  -- logger.log('START', l_scope, null, l_params);

  l_instr := instr (p_ir_query, 'order by', -1);

  if l_instr > 0
  then
     -- grab the final order by from the IR query and trim off any trailing ")"
     l_order_by := rtrim (substr (p_ir_query, l_instr), ')');
  
  else -- add default order by for use by analytics lead/gag functions
    l_order_by := 'order by ' || p_default_pk; -- Use a column that's always present
  end if;

  -- logger.log('order by:' || l_order_by, l_scope, null, l_params);
  return l_order_by;

exception
  when others then
    null;
end get_ir_order_by;





function get_ir_report(p_page_id   in number
                     , p_static_id in varchar2)
  return apex_ir.t_report
is
  -- l_scope             logger_logs.scope%type := gc_scope_prefix || 'get_ir_report';
  -- l_params            logger.tab_param;

  l_region_id          number;
begin
  -- logger.append_param(l_params, 'p_page_id', p_page_id);
  -- logger.append_param(l_params, 'p_static_id', p_static_id);
  -- logger.log('START', l_scope, null, l_params);

  select region_id
    into l_region_id 
    from apex_application_page_regions
   where static_id = p_static_id
     and page_id   = p_page_id 
     and application_id = (select v('APP_ID') from dual);
      
  return apex_ir.get_report 
         (
            p_page_id   => p_page_id
          , p_region_id => l_region_id
         );

exception
    when OTHERS then
      -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
      raise;
end get_ir_report;



end ks_util;
/
create or replace package body ks_session_load_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant varchar2(31) := lower($$PLSQL_UNIT) || '.';



------------------------------------------------------------------------------
/**
 * Load rows from `ks_session_load` into `ks_sessions` and `ks_session_votes`.
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created September 2, 2016
 * @param p_app_user user loading data.
 * @param p_into_event_id event_id for the sessions being loaded.
 * @param p_into_track_id tracks_id for the sessions being loaded.
 */
procedure load_sessions(
    p_app_user       in ks_users.username%TYPE
  , p_into_event_id  in ks_event_tracks.event_id%TYPE
  , p_into_track_id  in ks_event_tracks.id%TYPE)
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'load_sessions';
  -- l_params logger.tab_param;

  l_session_id ks_sessions.id%type;

begin
  -- logger.append_param(l_params, 'p_app_user', p_app_user);
  -- logger.append_param(l_params, 'p_into_event_id', p_into_event_id);
  -- logger.append_param(l_params, 'p_into_track_id', p_into_track_id);
  -- logger.log('BEGIN', l_scope, null, l_params);


  for s in (
    with session_info as (
      select distinct l.app_user
           , l.session_num
           , l.sub_categorization
           , l.session_type
           , l."SESSION" title
           , l.primary_presenter
           , l.co_presenter
        from ks_session_load l
    )
    select l.session_num
         , l.sub_categorization
         , l.session_type
         , l.title
         -- , trim(regexp_replace(l.primary_presenter, '(.*)\((.*)\)','\1')) presenter
         , rtrim(substr(l.primary_presenter,1,instr(l.primary_presenter,'(',1,1)-1)) presenter
         , l.co_presenter
         -- , regexp_replace(l.primary_presenter, '(.*)\((.*)\)','\2') company
         , rtrim(substr(l.primary_presenter,instr(l.primary_presenter,'(',1,1)+1,length(substr(l.primary_presenter,instr(l.primary_presenter,'(',1,1)+1))-1)) company
     from session_info l
    where l.app_user = p_app_user
  )
  loop    

    insert into ks_sessions (
        event_id
      , event_track_id
      , session_num
      , sub_category
      , session_type
      , title
      , presenter
      , co_presenter
      , company
    )
    values (
        p_into_event_id
      , p_into_track_id
      , s.session_num
      , s.sub_categorization
      , s.session_type
      , s.title
      , s.presenter
      , s.co_presenter
      , s.company
    )
    returning id into l_session_id;

    -- Load votes for session
    insert into ks_session_votes (
        session_id
      , session_num
      , voter
      , vote
      , comments
    )
    select l_session_id
         , s.session_num
         , ld.voter
         , ld.total
         , ld."COMMENT" voter_comment
      from ks_session_load ld
     where ld.session_num = s.session_num;

  end loop;

  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    raise;
end load_sessions;




end ks_session_load_api;
/
create or replace package body ks_session_api
is

--------------------------------------------------------------------------------
-- TYPES
/**
 * @type
 */

-- CONSTANTS
/**
 * @constant gc_scope_prefix Standard logger package name
 */
gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';



------------------------------------------------------------------------------
/**
 * Description
 *
 *
 * @example
 * 
 * @issue
 *
 * @author Jorge Rimblas
 * @created September 9, 2016
 * @param p_event_id
 * @param p_presenter
 * @return
 */
procedure presenter_tracks_json(
    p_event_id  in ks_events.id%TYPE
  , p_presenter in ks_sessions.presenter%TYPE)
is
  -- l_scope logger_logs.scope%type := gc_scope_prefix || 'presenter_tracks_json';
  -- l_params logger.tab_param;

  list_cur sys_refcursor;
begin
  -- logger.append_param(l_params, 'p_event_id', p_event_id);
  -- logger.append_param(l_params, 'p_presenter', p_presenter);
  -- logger.log('BEGIN', l_scope, null, l_params);

  -- open list_cur for 
  -- select p_presenter "presenter", '<ul><li>' || listagg(nvl(t.alias, t.name), '</li><li>') within group (order by t.display_seq) || '</li></ul>' "trackList"
  --   from ks_event_tracks t
  --      , ks_sessions s
  --  where t.id s.event_track_id
  --    and s.event_id = to_number(p_event_id)
  --    and s.presenter = p_presenter
  -- );

  open list_cur for 
    select p_presenter "presenter"
         , '<ul><li>' ||listagg(n || ' in ' || p, '</li><li>') within group (order by display_seq) || '</li></ul>' "trackList"
    from (
      select t.display_seq, nvl(t.alias, t.name) p, count(*) n
        from ks_event_tracks t
           , ks_sessions s
       where t.id = s.event_track_id
         and s.event_id = to_number(p_event_id)
         and s.presenter = p_presenter
       group by t.display_seq, nvl(t.alias, t.name)
    );

  apex_json.write(list_cur);

  -- apex_json.open_object;
  -- apex_json.write('presenter', p_presenter);
  -- apex_json.write('trackList', '<ul><li>Track 1</li></ul>');
  -- apex_json.close_object;


  -- logger.log('END', l_scope, null, l_params);

exception
  when OTHERS then
    -- logger.log_error('Unhandled Exception', l_scope, null, l_params);
    apex_json.open_array;
    apex_json.open_object;
    apex_json.write('presenter', p_presenter);
    apex_json.write('trackList', 'Unable to fetch list:<br>' || sqlerrm || '<br>');
    apex_json.close_object;
    apex_json.close_array;
end presenter_tracks_json;




end ks_session_api;
/


create or replace view ks_sessions_v
as
with totals as (
  select d.session_id
       , sum(d.vote) votes_total
       , avg(d.vote) votes_average
   from ks_session_votes d
  group by d.session_id
)
select s.id
     , s.event_id
     , s.event_track_id
     , s.session_num
     , s.sub_category
     , s.session_type
     , s.title
     , s.presenter
     , s.company
     , s.co_presenter
     , s.status_code
     , s.notes
     , s.tags
     , t.votes_total
     , t.votes_average
     , s.created_by
     , s.created_on
     , s.updated_by
     , s.updated_on
  from ks_sessions s
     , totals t
 where s.id = t.session_id (+)
/


create or replace trigger ks_users_iu
before insert or update
on ks_users
referencing old as old new as new
for each row
declare
  l_pass_w_salt ks_users.password%TYPE;
begin
  if updating then
    :new.updated_on := sysdate;
    :new.updated_by := coalesce(
                           sys_context('APEX$SESSION','app_user')
                         , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                         , sys_context('userenv','session_user')
                       );
  end if;

  if :new.password is not null AND nvl(:new.password,'~NA~') != nvl(:old.password,'~NA~') then
    l_pass_w_salt := ks_sec.password_with_salt(:new.password);
    :new.password := l_pass_w_salt;
  else
    :new.password := :old.password;
  end if;
end;
/
alter trigger ks_users_iu enable;
--  Post Install ---------------------------
--------------------------------------------------------
-- Replace previosul trigger
create or replace trigger ks_sessions_iu_trg 
before insert or update
on ks_sessions
referencing old as old new as new
for each row
begin
  if updating then
    :new.updated_on := sysdate;
    :new.updated_by := coalesce(
                          sys_context('APEX$SESSION','app_user')
                        , regexp_substr(sys_context('userenv','client_identifier'),'^[^:]*')
                        , sys_context('userenv','session_user')
                       );
  end if;
  ks_tags_api.tag_sync(
      p_new_tags      => :new.tags
    , p_old_tags      => :old.tags
    , p_content_type  => 'SESSION' || ':' || :new.event_track_id
    , p_content_id    => :new.session_num );
end;
/

create or replace trigger ks_sessions_bd_trg
    before delete on ks_sessions
    for each row
begin
  ks_tags_api.tag_sync(
      p_new_tags      => null
    , p_old_tags      => :old.tags
    , p_content_type  => 'SESSION' || ':' || :old.event_track_id
    , p_content_id    => :old.session_num );
end;
/
-- ========================================
--  Seed Users -----------------------------
PRO seed ks_users

SET DEFINE OFF;
delete from ks_users;
insert into ks_users(username, password, first_name, last_name, email, active_ind, admin_ind) values ('JRIMBLAS','welcome','Jorge','Rimblas','jorge@rimblas.com', 'Y', 'Y');
insert into ks_users(username, password, first_name, last_name, email, active_ind, admin_ind) values ('FMIGNAULT','welcome','Francis','Mignault','fmignault@insum.ca', 'Y', 'Y');
insert into ks_users(username, password, first_name, last_name, email, active_ind, admin_ind) values ('GALO','welcome','Galo','Balda','galo.balda@gmail.com', 'Y', 'N');
insert into ks_users(username, password, first_name, last_name, email, active_ind, admin_ind) values ('TGERMAN','welcome','Tim','German','tim.german@qubix.com', 'Y', 'N');
